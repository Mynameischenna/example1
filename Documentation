java.net.ConnectException: Connection timed out: connect
	at java.base/sun.nio.ch.Net.connect0(Native Method)
	at java.base/sun.nio.ch.Net.connect(Net.java:589)
	at java.base/sun.nio.ch.Net.connect(Net.java:578)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:583)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:751)
	at java.base/sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:304)
	at java.base/sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:181)
	at java.base/sun.net.NetworkClient.doConnect(NetworkClient.java:183)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:531)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:636)
	at java.base/sun.net.www.protocol.https.HttpsClient.<init>(HttpsClient.java:264)
	at java.base/sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:377)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:193)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1237)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1123)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:179)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1446)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1417)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getOutputStream(HttpsURLConnectionImpl.java:219)
	at com.ecm1.ECM1.service.AuthID.getAuthorizationID(AuthID.java:57)
	at com.ecm1.ECM1.service.Service1.sendPostScanSheets(Service1.java:132)
	at com.ecm1.ECM1.service.Service1.processFilesAndCreateJson(Service1.java:54)
	at com.ecm1.ECM1.controller.ECMcontroller.processFiles(ECMcontroller.java:20)
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:28)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:19)
java.net.ConnectException: Connection timed out: connect
	at java.base/sun.nio.ch.Net.connect0(Native Method)
	at java.base/sun.nio.ch.Net.connect(Net.java:589)
	at java.base/sun.nio.ch.Net.connect(Net.java:578)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:583)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:751)
	at java.base/sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:304)
	at java.base/sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:181)
	at java.base/sun.net.NetworkClient.doConnect(NetworkClient.java:183)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:531)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:636)
	at java.base/sun.net.www.protocol.https.HttpsClient.<init>(HttpsClient.java:264)
	at java.base/sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:377)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:193)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1237)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1123)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:179)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream0(HttpURLConnection.java:1675)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getInputStream(HttpURLConnection.java:1599)
	at java.base/java.net.HttpURLConnection.getResponseCode(HttpURLConnection.java:531)
	at java.base/sun.net.www.protocol.https.HttpsURLConnectionImpl.getResponseCode(HttpsURLConnectionImpl.java:307)
	at com.ecm1.ECM1.service.AuthID.getAuthorizationID(AuthID.java:67)
	at com.ecm1.ECM1.service.Service1.sendPostScanSheets(Service1.java:132)
	at com.ecm1.ECM1.service.Service1.processFilesAndCreateJson(Service1.java:54)
	at com.ecm1.ECM1.controller.ECMcontroller.processFiles(ECMcontroller.java:20)
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:28)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:19)
done auth id is 
error in processing file
2025-02-25T08:21:41.692-07:00  WARN 3480 --- [ECM1] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-02-25T08:21:42.274-07:00  INFO 3480 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8082 (http) with context path '/'
2025-02-25T08:21:42.290-07:00  INFO 3480 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Started Ecm1Application in 70.493 seconds (process running for 72.084)
ECM Application is running...
package com.ecm1.ECM1.service;

import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URL;
@Service
public class AuthID {
    private final String runType = "PROD";
    public String getAuthorizationID() {

        String authorizationID = "";
        try {

            /*
             * Set up POST request for authorization key
             */
            URL authorizationUrl = null;
            if (runType.equals("PROD")) {
                authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
            } else if (runType.equals("DEV")) {
                authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
            }

            /*
             * Define JSON object
             */
            String authorizationJSON = "{\n";
            if (runType.equals("PROD")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
            } else if (runType.equals("DEV")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
            }
            authorizationJSON = authorizationJSON + "}\n";

            /*
             * Open connection
             */
            HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

            /*
             * Setup connection properties
             */
            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");

            /*
             * Write POST request
             */
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = authorizationJSON.getBytes("utf-8");
                os.write(input, 0, input.length);
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
             * Get response status
             */
            int status = connection.getResponseCode();

            /*
             * Should be 204, no content returned But we will get the authorization key
             * returned in a header record
             */
            if (status == HttpURLConnection.HTTP_NO_CONTENT) {
                authorizationID = connection.getHeaderField("Authorization");
                System.out.println(authorizationID);
            }
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return authorizationID;
    }
}



IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (master)
$ git pull origin main
fatal: couldn't find remote ref main

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (master)
$ git checkout -b branchb
Switched to a new branch 'branchb'

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git push origin branchb
Total 0 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
remote:
remote: To create a merge request for branchb, visit:
remote:   https://gitlab.retirementpartner.com/chnksv/ecm1/-/merge_requests/new?merge_request%5Bsource_branch%5D=branchb
remote:
To https://gitlab.retirementpartner.com/chnksv/ecm1.git
 * [new branch]      branchb -> branchb

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git add .

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git commit -m "added into b"
On branch branchb
nothing to commit, working tree clean

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git push origin branchb
Everything up-to-date

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git commit -m "added into b"
On branch branchb
nothing to commit, working tree clean

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git add .

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git commit -m "added into b"
On branch branchb
nothing to commit, working tree clean

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$ git push origin branchb
Everything up-to-date

IND+chnksv@appcompl04d MINGW64 /c/JAVA chenna/testgit/ecm1 (branchb)
$



Monitoring Stopped EC2 Instances with AWS EventBridge and Step Functions
Objective:
You want to monitor an EC2 instance using AWS EventBridge, trigger a Step Function when the instance stops, and then execute two Lambda functions:

First Lambda: Send an email immediately when the instance stops.
Second Lambda: Wait for 1 hour, check if the instance is still stopped, and if so, send an escalation email.
Components Involved:
AWS EventBridge: To detect the EC2 Stop state.
AWS Step Functions: To manage the workflow.
Two AWS Lambda Functions:
First Lambda: Sends an immediate email when the instance stops.
Second Lambda: Sends an escalation email after 1 hour if the instance remains stopped.
Amazon SNS (Simple Notification Service): For sending emails.
IAM Roles and Policies: To grant the necessary permissions for EventBridge, Step Functions, and Lambda.
Step 1: Create SNS Topics for Email Notifications
Navigate to the Amazon SNS console.
Create two SNS topics:
Immediate Alert Topic (for the first Lambda to send an email when the instance stops).
Escalation Alert Topic (for the second Lambda to send an email after 1 hour).
Subscribe your email address to both topics.
Step 2: Create Lambda Functions
Lambda Function 1: Sends an Immediate Email
Go to the Lambda Console and create a new function.
Name it SendImmediateAlertLambda.
Assign the appropriate permissions to allow publishing messages to the SNS topic.
Add this Python (or Node.js, depending on preference) code for the function:
Python Code Example:

python
Copy code
import json
import boto3

sns = boto3.client('sns')

def lambda_handler(event, context):
    # Retrieve the SNS topic ARN
    sns_topic_arn = 'arn:aws:sns:REGION:ACCOUNT_ID:ImmediateAlertTopic'
    
    # Create a message
    message = f"EC2 instance {event['detail']['instance-id']} has been stopped."
    
    # Publish the message to SNS
    response = sns.publish(
        TopicArn=sns_topic_arn,
        Message=message,
        Subject='EC2 Instance Stopped',
    )
    
    return {
        'statusCode': 200,
        'body': json.dumps('Immediate Alert Sent!')
    }
Deploy the function.
Lambda Function 2: Sends an Escalation Email After 1 Hour
Create another Lambda function and name it SendEscalationAlertLambda.
Assign the appropriate permissions to allow publishing messages to the SNS topic.
Add the following code to check if the instance is still stopped and send the escalation email:
Python Code Example:

python
Copy code
import boto3
import json

ec2 = boto3.client('ec2')
sns = boto3.client('sns')

def lambda_handler(event, context):
    instance_id = event['detail']['instance-id']
    
    # Check the instance state
    response = ec2.describe_instance_status(InstanceIds=[instance_id])
    instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
    
    if instance_state == 'stopped':
        # Send escalation email if instance is still stopped
        sns_topic_arn = 'arn:aws:sns:REGION:ACCOUNT_ID:EscalationAlertTopic'
        message = f"EC2 instance {instance_id} is still stopped after 1 hour."
        
        sns.publish(
            TopicArn=sns_topic_arn,
            Message=message,
            Subject='EC2 Instance Escalation Alert',
        )
        
        return {
            'statusCode': 200,
            'body': json.dumps('Escalation Alert Sent!')
        }
    else:
        return {
            'statusCode': 200,
            'body': json.dumps('Instance is no longer stopped.')
        }
Deploy the function.
Step 3: Set Up AWS Step Functions
Go to the Step Functions console and create a new state machine.
Define the following workflow:
First Task: Trigger SendImmediateAlertLambda.
Wait for 1 Hour: Add a wait state that pauses the workflow for 1 hour.
Second Task: Trigger SendEscalationAlertLambda.
Example State Machine Definition (Amazon States Language):

json
Copy code
{
  "Comment": "State machine to handle EC2 stopped instance alerts",
  "StartAt": "SendImmediateAlert",
  "States": {
    "SendImmediateAlert": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:SendImmediateAlertLambda",
      "Next": "Wait1Hour"
    },
    "Wait1Hour": {
      "Type": "Wait",
      "Seconds": 3600,
      "Next": "SendEscalationAlert"
    },
    "SendEscalationAlert": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function:SendEscalationAlertLambda",
      "End": true
    }
  }
}
Deploy the state machine.
Step 4: Create EventBridge Rule
Go to the EventBridge console and create a new rule.
Set the event source to EC2 and use the following event pattern to capture EC2 stop events:
json
Copy code
{
  "source": ["aws.ec2"],
  "detail-type": ["EC2 Instance State-change Notification"],
  "detail": {
    "state": ["stopped"]
  }
}
Set the target as the Step Functions state machine created in step 3.
Deploy the rule.
Step 5: Test the Setup
Stop the EC2 instance manually or wait for it to stop.
Check if the first Lambda function triggers and sends the immediate email.
After 1 hour, verify if the second Lambda function triggers and sends the escalation email if the instance remains stopped.
IAM Roles and Permissions:
Make sure your Lambda functions and Step Functions have the necessary permissions:

Lambda Functions: Need permissions to publish to SNS and describe EC2 instances.
Step Functions: Need permissions to invoke the Lambda functions.
Here’s a sample IAM policy for the Lambda functions:

json
Copy code
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "sns:Publish",
        "ec2:DescribeInstanceStatus"
      ],
      "Resource": "*"
    }
  ]
}
And a sample policy for Step Functions to invoke Lambda:

json
Copy code
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "lambda:InvokeFunction",
      "Resource": [
        "arn:aws:lambda:REGION:ACCOUNT_ID:function:SendImmediateAlertLambda",
        "arn:aws:lambda:REGION:ACCOUNT_ID:function:SendEscalationAlertLambda"
      ]
    }
  ]
}
Conclusion:
By following this setup, your EventBridge rule will detect when an EC2 instance stops, trigger a Step Functions workflow to send an immediate email, and then wait for 1 hour to send an escalation email if necessary.

package com.hrlc.compliance.ecmstore;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;

import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.content.StringBody;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

public class PostAPINew {

	private ModelMain modelMain;
	private boolean status;
	private String inputDocFileName;

	/*
	 * Setup for DEV or PROD
	 */
	private final String runType ="PROD";
	//	private final String runType ="DEV";

	public PostAPINew() {
	}

	public PostAPINew(ModelMain modelMain) {
		this.modelMain = modelMain;
	}

	public boolean sendPostCompliance(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDate(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDate(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDate(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "SmartSubmission" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	/*
	 * Build JSON for document
	 */
	private String buildDocuData(FileSystemResource resource) {
		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Start of docuData
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n";
				
		if (dbinst == null || dbinst.equals("")) {
			docuData = docuData  
			+ "			\"name\": \"" + planName.trim() + "\"\n";
//			+ "			\"name\": \"" + planName.trim() + "\",\n";
//			+ "			\"source\": \"" + "" + "\"\n";
//			+ "			\"source\": \"" + "401k" + "\"\n";
		}
		else {
			docuData = docuData 
				+ "			\"name\": \"" + planName.trim() + "\",\n" 
				+ "			\"source\": \"" + dbinst.trim() + "\"\n";
		}
		docuData = docuData 
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "ScanSheets" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";
		return docuData;
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	public void postOne() {
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";

		// Create the request body as per the API's requirements
		String requestBody = "{\"key1\":\"value1\", \"key2\":\"value2\"}"; // Replace with your actual request body

		// Set the headers
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		// Create the request entity
		HttpEntity<String> requestEntity = new HttpEntity<>(requestBody, headers);

		// Create a RestTemplate
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response
		System.out.println("Response status: " + response.getStatusCode());
		System.out.println("Response body: " + response.getBody());
	}

	public void postJoel() {

		/*
		 * Write out the doc first
		 */
		File file = null;
		String fileName = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		file = new File(fileName);
		if (!file.exists()) {
			System.out.println("Error - Output file does not exist - " + fileName);
			return;
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}

		MultipartFile multipartFile = new MockMultipartFile(fileName, fileName, "application/pdf", image);

		/*
		 * Setup for multipart POST request
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";
		String docuBody = "ContentType.APPLICATION_JSON";
		String typeBody = "plan";
		String mimeBody = "application/pdf";

		/*
		 * Joel
		 */
		HttpHeaders httpHeaders = new HttpHeaders();
		MultiValueMap<String, Object> mvmBody = new LinkedMultiValueMap<>();

		HttpEntity requestEntity = null;
		Resource resource = null;

		httpHeaders.setContentType(org.springframework.http.MediaType.MULTIPART_FORM_DATA);

		resource = multipartFile.getResource();
		mvmBody.add("typeOfDocument", typeBody);
		mvmBody.add("mimeType", mimeBody);
		mvmBody.add("documentProperties", docuData);
		mvmBody.add("file", resource);

		requestEntity =  new HttpEntity<>(mvmBody, httpHeaders);

		RestTemplate restTemplate = new RestTemplate();

		URI location = null;
		try {
			location = new URI("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (URISyntaxException e) {
			e.printStackTrace();
		}
		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.setLocation(location);
		ResponseEntity responseAddDocumentResponseDTO = restTemplate.postForEntity(location, requestEntity, ResponseEntity.class);
		System.out.println(responseAddDocumentResponseDTO.getStatusCodeValue());

	}

	public String fixDate(String currDate) {
		if (currDate == null) {
			return "";
		}
		if (!currDate.equals(null) && !currDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("MM-dd-yyyy HH:mm:ss");

			//			String dateIn = currDate +" 00:00";
			String dateIn = currDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public String fixDateSS(String currDate) {
		if (currDate == null) {
			return "";
		}

		/*
		 * Convert to proper date
		 */
		if (!currDate.equals(null) && !currDate.equals("")) {
			/*
			 * Check month case
			 */
			StringBuffer newDate = new StringBuffer(currDate);
			int ln = newDate.length();

			// Conversion to proper month pascal case
			for (int i = 3; i<=3; i++) {
				newDate.setCharAt(i, Character.toUpperCase(currDate.charAt(i)));
			}
			for (int i = 4; i<=5; i++) {
				newDate.setCharAt(i, Character.toLowerCase(currDate.charAt(i)));
			}

			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

			String dateIn = newDate.toString().trim() +" 00:00:00";
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public static void main(String[] args) {

		PostAPINew testPostman = new PostAPINew();
		//		testPostman.postJoel();
		//		testPostman.doGet();
		//		testPostman.doPost();
		;
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

		MultiValueMap<String, String> map= new LinkedMultiValueMap<String, String>();
		map.add("email", "first.last@example.com");

		HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map, headers);

		try {
			URL url = new URL("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		RestTemplate restTemplate = new RestTemplate();
		System.out.println("Test");
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
	}

}


















public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}



/*
 * Class: ECMStore
 * Author: Paul Raab
 * Date: January 9, 2023
 * Group: HRLC
 * Main application for loading files into Empower ECM.
 * Replaces ContentCollector
 */
package com.hrlc.compliance.ecmstore;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.apache.commons.io.FilenameUtils;

public class ECMStore {

	private static Logger logger = null;

	/*
	 * Setup for DEV or PROD
	 */
	//	private static String runType = "PROD";
	//	private static String runType = "DEV";
	private static String runType = "UAT";

	public static void main(String[] args) {

		ModelMain modelMain = new ModelMain();
		ParseXML parseXML = new ParseXML(modelMain);
		//		PostAPI postAPI = new PostAPI(modelMain);
		PostAPINew postAPI = new PostAPINew(modelMain);
		Hashtable<String,String> xmlFileHash = new Hashtable<>();
		Hashtable<String,String> docFileHash = new Hashtable<>();

		/*
		 * Do Compliance job
		 */
		String imageDir = "";
		String imageDirCompleted = "";

		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Success\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging\\Test";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Test\\Success\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging\\Test";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Test\\Success\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);
		logger = modelMain.getLogger();
		
		/*
		 * Loop through all files
		 */
		Enumeration<String> e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("Compliance");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostCompliance(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				System.out.println("LocalDateTime : "
						+ todayDT);
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				/*
				 * If production, move files
				 */
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
			} catch (IOException e1) {
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}

		/*
		 * Do SmartSubmission job
		 */
		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Completed\\SmartSubmission\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Test\\Completed\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Test\\Completed\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);

		/*
		 * Loop through all files
		 */
		e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("SmartSubmission");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostSmartSubmission(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				System.out.println("LocalDateTime : "
						+ todayDT);
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}

		/*
		 * Do ScanSheets job
		 */
		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\online\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Completed\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\online\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Test\\Completed\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\online\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Test\\Completed\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);

		/*
		 * Loop through all files
		 */
		e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("ScanSheets");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostScanSheets(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}
		modelMain.closeLog();


	}

}




package com.hrlc.compliance.ecmstore;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;

import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.content.StringBody;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.util.logging.Logger;

public class PostAPINew {

	private ModelMain modelMain;
	private boolean status;
	private String inputDocFileName;
	private static Logger logger = null;

	/*
	 * Setup for DEV or PROD
	 */
	//	private final String runType ="PROD";
	//	private final String runType ="DEV";
	private final String runType ="UAT";

	public PostAPINew() {
	}

	public PostAPINew(ModelMain modelMain) {
		super();
		this.modelMain = modelMain;
		logger = modelMain.getLogger();
	}

	public boolean sendPostCompliance(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDate(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDate(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDate(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
		if (!fileName.contains(groupID.trim())) {
			logger.info("Compliance");
			logger.info("Error - FileName - PlanNumber mismatch - skip");
			logger.info("FileName = " + fileName);
			logger.info("PlanNumber = " + groupID.trim());
			return false;
		}
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
//		if (!fileName.contains(groupID.trim())) {
//			logger.info("SmartSubmission");
//			logger.info("Error - FileName - PlanNumber mismatch - skip");
//			logger.info("FileName = " + fileName);
//			logger.info("PlanNumber = " + groupID.trim());
//			return false;
//		}
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "SmartSubmission" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);
		if (docuData == null) {
			return false;
		}

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	/*
	 * Build JSON for document
	 */
	private String buildDocuData(FileSystemResource resource) {
		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		if (dbinst == null || dbinst == "") {
			dbinst = "INST";
		}
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
		if (!fileName.contains(groupID.trim())) {
			logger.info("ScanSheets");
			logger.info("Error - FileName - PlanNumber mismatch - skip");
			logger.info("FileName = " + fileName);
			logger.info("PlanNumber = " + groupID.trim());
			return null;
		}

		/*
		 * Start of docuData
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n";
				
		if (dbinst == null || dbinst.equals("")) {
			docuData = docuData  
			+ "			\"name\": \"" + planName.trim() + "\"\n";
//			+ "			\"name\": \"" + planName.trim() + "\",\n";
//			+ "			\"source\": \"" + "" + "\"\n";
//			+ "			\"source\": \"" + "INST" + "\"\n";
		}
		else {
			docuData = docuData 
				+ "			\"name\": \"" + planName.trim() + "\",\n" 
				+ "			\"source\": \"" + dbinst.trim() + "\"\n";
		}
		docuData = docuData 
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "ScanSheets" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";
		return docuData;
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}
			else if (runType.equals("UAT")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			else if (runType.equals("UAT")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	public void postOne() {
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";

		// Create the request body as per the API's requirements
		String requestBody = "{\"key1\":\"value1\", \"key2\":\"value2\"}"; // Replace with your actual request body

		// Set the headers
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		// Create the request entity
		HttpEntity<String> requestEntity = new HttpEntity<>(requestBody, headers);

		// Create a RestTemplate
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response
		System.out.println("Response status: " + response.getStatusCode());
		System.out.println("Response body: " + response.getBody());
	}

	public void postJoel() {

		/*
		 * Write out the doc first
		 */
		File file = null;
		String fileName = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		file = new File(fileName);
		if (!file.exists()) {
			System.out.println("Error - Output file does not exist - " + fileName);
			return;
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}

		MultipartFile multipartFile = new MockMultipartFile(fileName, fileName, "application/pdf", image);

		/*
		 * Setup for multipart POST request
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";
		String docuBody = "ContentType.APPLICATION_JSON";
		String typeBody = "plan";
		String mimeBody = "application/pdf";

		/*
		 * Joel
		 */
		HttpHeaders httpHeaders = new HttpHeaders();
		MultiValueMap<String, Object> mvmBody = new LinkedMultiValueMap<>();

		HttpEntity requestEntity = null;
		Resource resource = null;

		httpHeaders.setContentType(org.springframework.http.MediaType.MULTIPART_FORM_DATA);

		resource = multipartFile.getResource();
		mvmBody.add("typeOfDocument", typeBody);
		mvmBody.add("mimeType", mimeBody);
		mvmBody.add("documentProperties", docuData);
		mvmBody.add("file", resource);

		requestEntity =  new HttpEntity<>(mvmBody, httpHeaders);

		RestTemplate restTemplate = new RestTemplate();

		URI location = null;
		try {
			location = new URI("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (URISyntaxException e) {
			e.printStackTrace();
		}
		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.setLocation(location);
		ResponseEntity responseAddDocumentResponseDTO = restTemplate.postForEntity(location, requestEntity, ResponseEntity.class);
		System.out.println(responseAddDocumentResponseDTO.getStatusCodeValue());

	}

	public String fixDate(String currDate) {
		if (currDate == null) {
			return "";
		}
		if (!currDate.equals(null) && !currDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("MM-dd-yyyy HH:mm:ss");

			//			String dateIn = currDate +" 00:00";
			String dateIn = currDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public String fixDateSS(String currDate) {
		if (currDate == null) {
			return "";
		}

		/*
		 * Convert to proper date
		 */
		if (!currDate.equals(null) && !currDate.equals("")) {
			/*
			 * Check month case
			 */
			StringBuffer newDate = new StringBuffer(currDate);
			int ln = newDate.length();

			// Conversion to proper month pascal case
			for (int i = 3; i<=3; i++) {
				newDate.setCharAt(i, Character.toUpperCase(currDate.charAt(i)));
			}
			for (int i = 4; i<=5; i++) {
				newDate.setCharAt(i, Character.toLowerCase(currDate.charAt(i)));
			}

			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

			String dateIn = newDate.toString().trim() +" 00:00:00";
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public static void main(String[] args) {

		PostAPINew testPostman = new PostAPINew();
		//		testPostman.postJoel();
		//		testPostman.doGet();
		//		testPostman.doPost();
		;
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

		MultiValueMap<String, String> map= new LinkedMultiValueMap<String, String>();
		map.add("email", "first.last@example.com");

		HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map, headers);

		try {
			URL url = new URL("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		RestTemplate restTemplate = new RestTemplate();
		System.out.println("Test");
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
	}

}





/**
 * Title: ModelTest
 * Description: Model for the Test application. Communicates with the View
 * and Control about state changes and settings. Stores information about
 * the parameter settings, the input and output files, and the view display.
 *
 * Interesting notes:
 * Notify() can be turned on or off. Typically, if you are loading a large
 * runstream, Notify() will be turned off until the entire file is loaded
 * and processed, and then a global notify is sent, and the auto Notify()
 * is turned back on.
 * @author Paul Raab
 * @version 1.0
 */

package com.hrlc.compliance.ecmstore;

import java.io.*;
import javax.swing.*;

import org.apache.commons.io.FilenameUtils;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.regex.Pattern;

public class ModelMain {

	private String inputDocFileName;
	private String inputXMLFileName;
	
	private String AccessCode;
	private String ActionRequired;
	private String AvailableOnline;
	private String Category;
	private String dbinst;
	private String DocumentGroup;
	private String DocumentClass;
	private String DMTYCODE;
	private String DocumentDescription;
	private String EffDate;
	private String FriendlyName;
	private String GroupID;
	private String PlanName;
	private String PeriodBegin;
	private String PeriodEnd;
	private String SortOrder;
	
	private String DocumentTitle; // FriendlyName from XML
	private String BatchName; // ICC Ingestion-<file name>
	private String CategorySubclass; // category from XML
	private String DatabaseInstance; // dbinst from XML
	private String EffectiveDate; // EffDate from XML
	private String ExternalView; // AvailableOnline from XML
	private String DocumentType; // friendlyname from XML
	private String PlanNumber; // GroupID from XML
	private String smart_submission_packages; // FriendlyName from XML
	
	private static Logger logger = null;
	private static FileHandler handler = null;

	public ModelMain() {
		
		handler = null;
		boolean append = true;
		try {
			handler = new FileHandler("C:\\ECMStoreLog\\default.log", append);
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		SimpleFormatter formatter = new SimpleFormatter();    
		handler.setFormatter(formatter);
		logger = Logger.getLogger("com.hrlc.compliance.ecmstore");
		logger.addHandler(handler);

		logger.info("ECMStore start");

	}

	public String getInputDocFileName() {
		return inputDocFileName;
	}

	public void setInputDocFileName(String inputDocFileName) {
		this.inputDocFileName = inputDocFileName;
	}

	public String getInputXMLFileName() {
		return inputXMLFileName;
	}

	public void setInputXMLFileName(String inputXMLFileName) {
		this.inputXMLFileName = inputXMLFileName;
	}
	
	public String getAccessCode() {
		return AccessCode;
	}

	public void setAccessCode(String accessCode) {
		AccessCode = accessCode;
	}

	public String getActionRequired() {
		return ActionRequired;
	}

	public void setActionRequired(String actionRequired) {
		ActionRequired = actionRequired;
	}

	public String getAvailableOnline() {
		return AvailableOnline;
	}

	public void setAvailableOnline(String availableOnline) {
		AvailableOnline = availableOnline;
	}

	public String getCategory() {
		return Category;
	}

	public void setCategory(String category) {
		Category = category;
	}

	public String getDbinst() {
		return dbinst;
	}

	public void setDbinst(String dbinst) {
		this.dbinst = dbinst;
	}

	public String getDocumentClass() {
		return DocumentClass;
	}

	public void setDocumentClass(String documentClass) {
		DocumentClass = documentClass;
	}

	public String getDMTYCODE() {
		return DMTYCODE;
	}

	public void setDMTYCODE(String dMTYCODE) {
		DMTYCODE = dMTYCODE;
	}

	public String getDocumentDescription() {
		return DocumentDescription;
	}

	public void setDocumentDescription(String documentDescription) {
		DocumentDescription = documentDescription;
	}

	public String getEffDate() {
		return EffDate;
	}

	public void setEffDate(String effDate) {
		EffDate = effDate;
	}

	public String getFriendlyName() {
		return FriendlyName;
	}

	public void setFriendlyName(String friendlyName) {
		FriendlyName = friendlyName;
	}

	public String getGroupID() {
		return GroupID;
	}

	public void setGroupID(String groupID) {
		GroupID = groupID;
	}

	public String getPeriodBegin() {
		return PeriodBegin;
	}

	public void setPeriodBegin(String periodBegin) {
		PeriodBegin = periodBegin;
	}

	public String getPeriodEnd() {
		return PeriodEnd;
	}

	public void setPeriodEnd(String periodEnd) {
		PeriodEnd = periodEnd;
	}

	public String getDocumentTitle() {
		return DocumentTitle;
	}

	public void setDocumentTitle(String documentTitle) {
		DocumentTitle = documentTitle;
	}

	public String getBatchName() {
		return BatchName;
	}

	public void setBatchName(String batchName) {
		BatchName = batchName;
	}

	public String getCategorySubclass() {
		return CategorySubclass;
	}

	public void setCategorySubclass(String categorySubclass) {
		CategorySubclass = categorySubclass;
	}

	public String getDatabaseInstance() {
		return DatabaseInstance;
	}

	public void setDatabaseInstance(String databaseInstance) {
		DatabaseInstance = databaseInstance;
	}

	public String getDocumentGroup() {
		return DocumentGroup;
	}

	public void setDocumentGroup(String documentGroup) {
		this.DocumentGroup = documentGroup;		
	}

	public String getEffectiveDate() {
		return EffectiveDate;
	}

	public void setEffectiveDate(String effectiveDate) {
		EffectiveDate = effectiveDate;
	}

	public String getExternalView() {
		return ExternalView;
	}

	public void setExternalView(String externalView) {
		ExternalView = externalView;
	}

	public String getDocumentType() {
		return DocumentType;
	}

	public void setDocumentType(String documentType) {
		DocumentType = documentType;
	}

	public String getPlanName() {
		return PlanName;
	}

	public void setPlanName(String planName) {
		PlanName = planName;
	}

	public String getPlanNumber() {
		return PlanNumber;
	}

	public void setPlanNumber(String planNumber) {
		PlanNumber = planNumber;
	}

	public String getSmart_submission_packages() {
		return smart_submission_packages;
	}

	public void setSmart_submission_packages(String smart_submission_packages) {
		this.smart_submission_packages = smart_submission_packages;
	}
	
	public String getSortOrder() {
		return SortOrder;
	}
	
	public void setSortOrder(String sortOrder) {
		this.SortOrder = sortOrder;
	}

	/*
	 * Get all the files in a template directory
	 * store in a fileHash Hashtable data structure
	 * Look for only *.docx files
	 */
	public void getFiles(String templateDir, Hashtable<String, String> xmlFileHash,
						 Hashtable<String, String> docFileHash) {

		/*
		 * Set directory name
		 */
		File fileTemplateDir = new File(templateDir);
		String delims  = ".";

		/*
		 * Process all files in directory
		 */
		if (fileTemplateDir.listFiles() == null) {
			return;
		}
		for (final File fileEntry : fileTemplateDir.listFiles()) {

			/*
			 * Debug output
			 */
			String fileName = fileEntry.getName();
			if (fileEntry.isDirectory()) {
				System.out.println("Directory: " + fileEntry.getName());
				continue;
			}
			else if (FilenameUtils.getExtension(fileName) != null &&
					FilenameUtils.getExtension(fileName).equals("xml")) {
				System.out.println("XML" + fileEntry.getName());
				String[] tokenString = fileEntry.getName().split(Pattern.quote("."));

				/*
				 * Get file path
				 */
				String filePath = fileEntry.getPath();

				/*
				 * Put filePath into fileHash using planNumber as key
				 */
				xmlFileHash.put(tokenString[0], filePath);

			}
			else if (FilenameUtils.getExtension(fileName) != null &&
					FilenameUtils.getExtension(fileName).equals("pdf")) {
				System.out.println("PDF " + fileEntry.getName());
				String testStr = fileEntry.getName();
				String[] tokenString = testStr.split(Pattern.quote("."));

				/*
				 * Get file path
				 */
				String filePath = fileEntry.getPath();

				/*
				 * Put filePath into fileHash using planNumber as key
				 */
				docFileHash.put(tokenString[0], filePath);
			}
			else {
				System.out.println(fileEntry.getName());
				continue;
			}

		}
	}
	
	/*
	 * Close log file
	 */
	public void closeLog() {
		handler.close();
	}

	public Logger getLogger() {
		return this.logger;
	}

}





/*
 * Class: DocuSignPostAPI
 * Author: Paul Raab
 * Date: November 11, 2020
 * Group: HRLC
 * Class to build and send POST request to DocuSign API.
 * 
 * Use:
 * https://hc.apache.org/httpcomponents-client-ga/httpmime/examples/org/apache/http/examples/entity/mime/ClientMultipartFormPost.java
 * For formatting response as JSON
 * https://stackoverflow.com/questions/20374156/sending-and-parsing-response-using-http-client-for-a-json-list
 * ====================================================================
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 * 
 * 06/01/2021
 * Add More detail on response header
 *
 */
package com.hrlc.compliance.ecmstore;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.apache.commons.codec.Charsets;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.ParseException;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.InputStreamBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
//import org.springframework.http.HttpEntity;

/**
 * Example how to use multipart/form encoded POST request.
 */
public class PostAPI {

	private String inputDocFileName;
	private String inputXMLFileName;

	private String DocumentTitle; // FriendlyName from XML
	private String BatchName; // ICC Ingestion-<file name>
	private String CategorySubclass; // category from XML
	private String DatabaseInstance; // dbinst from XML
	private String EffectiveDate; // EffDate from XML
	private String ExternalView; // AvailableOnline from XML
	private String DocumentType; // friendlyname from XML
	private String PlanName; // PlanName from XML
	private String PlanNumber; // GroupID from XML
	private String smart_submission_packages; // FriendlyName from XML

	private String httpStatus = null;
	private String envelopeId = null;
	private String errorDetails = null;
	private String statusStr = null;
	private String statusDateTime = null;
	private boolean status;
	private String error;
	private String message;

	private ArrayList<InputStreamBody> isb = null;

	private ModelMain modelMain;

	private final String runType ="PROD";
	//	private final String runType ="DEV";
	//	private final String runType ="DEVNOAPI";

	public PostAPI(ModelMain modelMain) {
		this.modelMain = modelMain;
	}

	public String getStatusStr() {
		return statusStr;
	}

	public void setStatusStr(String statusStr) {
		this.statusStr = statusStr;
	}

	public String getStatusDateTime() {
		return statusDateTime;
	}

	public void setStatusDateTime(String statusDateTime) {
		this.statusDateTime = statusDateTime;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	/*
	 * Send SmartSubmission POST request
	 */
	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		CloseableHttpClient httpClient = null;
		CloseableHttpResponse httpResponse = null;

		RequestConfig requestConfig = RequestConfig.custom()
				.setConnectionRequestTimeout(100000)
				.setConnectTimeout(100000)
				.setSocketTimeout(100000)
				.build();
		httpClient = HttpClients.custom()
				.setDefaultRequestConfig(requestConfig)
				.build();

		/*
		 * Build the POST request
		 */
		URI uri = null;
		URIBuilder uriBuilder = null;

		/*
		 * Add parameters to URL
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			
			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			String dtstr = date.format(formatterOut);
			/*
			 * Must have the time on this
			 */
			effDate = dtstr + " 00:00:00";
		}
		else {
			effDate = "";
		}
		File testFile = new File(pdfFile);
		String sFileName = testFile.getName();
		String batchName = "ICC Ingestion - " + FilenameUtils.removeExtension(sFileName);
		String sortOrder = modelMain.getSortOrder();

		try {
			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
			uriBuilder = new URIBuilder(uri);
			uriBuilder.addParameter("source", "FileNet");
			uriBuilder.addParameter("returnId", "true");
			uriBuilder.addParameter("contentType", "application/pdf");
//pvr Change SmartSubmissionPackage to ContractsAgreements for OnBase
//			uriBuilder.addParameter("documentType", "ContractsAgreements");
//			uriBuilder.addParameter("fileName", sdocType);
//			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"groupAccount\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"DocumentType\":\"Contracts/Agreements/Signature Page\",\"EffectiveDate\":\"" + effDate + "\"}");
//			uriBuilder.addParameter("subSource", "FASCORE_OS");
//			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

//pvr - original setup for PROD_BPI_OS			
			uriBuilder.addParameter("smart_submission_packages", sdocType);
			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"smart_submission_packages\":\"" + sdocType + "\"}");
			uriBuilder.addParameter("documentType", "SmartSubmissionPackage");
			uriBuilder.addParameter("documentType", "SmartSubmission");
			uriBuilder.addParameter("documentType", "Implementation");
			uriBuilder.addParameter("subSource", "PROD_BPI_OS");

		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}
		System.out.println(uriBuilder.getQueryParams());
		HttpPost post = null;
		try {
			post = new HttpPost(uriBuilder.build());
		} catch (URISyntaxException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		}

		/*
		 * Write out the doc first
		 */
		File file = null;

		if (pdfFile != null) {
			file = new File(pdfFile);
			if (!file.exists()) {
				System.out.println("Error - Output file does not exist - " + pdfFile);
				status = false;
				setStatusStr("fail");
				setMessage("Error - Output file does not exist - " + pdfFile);
				return status;
			}
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}
		HttpEntity entity = MultipartEntityBuilder.create().addBinaryBody("file", image).build();
		post.setEntity(entity);

		/*
		 * Execute the post request
		 */
		try {
			System.out.println(post.getURI().toString());
			httpResponse = httpClient.execute(post);
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println(httpResponse);
		String httpStatus = null;
		httpStatus = Integer.toString(httpResponse.getStatusLine().getStatusCode());
		System.out.println("----------------------------------------");
		System.out.println(httpResponse.getStatusLine());
		Header[] hM = httpResponse.getAllHeaders();
		for (Header header : hM) {
			System.out.println(header.getName() + " " + header.getValue());
		}
		try {
			fis.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return status;

	}

	/*
	 * Test POST
	 */
	public void doPost() {

		/*
		 * Get authorization ID from Empower API
		 */
		System.out.println("Here");
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";

		// Define the file         
		String filePath = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		File file = new File(filePath);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";
		HashMap<String, Object> documentProperties = new HashMap<>();
		HashMap<String, String> documentMap = new HashMap<>();
		HashMap<String, String> planMap = new HashMap<>();

		planMap.put("number", "932777-01");
		planMap.put("name", "ecmdocumentsapi-name");
		planMap.put("source", "401K");
		documentProperties.put("plan", planMap);

		documentMap.put("batchName", "ecmdocumentapitest");
		documentMap.put("product", "ecmdocumentapitest");
		documentMap.put("title", "documentTitle");
		documentProperties.put("document", documentMap);

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		org.springframework.http.HttpEntity<MultiValueMap<String, Object>> requestEntity = new org.springframework.http.HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());
	}

	public void doGet() {

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";
		// Replace with the actual API endpoint         

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create a HttpEntity         
		org.springframework.http.HttpEntity<String> entity = new org.springframework.http.HttpEntity<>(headers);         

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();         

		// Make the HTTP GET request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody()); 
	}

	/*
	 * Send SmartSubmission POST request
	 * OnBase version
	 */
	public boolean sendPostSmartSubmissionOnBase(String pdfFile) {

		status = true;

		/*
		 * Get current doc
		 */
		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Do OnBase
		 */
		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";

		// Define the file         
		String filePath = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		/*
		 * Set parameter values
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			
			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			String dtstr = date.format(formatterOut);
			/*
			 * Must have the time on this
			 */
			effDate = dtstr + " 00:00:00";
		}
		else {
			effDate = "";
		}

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";
		HashMap<String, Object> documentProperties = new HashMap<>();
		HashMap<String, String> documentMap = new HashMap<>();
		HashMap<String, String> planMap = new HashMap<>();

		planMap.put("number", "932777-01");
		planMap.put("name", "ecmdocumentsapi-name");
		planMap.put("source", "401K");
		documentProperties.put("plan", planMap);

		documentMap.put("batchName", "ecmdocumentapitest");
		documentMap.put("product", "ecmdocumentapitest");
		documentMap.put("title", "documentTitle");
		documentProperties.put("document", documentMap);

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		org.springframework.http.HttpEntity<MultiValueMap<String, Object>> requestEntity = new org.springframework.http.HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;

	}

	/*
	 * Send ScanSheets POST request
	 */
	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		CloseableHttpClient httpClient = null;
		CloseableHttpResponse httpResponse = null;

		RequestConfig requestConfig = RequestConfig.custom()
				.setConnectionRequestTimeout(100000)
				.setConnectTimeout(100000)
				.setSocketTimeout(100000)
				.build();
		httpClient = HttpClients.custom()
				.setDefaultRequestConfig(requestConfig)
				.build();

		/*
		 * Build the POST request
		 */
		URI uri = null;
		URIBuilder uriBuilder = null;

		/*
		 * Add parameters to URL
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date;
			DateTimeFormatter formatterOut;
			String dtstr;
			try {
				date = LocalDate.parse(dateIn, formatterIn);
				formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
				dtstr = date.format(formatterOut);
				
				/*
				 * Must have the time on this
				 */
				effDate = dtstr + " 00:00:00";
			}
			catch (Exception e) {
				e.printStackTrace();
				effDate="";
			}
			
		}
		else {
			effDate = "";
		}
		File testFile = new File(pdfFile);
		String sFileName = testFile.getName();
//		String batchName = "ICCPPS" + sFileName;
		String batchName = "ICC Ingestion - " + FilenameUtils.removeExtension(sFileName);
		String sortOrder = modelMain.getSortOrder();
		
		try {
			
			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
			uriBuilder = new URIBuilder(uri);
			uriBuilder.addParameter("source", "FileNet");
			uriBuilder.addParameter("returnId", "true");
			uriBuilder.addParameter("contentType", "application/pdf");
//pvr Change SmartSubmissionPackage to Compliance for OnBase
//			uriBuilder.addParameter("documentType", "Plan");
			uriBuilder.addParameter("documentType", "Plan");
			uriBuilder.addParameter("fileName", sdocType);
//			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\"}");
			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"groupAccount\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"EffectiveDate\":\"" + effDate + "\"}");
			uriBuilder.addParameter("subSource", "PROD_BPI_OS");
//			uriBuilder.addParameter("subSource", "FASCORE_OS");
			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

//pvr			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
//			uriBuilder = new URIBuilder(uri);
//			uriBuilder.addParameter("source", "FileNet");
//			uriBuilder.addParameter("returnId", "true");
//			uriBuilder.addParameter("contentType", "application/pdf");
//			uriBuilder.addParameter("documentType", "SmartSubmissionPackage");
//			uriBuilder.addParameter("fileName", sdocType);
////			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\"}");
////			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"\" + sortOrder + \"\"}");
//			uriBuilder.addParameter("subSource", "PROD_BPI_OS");
//			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}
		System.out.println(uriBuilder.getQueryParams());
		HttpPost post = null;
		try {
			post = new HttpPost(uriBuilder.build());
		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}

		/*
		 * Write out the doc first
		 */
		File file = null;

		if (pdfFile != null) {
			file = new File(pdfFile);
			if (!file.exists()) {
				System.out.println("Error - Output file does not exist - " + pdfFile);
				status = false;
				setStatusStr("fail");
				setMessage("Error - Output file does not exist - " + pdfFile);
				return status;
			}
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}
		HttpEntity entity = MultipartEntityBuilder.create().addBinaryBody("file", image).build();
		post.setEntity(entity);

		/*
		 * Execute the post request
		 */
		try {
			System.out.println(post.getURI().toString());
			httpResponse = httpClient.execute(post);
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(httpResponse);
		String httpStatus = null;
		httpStatus = Integer.toString(httpResponse.getStatusLine().getStatusCode());
		System.out.println("----------------------------------------");
		System.out.println(httpResponse.getStatusLine());
		Header[] hM = httpResponse.getAllHeaders();
		for (Header header : hM) {
			System.out.println(header.getName() + " " + header.getValue());
		}
		try {
			fis.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return status;

	}

	/*
	 * Initialize various status and message values
	 */
	public void clear() {
		setStatusDateTime(null);
		setStatusStr(null);
		setMessage(null);
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	/*
	 * Main for testing class
	 */
	public static void main(String[] args) throws Exception {
	}

}





{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Resource": "*",
			"Effect": "Allow",
			"NotAction": [
				"iam:*",
				"organizations:*",
				"account:*",
				"cloudhsm:*",
				"cognito-idp:*",
				"cognito-identity:*",
				"cognito-sync:*",
				"fms:*",
				"guardduty:*",
				"inspector:*",
				"inspector2:*",
				"macie2:*",
				"network-firewall:*",
				"shield:*"
			],
			"Sid": "AllowPowerUserAccess"
		},
		{
			"Action": [
				"ec2:GetPasswordData",
				"iam:CreateServiceLinkedRole",
				"iam:DeleteServiceLinkedRole",
				"iam:ListRoles",
				"organizations:DescribeOrganization",
				"account:ListRegions"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowPowerUserAccessIam"
		},
		{
			"Action": [
				"iam:List*",
				"iam:Generate*",
				"iam:Get*",
				"iam:Simulate*"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowReadIAMActions"
		},
		{
			"Action": [
				"iam:PassRole"
			],
			"Resource": [
				"arn:aws:iam::563003501456:role/gwf/service/*",
				"arn:aws:iam::563003501456:role/gwf/apps/*"
			],
			"Effect": "Allow",
			"Sid": "PassRole"
		},
		{
			"Action": [
				"ec2:AcceptVpcEndpointConnections",
				"ec2:AcceptVpcPeeringConnection",
				"ec2:AssociateRouteTable",
				"ec2:AssociateSubnetCidrBlock",
				"ec2:AssociateVpcCidrBlock",
				"ec2:AttachClassicLinkVpc",
				"ec2:AttachInternetGateway",
				"ec2:AttachVpnGateway",
				"ec2:CreateDefaultSubnet",
				"ec2:CreateDefaultVpc",
				"ec2:CreateDhcpOptions",
				"ec2:CreateEgressOnlyInternetGateway",
				"ec2:CreateInternetGateway",
				"ec2:CreateNatGateway",
				"ec2:CreateNetworkAcl",
				"ec2:CreateNetworkAclEntry",
				"ec2:CreateRoute",
				"ec2:CreateRouteTable",
				"ec2:CreateSubnet",
				"ec2:CreateVpc",
				"ec2:CreateVpcEndpoint",
				"ec2:CreateVpcEndpointConnectionNotification",
				"ec2:CreateVpcEndpointServiceConfiguration",
				"ec2:CreateVpcPeeringConnection",
				"ec2:CreateVpnConnection",
				"ec2:CreateVpnConnectionRoute",
				"ec2:CreateVpnGateway",
				"wafv2:Create*",
				"wafv2:Update*",
				"wafv2:Delete*",
				"waf:Create*",
				"waf:Update*",
				"waf:Delete*",
				"fms:*",
				"ec2:DeleteEgressOnlyInternetGateway",
				"ec2:DeleteInternetGateway",
				"ec2:DeleteNatGateway",
				"ec2:DeleteNetworkAcl",
				"ec2:DeleteNetworkAclEntry",
				"ec2:DeleteRoute",
				"ec2:DeleteRouteTable",
				"ec2:DeleteSubnet",
				"ec2:DeleteVpc",
				"ec2:DeleteVpcEndpointConnectionNotifications",
				"ec2:DeleteVpcEndpoints",
				"ec2:DeleteVpcEndpointServiceConfigurations",
				"ec2:DeleteVpcPeeringConnection",
				"ec2:DeleteVpnConnection",
				"ec2:DeleteVpnConnectionRoute",
				"ec2:DeleteVpnGateway",
				"ec2:DisableVgwRoutePropagation",
				"ec2:DisassociateRouteTable",
				"ec2:EnableVgwRoutePropagation",
				"ec2:EnableVpcClassicLink",
				"ec2:EnableVpcClassicLinkDnsSupport",
				"ec2:ModifySubnetAttribute",
				"ec2:ModifyVpcAttribute",
				"ec2:ModifyVpcEndpoint",
				"ec2:ModifyVpcEndpointConnectionNotification",
				"ec2:ModifyVpcEndpointServiceConfiguration",
				"ec2:ModifyVpcEndpointServicePermissions",
				"ec2:ModifyVpcPeeringConnectionOptions",
				"ec2:ModifyVpcTenancy",
				"ec2:RejectVpcEndpointConnections",
				"ec2:RejectVpcPeeringConnection",
				"ec2:ReplaceRoute",
				"ec2:ReplaceRouteTableAssociation",
				"s3:PutAccountPublicAccessBlock",
				"s3:PutBucketPublicAccessBlock",
				"s3:DeleteBucketEncryption"
			],
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedAction"
		},
		{
			"Condition": {
				"StringEquals": {
					"ec2:ResourceTag/department": "securityengineering"
				},
				"ForAllValues:StringEquals": {
					"aws:TagKeys": "department"
				}
			},
			"Action": [
				"ec2:AuthorizeSecurityGroupEgress",
				"ec2:AuthorizeSecurityGroupIngress",
				"ec2:CreateSecurityGroup",
				"ec2:DeleteSecurityGroup"
			],
			"Resource": "arn:aws:ec2:*:*:security-group/*",
			"Effect": "Deny",
			"Sid": "DenySecOpsOwnedSecuritygroups"
		},
		{
			"Condition": {
				"StringNotEquals": {
					"aws:RequestedRegion": [
						"us-west-2",
						"us-east-1"
					]
				}
			},
			"Action": "*",
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedRegions"
		}
	]
}




{
  "errorMessage": "An error occurred (UnauthorizedOperation) when calling the StartInstances operation: You are not authorized to perform this operation. User: arn:aws:sts::563003501456:assumed-role/LambdaEC2ManagementRole/test-chenna-last is not authorized to perform: ec2:StartInstances on resource: arn:aws:ec2:us-east-1:563003501456:instance/i-0488b8da2a2809c51 because no identity-based policy allows the ec2:StartInstances action. Encoded authorization failure message: zCAWRNCFjL8YiALExJZzPmdNdFWer4GA75KjX-oZsm1ZREL-N3s9ITmpLEgtBrDKOUGtushvpTeD3TlSA32XCDyYC0Ng7CvhAPkqBgvwj7uYUqwDN-Uumdk9n2jcV4NEyKvQbXKU5QGfAAuSNDU8NUHm_FEOuWTFVCOXrmjZsCu7UKVuXG9HYe4HH9TQjUReokDBdho8Kk-MtDTTssB9UzVm_98f0PM2GayJSnuasAtCRuFy_JnDRJlKy5EQ2AZ1hQSXiVkQRj3dH7VuGR-uYS4qXBV1jQkL8SJGUiXXygx2_GTJPY1P0MRQeA4oIRLs4aoahSAO2bPSYQhCzQtMAz7pCH6aK_QaR11OJbde-JFaDoc9e44Y0Dyvk8WdXpDeoLQHZoe18n-Osi-RsT8zAf3PzaxsCaDqRitcyGbdkCSjscuc9K9X9BFEALGV31Tn4A8At0Mgk1piXkZTreLzsZcbWlXyuibvN0Pu55HgJyU9kx4onMIou9CIK5pBKeAdtVW2u-n62ZQw-MCldOxkkq5HysQ-iFtkZxXd77ehSdIFnOmYpRRyFvtluwzEzjAJWyKhaLkPws1CfJ9aswY3zNgunlJDRAV8mgbZfrOnnOKQNOX4aVMozbg8W7e_J0r_HVcaXJQ_8Bd93ElqkDvVrAnXCq3ZawcGMLDcEAuI_ELcG2LUDyeqq7S7jQWyfQEylcaivOAxQ168Obew0Un8ksVGnW5cIvVE1zj7XQ3cJf-FOoX_rdtoN7-i4TauIeovMxEXzs0Tns46qaqRUGrVysyI0aPv4Zi60UgWtviDTl90P8sfZTqeDmfD71yj-oEP_kHc3LSXAbRdywhv8GorVhO9fcskvFbkep_WERvkuegFRUS1h4OtCzC4v_ff9zK2rrOmHQ4NQAa1aDe3Y0cpStwnT-psgpczhG3eFLglm0MRzODbPlbIulsEJzTlKnA1Dq1yabIPmT8UYWtOJYMk7mk86Vn_2v4eht1Tdya758Hw3PzLxq0",
  "errorType": "ClientError",
  "requestId": "83c9032b-28e2-4d2f-95e7-7c927ea231b3",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 12, in lambda_handler\n    ec2.start_instances(InstanceIds = instances)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 565, in _api_call\n    return self._make_api_call(operation_name, kwargs)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 1021, in _make_api_call\n    raise error_class(parsed_response, operation_name)\n"
  ]
}




AWSTemplateFormatVersion: '2010-09-09'
Description: IAM Role for Lambda to Start/Restart EC2 Instances with Logging Access and Existing Chenna1Policy

Resources:
  # Lambda IAM Role with EC2 management and logging access
  LambdaEC2ManagementRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: LambdaEC2ManagementRole
      Path: /gwf/apps/lambda/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument: 
        Version: '2012-10-17'
        Statement: 
          - Effect: Allow
            Principal: 
              Service: 
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      
      # Attach the required managed policies
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        
        # Attach the already created Chenna1Policy
        - arn:aws:iam::${AWS::AccountId}:policy/gwf/apps/chenna1policy








---
AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'

AWSTemplateFormatVersion: '2010-09-09'
Description: Compliance Lambda IAM Role with an Empower permissions boundary
Resources:
  ComplianceLambdaS3Read:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaS3Read
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
  ComplianceLambdaEC2Full:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaEC2Full
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole



AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role for Lambda with a permissions boundary
Resources:
  
  LambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: LambdaExecutionRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole


---
AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role with a permissions boundary
Resources:
  
  BackupRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: BackupRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - backup.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - >-
          arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup



AWSTemplateFormatVersion: 2010-09-09
Description: Role to allow starting an EC2 instance

Resources:
  EC2StartRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: chenna1role
      Path: /gwf/apps/
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 'ec2.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess



AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'



AWSTemplateFormatVersion: "2010-09-09"
Description: Lambda Role with EC2 and CloudWatch Logs Permissions

Resources:
  Chennatest1LambdaRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: "chennatest1"
      Path: "/gwf/apps/chennatest/"
      PermissionsBoundary: "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      # Attach policies for Lambda to perform basic tasks and the custom permissions
      ManagedPolicyArns: 
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: "CustomEC2AndCloudWatchPermissions"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Permissions for CloudWatch Logs
              - Effect: "Allow"
                Action: 
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              # Permissions to start and stop EC2 instances
              - Effect: "Allow"
                Action: 
                  - "ec2:Start*"
                  - "ec2:Stop*"
                Resource: "*"





AWSTemplateFormatVersion: "2010-09-09"Description: Compliance Lambda IAM Role with an Empower permissions boundaryResources:ComplianceLambdaS3Read:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaS3Read'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonS3FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole'ComplianceLambdaEC2Full:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaEC2Full'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonEC2FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole

{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "IAM Role with a permissions boundary for MyApp",
  "Resources": {
    "MyAppRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "MyAppRole-EC2Access",
        "Path": "/gwf/apps/MyApp/",
        "PermissionsBoundary": "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "ec2.amazonaws.com"
                ]
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
      }
    }
  }
}





Updates:

The /gwf/operations/CDTOperator role has been updated in each account to enable permissions boundary

Assumptions / Requirements:
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Least Preferred Method: Create a Role with Permissions Boundary using CLI
Notes from Matt / SS-Prod example as of 10/24/2018
This page contains the draft directions for how to create IAM roles within a permission boundary.

Assumptions / Requirements:
You must assume an AWS role with permissions to create roles.
Roles may be created with CLI or CloudFormation.  
Currently, roles cannot be created using the console because Path is unsupported in the IAM console.
Roles must be created within the /gwf/apps/app_name/ path.  
Attempts to create roles that are in this path will result in an Access Denied message.
Policies must be created within the /gwf/apps/app_name/ path.  
Attempts to create policies that are not in this path will result in an Access Denied message.
Attempts to create roles with attached policies that are not in this path will result in an Access Denied message.
Attempts to create roles with AWS Managed Policies attached will result in an Access Denied message.
Create a Customer Managed version of the AWS Managed Policy, but replace any reference to Resource: "*" with an IAM Best Practice.
A permissions boundary must be attached to the role at the time of role creation.  There are two policies to choose from:
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services and need to create other roles.
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services.
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
A CloudFormation template.
Instructions:

Create a CloudFormation role template that includes the following properties:
AssumeRolePolicyDocument
Also known as a "trust policy."  See IAM Best Practices: IAM for examples of common trust policy patterns and code snippets.
ManagedPolicyArns
Managed Policies can be created in the same CloudFormation template and passed by reference.
Path
See AWS IAM and Path for details.
RoleName
Roles should follow a descriptive naming standard of <App_Name>-Description.  For example, if my application is called underwaterbasketweaver, I might create a role called UnderwaterBasketWeaver-LambdaWriteToS3Role.
Launch the CloudFormation stack from the template.
An example CloudFormation template in YAML format might look something like:

SampleRole
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
---
AWSTemplateFormatVersion: "2010-09-09"
Description: IAM Role with a permissions boundary
Resources:
  TestRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: 'PermissionBoundaryTestRole'
      Path: /gwf/apps/
      PermissionsBoundary: !Sub "arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - 'ec2.amazonaws.com'
          Action: 'sts:AssumeRole'


Least Preferred Method: Create a Role with Permissions Boundary using CLI
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
Shell access on is-xcloud05nb to obtain federated CLI credentials.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
The trust document for the role in json format.


Instructions:

Login to is-xcloud05nb using LDAP/Active Directory credentials

directions to create SAML token

federate in as /gwf/operations/CDTOperator role for the account that needs the role.

When creating the role, you will need a json file containing a trust policy which defines what service will be using the role.  There are some examples of trust policies in the IAM Best Practices guide. Here is an example for an EC2 role:

ec2trust.json
1
2
3
4
5
6
7
8
9
10
11
12
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
Create a role with a particular boundary:  



[dfgkwg@is-xcloud05nb iamRoleTesting]$ aws iam create-role \
--permissions-boundary arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM \
--role-name testRole3 --assume-role-policy-document file://ec2trust.json \
--path /gwf/apps/<App_name> --profile iamtest

aws iam create-role --permissions-boundary <FULL PERMISSION BOUNDARY ARN> --role-name <ROLE NAME> --assume-role-policy-document file://<PATH TO TRUST DOCUMENT>.json --path /gwf/apps/<APP NAME>/ --profile saml

You should a response similar to the following:

create role output
1
{ "Role": { "PermissionsBoundary": { "PermissionsBoundaryType": "Policy", "PermissionsBoundaryArn": "arn:aws:iam::499776071476:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM" }, "AssumeRolePolicyDocument": { "Version": "2012-10-17", "Statement": [ { "Action": "sts:AssumeRole", "Effect": "Allow", "Principal": { "Service": "ec2.amazonaws.com" } } ] }, "RoleId": "AROAJRPI3P7H4TDI7EHCI", "CreateDate": "2018-10-05T17:13:27Z", "RoleName": "testRole3", "Path": "/gwf/apps/underwaterbasketweaver", "Arn": "arn:aws:iam::499776071476:role/gwf/apps/underwaterbasketweaver/testRole3" }
Create a permissions policy with a path of /gwf/apps/<App_Name>/.

CLI to create IAM policy
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
[user@is-xcloud05nb iamRoleTesting]$ aws iam create-policy --policy-name testPolicyName2 --policy-document file://testPolicy.json --profile iamtest --path /gwf/apps/underwaterbasketweaver/
 {     "Policy":
      {
         "PolicyName": "testPolicyName2",
         "PermissionsBoundaryUsageCount": 0,
         "CreateDate": "2018-10-05T17:20:04Z",
         "AttachmentCount": 0,
         "IsAttachable": true,
         "PolicyId": "ANPAITVBCUQSQA3BHFDJM",
         "DefaultVersionId": "v1",
         "Path": "/gwf/service/",
         "Arn": "arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2",
         "UpdateDate": "2018-10-05T17:20:04Z"
     }
}
Attach the permissions policy to the role.  This step may be performed using the Console once the role and permissions policy in the app-specific path have been created.

CLI to attach IAM policy
1
2
aws iam attach-role-policy --role-name testRole3 --policy-arn arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2 \
--profile iamtest
Diagram


Boundary      
Delegated IAM Administrator
EC2 Instance Boundary
Lambda Boundary
Other Boundaries
Newly Created Roles
arn:aws:iam::role/gwf/service/<ROLE>
CreateBoundedIamPolicy
Required
Boundary
Policies
IAM Administrator
Role managed by Security
Policy managed by Security
Role managed by CDT
Policy managed by CDT
arn:aws:iam::policy/gwf/boundary/*
arn:aws:iam::policy/gwf/service/<POLICY>
Security creates boundaries
based on reasonable and frequent
access requirements in partnership with
the CDT / Application teams
CDT IAM Admins are able to
create new roles and policies,
if and only if they attach an
existing boundary to the role
         Policy
Boundary      
Effective
Permissions
         Policy





Boundary      
Effective
Permissions
Effective
Permissions


arn:aws:iam::role/gwf/operations/<ROLE>
arn:aws:iam::role/gwf/security/<ROLE>
Legend
Effective Permissions using Permissions Boundary
Delegating IAM Administration using Permissions Boundary
Logical Design
- Sid: AllowAttachPermBoundary
  Effect: Allow
  Action:
  - iam:DetachRolePolicy
  - iam:AttachRolePolicy
  - iam:DeleteRolePolicy
  - iam:PutRolePermissionsBoundary
  - iam:CreateRole
  - iam:PutRolePolicy
  Resource: arn:aws:iam:::role/gwf/service/*
  Condition:
    StringLike:
      iam:PermissionsBoundary: arn:aws:iam::*:policy/gwf/boundaries/*

- Sid: AllowOtherIAMActions
  Effect: Allow
  Action:
  - iam:AddRoleToInstanceProfile
  - iam:CreateInstanceProfile
  - iam:CreatePolicy
  - iam:CreatePolicyVersion
  - iam:DeleteInstanceProfile
  - iam:DeletePolicy
  - iam:DeleteRole
  - iam:UpdateRole
  - iam:UpdateRoleDescription
  - iam:RemoveRoleFromInstanceProfile
  Resource:
  - arn:aws:iam:::role/gwf/service/*
  - arn:aws:iam:::policy/gwf/service/*
  - arn:aws:iam:::instance-profile/gwf/service/*

Delegating IAM Administration using Permissions Boundary
Physical Design
arn:aws:iam::role/gwf/operations/DelegatedIAMAdmin
ExampleBlacklistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: blacklist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: BoundaryAllowance
        Effect: Allow
        Action: '*'
        Resource: '*'
      - Sid:DenyNotApprovedAction
        Effect:Deny
        Action:
        - iam:*
        - organizations:*
        Resource:'*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
      
ExampleWhitelistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: whitelist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: AllowActions
        Effect: Allow
        Action: 
        - 's3:GetObject'
        - 'ssm:*'
        - 'logs:*'
        Resource: '*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
        Resource: '*'
Matt Helgen
10/5/2018
Policy
Error Messages
message 1


message 2


message 3


(---------- if you need this -----------------)






Notes from Matt / SS-Prod example as of 10/24/2018
here’s the commands I ran in the sharedservices prod account to create the role, after federating into the CDTOperator role on is-xcloud05nb
 
aws iam create-role \
--permissions-boundary arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary \
--role-name mtthlg-test \
--assume-role-policy-document file://ec2trust.json \
--path /gwf/operations/services/ \
--profile saml

Returns:
{
    "Role": {
        "PermissionsBoundary": {
            "PermissionsBoundaryType": "Policy",
            "PermissionsBoundaryArn": "arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary"
        },
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "ec2.amazonaws.com"
                    }
                }
            ]
        },
        "RoleId": "AROAJSWTGLMITKAYZG35K",
        "CreateDate": "2018-10-24T16:49:37Z",
        "RoleName": "mtthlg-test",
        "Path": "/gwf/operations/services/",
        "Arn": "arn:aws:iam::676428981261:role/gwf/operations/services/mtthlg-test"
    }
}
 
For the boundaries, we’ve created 2 empty boundaries which can be used for testing in every account (the account number will differ by account)
 
arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary  
arn:aws:iam::676428981261:policy/gwf/boundaries/apps/AppsTestBoundary
 
For the ec2trust.json file, this depends on what the role will be used for, here is the example file content for if we are creating an ec2 role, the trust policy will depend on what service needs to use the role:
 
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
After this role is created, you should be able to manage it via the console, or create new policies in cloudformation and attach them to this role. Only the initial creation of the role itself needs to be done via CLI, until the “PermissionsBoundary” option is available as part of the AWS::IAM::Role cloudformation resource properties.







Resources:



Permission Boundary links recommended by Unknown User (rjskkn) on 4 February 2019:

https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html
https://aws.amazon.com/blogs/security/delegate-permission-management-to-developers-using-iam-permissions-boundaries/
https://www.youtube.com/watch?v=YQsK4MtsELU


https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actions-resources-contextkeys.html was a recommended reference to understand adding AWS services to IAM policies from Matt Helgen in October 2018






LikeBe the first to like this
No labelsEdit Labels
User icon: Add a picture of yourself




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaEC2LogsPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:us-east-1:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:Start*'
                  - 'ec2:Stop*'
                Resource: 'arn:aws:ec2:us-east-1:*:instance/*'

Outputs:
  LambdaRole:
    Value: !Ref LambdaExecutionRole
    Description: The IAM role ARN for Lambda execution




AWSTemplateFormatVersion: '2010-09-09'
Resources:

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaExecutionPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128





AWSTemplateFormatVersion: '2010-09-09'
Resources:
  
  # Create the IAM Policy
  LambdaExecutionPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: 'LambdaExecutionPolicy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: 'arn:aws:logs:*:*:*'
          - Effect: Allow
            Action:
              - 'ec2:StartInstances'
              - 'ec2:StopInstances'
            Resource: '*'
      Roles:
        - !Ref LambdaExecutionRole

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: LambdaExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Lambda Function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code: 
        S3Bucket: 'your-lambda-code-bucket'
        S3Key: 'your-lambda-code.zip'
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128

  # CloudWatch log group for Lambda
  LambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub '/aws/lambda/${MyLambdaFunction}'
      RetentionInDays: 14




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ec2:Start*",
        "ec2:Stop*"
      ],
      "Resource": "*"
    }
  ]
}




{'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': '45922bac-072d-484d-83ba-50770d2da1ee', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': '45922bac-072d-484d-83ba-50770d2da1ee', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Mon, 23 Sep 2024 13:54:50 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}
END RequestId: 82f2b6c6-2835-4335-b43b-33c52667dd08

INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e
REPORT RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e	Duration: 1256.09 ms	Billed Duration: 1257 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 570.13 ms	
START RequestId: 70e884fd-d13b-425f-8832-a35244b00733 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 70e884fd-d13b-425f-8832-a35244b00733
REPORT RequestId: 70e884fd-d13b-425f-8832-a35244b00733	Duration: 1117.61 ms	Billed Duration: 1118 ms	Memory Size: 128 MB	Max Memory Used: 87 MB

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            try:
                ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
                print(f"Starting instance {INSTANCE_ID}")
            except Exception as e:
                print(f"exception is {e}");
            
           
            
            # # Wait for the instance to be in running state
            # retry_count = 0
            # max_retries = 4
            # while retry_count < max_retries:
            #     response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
            #     current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
            #     print(f"Current state after start attempt: {current_state}")
                
            #     if current_state == 'running':
            #         print(f"Instance {INSTANCE_ID} is now running.")
            #         break
            #     elif current_state == 'stopped':
            #         print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
            #         retry_count += 1;
            #         time.sleep(4)  # Wait before checking again
            #     else:
            #         print("instance is in unexpected state")
            #         break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # # Send error message via SNS
        # sns_client.publish(
        #     TopicArn=SNS_TOPIC_ARN,
        #     Subject='Error starting EC2 instance',
        #     Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        # )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send escalation email via SNS
def send_escalation_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Escalation Alert: Instance {instance_name} ({instance_id})"
    body = f"Instance {instance_name} ({instance_id}) is still in a stopped state after 1 hour."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to check if the instance is still stopped
def is_instance_stopped(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_state = instance['State']['Name']
        return instance_state == 'stopped'
    return False

def lambda_handler(event, context):
    # Extract instance ID and name from the event
    instance_id = event['instance-id']
    instance_name = event['instance-name']

    # Check if the instance is still stopped
    if is_instance_stopped(instance_id):
        # Send escalation email
        send_escalation_email(instance_id, instance_name)

    return {
        "message": f"Escalation email sent for instance {instance_id}."
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send an initial email via SNS
def send_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) Alert"
    body = f"Instance {instance_name} ({instance_id}) is in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get instance name
def get_instance_name(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        return instance_name
    return None

def lambda_handler(event, context):
    # Extract instance ID from the event
    instance_id = event['detail']['instance-id']

    # Get instance name
    instance_name = get_instance_name(instance_id) or "Unnamed Instance"

    # Send the email
    send_email(instance_id, instance_name)

    return {
        "message": f"Initial email sent for instance {instance_id}.",
        "instance-id": instance_id,
        "instance-name": instance_name
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




https://app.diagrams.net/?src=about
INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: ccf2649f-086a-441a-8309-9960e57577f2 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: ccf2649f-086a-441a-8309-9960e57577f2
REPORT RequestId: ccf2649f-086a-441a-8309-9960e57577f2	Duration: 41737.89 ms	Billed Duration: 41738 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 567.85 ms	


import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            retry_count = 0
            max_retries = 4
            while retry_count < max_retries:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                    retry_count += 1;
                    time.sleep(10)  # Wait before checking again
                else:
                    print("instance is in unexpected state")
                    break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Test Event Name
inputdata

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86
REPORT RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 534.24 ms	Status: timeout

Request ID
7c5fad82-989a-42db-ac8a-96df2d23ff86

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            while True:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                time.sleep(10)  # Wait before checking again

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Starting instance i-0488b8da2a2809c51 {'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Sat, 21 Sep 2024 10:50:18 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}

import boto3
import os

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "states:StartExecution",
      "Resource": "arn:aws:states:REGION:ACCOUNT_ID:stateMachine:STATE_MACHINE_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "sns:Publish",
      "Resource": "arn:aws:sns:REGION:ACCOUNT_ID:TOPIC_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "ec2:DescribeInstances",
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:REGION:ACCOUNT_ID:*"
    }
  ]
}



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Send the initial email when the instance is first stopped
    send_email(instance_id, instance_name)

    # If the instance is still in a stopped state, send the escalation email after some time
    if instance_state == 'stopped':
        send_email(instance_id, instance_name, escalation=True)

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output


-----
{
  "statusCode": 200,
  "body": "{\"detail\": {\"instance-id\": \"i-0488b8da2a2809c51\"}}"
}
output:
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "bba3f772-b551-4e65-a291-ec06a01b78bc",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 37, in lambda_handler\n    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda\n"
  ]
}
code:

import boto3
import time
import os
import json

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available


def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }






-------
import json

def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }



{
  "errorMessage": "'NoneType' object is not subscriptable",
  "errorType": "TypeError",
  "requestId": "bd316927-5a89-481c-89e9-f940a8a129ef",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}



The principal states.amazonaws.com is not authorized to assume the provided role. (role: arn:aws:iam::563003501456:role/gwf/apps/compliance/ComplianceLambdaEC2Chenna1)

{
  "Comment": "State machine to handle EC2 instance stop alerts and escalation",
  "StartAt": "InitialCheck",
  "States": {
    "InitialCheck": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<InitialEmailFunction>",
      "Next": "Wait1Hour"
    },
    "Wait1Hour": {
      "Type": "Wait",
      "Seconds": 3600,
      "Next": "CheckInstanceState"
    },
    "CheckInstanceState": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<RecheckEmailFunction>",
      "End": true
    }
  }
}


Test Event Name
event1

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Version: $LATEST
END RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f
REPORT RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 455.70 ms	Status: timeout

Request ID
ec3fd342-3d6f-480f-963f-42bf39870b2f

{
  "version": "0",
  "id": "c8c7bf83-0ce5-4b94-953e-0d332c7611b5",
  "detail-type": "EC2 Instance State-change Notification",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2023-09-20T18:40:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0abcd1234efgh5678"
  ],
  "detail": {
    "instance-id": "i-0abcd1234efgh5678",
    "state": "stopped"
  }
}



hello i am chenna 
{
  "version": "0",
  "id": "12345678-1234-1234-1234-1234567890ab",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2024-09-18T10:00:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0488b8da2a2809c51"
  ],
  "detail-type": "EC2 Instance State-change Notification",
  "detail": {
    "instance-id": "i-0488b8da2a2809c51",
    "state": "stopped"
  }
}

{
  "instanceId": "$.detail.instance-id",
  "state": "$.detail.state",

  "time": "$.time"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}
{
  "source": ["aws.ec2"],
  "detail-type": ["EC2 Instance State-change Notification"],
  "detail": {
    "state": ["stopped"],
    "instance-id": ["i-0488b8da2a2809c51"]
  }
}
Test Event Name
chennaStopInstance

Response
{
  "errorMessage": "Handler 'Hello::handleRequest' missing on module 'example'",
  "errorType": "Runtime.HandlerNotFound",
  "requestId": "",
  "stackTrace": []
}

Function Logs
[ERROR] Runtime.HandlerNotFound: Handler 'Hello::handleRequest' missing on module 'example'
Traceback (most recent call last):INIT_REPORT Init Duration: 310.36 ms	Phase: invoke	Status: error	Error Type: Runtime.Unknown
START RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32 Version: $LATEST
END RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32
REPORT RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32	Duration: 341.22 ms	Billed Duration: 342 ms	Memory Size: 512 MB	Max Memory Used: 42 MB	Status: error	Error Type: Runtime.Unknown

Request ID
84cb5abc-c4c1-4409-b195-b34f955f5c32



import boto3
import time
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available

# Lambda handler function
def lambda_handler(event, context):
    # Get instance ID from event (triggered by EventBridge)
    instance_id = event['detail']['instance-id']
    
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    # Wait for 1 hour
    time.sleep(3600)  # 3600 seconds = 1 hour
    
    # Check the instance state again after 1 hour
    instance_state = check_instance_state(instance_id)
    
    # If the instance is still in 'stopped' state, send the escalation email
    if instance_state == 'stopped':
        send_email(instance_id, escalation=True)
    
    return {
        'statusCode': 200,
        'body': f'Email sent successfully for instance {instance_id}.'
    }

Test Event Name
event1

Response
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "943b4064-98ae-40b4-bb88-d5bf8b59bfba",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}

Function Logs
START RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba Version: $LATEST
LAMBDA_WARNING: Unhandled exception. The most likely cause is an issue in the function code. However, in rare cases, a Lambda runtime update can cause unexpected function behavior. For functions using managed runtimes, runtime updates can be triggered by a function change, or can be applied automatically. To determine if the runtime has been updated, check the runtime version in the INIT_START log entry. If this error correlates with a change in the runtime version, you may be able to mitigate this error by temporarily rolling back to the previous runtime version. For more information, see https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html
[ERROR] KeyError: 'detail'
Traceback (most recent call last):
  File "/var/task/lambda_function.py", line 36, in lambda_handler
    instance_id = event['detail']['instance-id']END RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba
REPORT RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba	Duration: 6.27 ms	Billed Duration: 7 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 432.06 ms

Request ID
943b4064-98ae-40b4-bb88-d5bf8b59bfba

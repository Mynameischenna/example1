unning with:
Input Working Dir: C:\ECM
Input Excel File: C:\ECM\ecmdoc.xlsx
Input All Dir: C:\ECM
Output Report File: C:\ECM\ecmdoc.xlsx
Output Dir: C:\ECM
hello
java.lang.NullPointerException: Cannot invoke "com.ecm1.ECM1.ui.FileSelectionData.areAllFieldsSet()" because "this.data" is null
	at com.ecm1.ECM1.controller.ECMcontroller.processFiles(ECMcontroller.java:41)
	at com.ecm1.ECM1.ui.FileSelectorGUI.runProcessing(FileSelectorGUI.java:97)
	at com.ecm1.ECM1.ui.FileSelectorGUI.lambda$setupGUI$5(FileSelectorGUI.java:41)
	at java.desktop/javax.swing.AbstractButton.fireActionPerformed(AbstractButton.java:1972)
	at java.desktop/javax.swing.AbstractButton$Handler.actionPerformed(AbstractButton.java:2314)
	at java.desktop/javax.swing.DefaultButtonModel.fireActionPerformed(DefaultButtonModel.java:407)
	at java.desktop/javax.swing.DefaultButtonModel.setPressed(DefaultButtonModel.java:262)
	at java.desktop/javax.swing.plaf.basic.BasicButtonListener.mouseReleased(BasicButtonListener.java:279)
	at java.desktop/java.awt.Component.processMouseEvent(Component.java:6621)
	at java.desktop/javax.swing.JComponent.processMouseEvent(JComponent.java:3398)
	at java.desktop/java.awt.Component.processEvent(Component.java:6386)
	at java.desktop/java.awt.Container.processEvent(Container.java:2266)
	at java.desktop/java.awt.Component.dispatchEventImpl(Component.java:4996)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2324)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4828)
	at java.desktop/java.awt.LightweightDispatcher.retargetMouseEvent(Container.java:4948)
	at java.desktop/java.awt.LightweightDispatcher.processMouseEvent(Container.java:4575)
	at java.desktop/java.awt.LightweightDispatcher.dispatchEvent(Container.java:4516)
	at java.desktop/java.awt.Container.dispatchEventImpl(Container.java:2310)
	at java.desktop/java.awt.Window.dispatchEventImpl(Window.java:2780)
	at java.desktop/java.awt.Component.dispatchEvent(Component.java:4828)
	at java.desktop/java.awt.EventQueue.dispatchEventImpl(EventQueue.java:775)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:720)
	at java.desktop/java.awt.EventQueue$4.run(EventQueue.java:714)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:98)
	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:747)
	at java.desktop/java.awt.EventQueue$5.run(EventQueue.java:745)
	at java.base/java.security.AccessController.doPrivileged(AccessController.java:400)
	at java.base/java.security.ProtectionDomain$JavaSecurityAccessImpl.doIntersectionPrivilege(ProtectionDomain.java:87)
	at java.desktop/java.awt.EventQueue.dispatchEvent(EventQueue.java:744)
	at java.desktop/java.awt.EventDispatchThread.pumpOneEventForFilters(EventDispatchThread.java:203)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForFilter(EventDispatchThread.java:124)
	at java.desktop/java.awt.EventDispatchThread.pumpEventsForHierarchy(EventDispatchThread.java:113)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:109)
	at java.desktop/java.awt.EventDispatchThread.pumpEvents(EventDispatchThread.java:101)
	at java.desktop/java.awt.EventDispatchThread.run(EventDispatchThread.java:90)



package com.ecm1.ECM1.ui;

public class FileSelectionData {
    private String inputWorkingDir;
    private String inputExcelFile;
    private String inputAllDir;
    private String outputReportFile;
    private String outputDir;

    public String getInputWorkingDir() { return inputWorkingDir; }
    public String getInputExcelFile() { return inputExcelFile; }
    public String getInputAllDir() { return inputAllDir; }
    public String getOutputReportFile() { return outputReportFile; }
    public String getOutputDir() { return outputDir; }

    public void setInputWorkingDir(String path) { this.inputWorkingDir = path; }
    public void setInputExcelFile(String path) { this.inputExcelFile = path; }
    public void setInputAllDir(String path) { this.inputAllDir = path; }
    public void setOutputReportFile(String path) { this.outputReportFile = path; }
    public void setOutputDir(String path) { this.outputDir = path; }

    public boolean areAllFieldsSet() {
        return inputWorkingDir != null && inputExcelFile != null &&
               inputAllDir != null && outputReportFile != null && outputDir != null;
    }
}



package com.ecm1.ECM1;

import com.ecm1.ECM1.ui.FileSelectorGUI;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Ecm1Application {
    public static void main(String[] args) {
        System.setProperty("java.awt.headless", "false"); // Enable GUI mode
        SpringApplication.run(Ecm1Application.class, args);

        SwingUtilities.invokeLater(FileSelectorGUI::new);
        System.out.println("ECM Application is running...");
    }
}



package com.ecm1.ECM1.ui;

import javax.swing.*;
import java.awt.*;
import java.io.File;

public class FileSelectorGUI {
    private final FileSelectionData fileData;

    public FileSelectorGUI() {
        fileData = new FileSelectionData();
        setupGUI();
    }

    private void setupGUI() {
        JFrame frame = new JFrame("File Selector");
        frame.setSize(500, 400);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new GridLayout(7, 1, 10, 10));

        JButton btnInputWorkingDir = new JButton("Select Input Working Directory");
        JButton btnInputExcelFile = new JButton("Select Input Excel File");
        JButton btnInputAllDir = new JButton("Select Input All Directory");
        JButton btnOutputReportFile = new JButton("Select Output Report File");
        JButton btnOutputDir = new JButton("Select Output Directory");
        JButton btnRun = new JButton("Run");
        JButton btnAbout = new JButton("About");

        btnInputWorkingDir.addActionListener(e -> fileData.setInputWorkingDir(selectDirectory("Select Input Working Directory")));
        btnInputExcelFile.addActionListener(e -> fileData.setInputExcelFile(selectFile("Select Input Excel File")));
        btnInputAllDir.addActionListener(e -> fileData.setInputAllDir(selectDirectory("Select Input All Directory")));
        btnOutputReportFile.addActionListener(e -> fileData.setOutputReportFile(selectFile("Select Output Report File")));
        btnOutputDir.addActionListener(e -> fileData.setOutputDir(selectDirectory("Select Output Directory")));

        btnRun.addActionListener(e -> runProcessing());
        btnAbout.addActionListener(e -> showAboutInfo());

        frame.add(btnInputWorkingDir);
        frame.add(btnInputExcelFile);
        frame.add(btnInputAllDir);
        frame.add(btnOutputReportFile);
        frame.add(btnOutputDir);
        frame.add(btnRun);
        frame.add(btnAbout);

        frame.setVisible(true);
    }

    private String selectFile(String title) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle(title);
        int returnValue = fileChooser.showOpenDialog(null);
        if (returnValue == JFileChooser.APPROVE_OPTION) {
            File selectedFile = fileChooser.getSelectedFile();
            if (selectedFile.exists() && selectedFile.isFile()) {
                return selectedFile.getAbsolutePath();
            }
            JOptionPane.showMessageDialog(null, "Invalid file selected!", "Error", JOptionPane.ERROR_MESSAGE);
        }
        return null;
    }

    private String selectDirectory(String title) {
        JFileChooser directoryChooser = new JFileChooser();
        directoryChooser.setDialogTitle(title);
        directoryChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int returnValue = directoryChooser.showOpenDialog(null);
        if (returnValue == JFileChooser.APPROVE_OPTION) {
            File selectedDir = directoryChooser.getSelectedFile();
            if (selectedDir.exists() && selectedDir.isDirectory()) {
                return selectedDir.getAbsolutePath();
            }
            JOptionPane.showMessageDialog(null, "Invalid directory selected!", "Error", JOptionPane.ERROR_MESSAGE);
        }
        return null;
    }

    private void runProcessing() {
        if (!fileData.areAllFieldsSet()) {
            JOptionPane.showMessageDialog(null, "Please select all required files and directories!", "Missing Data", JOptionPane.WARNING_MESSAGE);
            return;
        }
        System.out.println("Running with:");
        System.out.println("Input Working Dir: " + fileData.getInputWorkingDir());
        System.out.println("Input Excel File: " + fileData.getInputExcelFile());
        System.out.println("Input All Dir: " + fileData.getInputAllDir());
        System.out.println("Output Report File: " + fileData.getOutputReportFile());
        System.out.println("Output Dir: " + fileData.getOutputDir());

        // Call external processing method
        processFiles();
    }

    private void showAboutInfo() {
        JOptionPane.showMessageDialog(null, "ECM File Selector v1.0\nDeveloped by Chenna", "About", JOptionPane.INFORMATION_MESSAGE);
    }

    public FileSelectionData getFileSelectionData() {
        return fileData;
    }

    private void processFiles() {
        System.out.println("Processing files...");
        // Add actual processing logic here
    }
}





package com.ecm1.ECM1.ui;

import com.ecm1.ECM1.controller.ECMcontroller;
import org.springframework.stereotype.Component;

import javax.swing.*;
import java.awt.*;

@Component
public class FileSelectorGUI {

    private String inputWorkingDir;
    private String inputExcelFile;
    private String inputAllDir;
    private String outputReportFile;
    private String outputDir;

    private final ECMcontroller ecmController;

    public FileSelectorGUI(ECMcontroller ecmController) {
        this.ecmController = ecmController;

        JFrame frame = new JFrame("File Selector");
        frame.setSize(500, 300);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new GridLayout(7, 2, 10, 10));

        JButton btnInputWorkingDir = new JButton("Select Input Working Directory");
        JButton btnInputExcelFile = new JButton("Select Input Excel File");
        JButton btnInputAllDir = new JButton("Select Input All Directory");
        JButton btnOutputReportFile = new JButton("Select Output Report File");
        JButton btnOutputDir = new JButton("Select Output Directory");

        JButton btnRun = new JButton("Run");
        JButton btnEnd = new JButton("End");
        JButton btnAbout = new JButton("About");

        btnInputWorkingDir.addActionListener(e -> inputWorkingDir = selectDirectory());
        btnInputExcelFile.addActionListener(e -> inputExcelFile = selectFile());
        btnInputAllDir.addActionListener(e -> inputAllDir = selectDirectory());
        btnOutputReportFile.addActionListener(e -> outputReportFile = selectFile());
        btnOutputDir.addActionListener(e -> outputDir = selectDirectory());

        btnRun.addActionListener(e -> runProcessing());
        btnEnd.addActionListener(e -> System.exit(0));
        btnAbout.addActionListener(e -> showAboutInfo());

        frame.add(btnInputWorkingDir);
        frame.add(btnInputExcelFile);
        frame.add(btnInputAllDir);
        frame.add(btnOutputReportFile);
        frame.add(btnOutputDir);
        frame.add(btnRun);
        frame.add(btnEnd);
        frame.add(btnAbout);

        frame.setVisible(true);
    }

    private String selectFile() {
        JFileChooser fileChooser = new JFileChooser();
        int returnValue = fileChooser.showOpenDialog(null);
        return (returnValue == JFileChooser.APPROVE_OPTION) ? fileChooser.getSelectedFile().getAbsolutePath() : null;
    }

    private String selectDirectory() {
        JFileChooser directoryChooser = new JFileChooser();
        directoryChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int returnValue = directoryChooser.showOpenDialog(null);
        return (returnValue == JFileChooser.APPROVE_OPTION) ? directoryChooser.getSelectedFile().getAbsolutePath() : null;
    }

    private void runProcessing() {
        if (inputExcelFile != null && outputReportFile != null) {
            String result = ecmController.processFiles(inputExcelFile, outputReportFile);
            JOptionPane.showMessageDialog(null, "Processing complete: " + result);
        } else {
            JOptionPane.showMessageDialog(null, "Please select all required files before running.");
        }
    }

    private void showAboutInfo() {
        JOptionPane.showMessageDialog(null, "ECM File Selector GUI\nVersion 1.0\nDeveloped by Chenna.");
    }

    public String getInputWorkingDir() { return inputWorkingDir; }
    public String getInputExcelFile() { return inputExcelFile; }
    public String getInputAllDir() { return inputAllDir; }
    public String getOutputReportFile() { return outputReportFile; }
    public String getOutputDir() { return outputDir; }
}





package com.ecm1.ECM1.ui;

import com.ecm1.ECM1.controller.ECMcontroller;
import org.springframework.stereotype.Component;

import javax.swing.*;
import java.awt.*;
import java.io.File;

@Component
public class FileSelectorGUI {

    private File inputWorkingDir;
    private File inputExcelFile;
    private File inputAllDir;
    private File outputReportFile;
    private File outputDir;

    private final ECMcontroller ecmController;

    public FileSelectorGUI(ECMcontroller ecmController) {
        this.ecmController = ecmController;

        JFrame frame = new JFrame("File Selector");
        frame.setSize(500, 300);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setLayout(new GridLayout(7, 2, 10, 10));

        JButton btnInputWorkingDir = new JButton("Select Input Working Directory");
        JButton btnInputExcelFile = new JButton("Select Input Excel File");
        JButton btnInputAllDir = new JButton("Select Input All Directory");
        JButton btnOutputReportFile = new JButton("Select Output Report File");
        JButton btnOutputDir = new JButton("Select Output Directory");

        JButton btnRun = new JButton("Run");
        JButton btnEnd = new JButton("End");
        JButton btnAbout = new JButton("About");

        btnInputWorkingDir.addActionListener(e -> inputWorkingDir = selectDirectory());
        btnInputExcelFile.addActionListener(e -> inputExcelFile = selectFile());
        btnInputAllDir.addActionListener(e -> inputAllDir = selectDirectory());
        btnOutputReportFile.addActionListener(e -> outputReportFile = selectFile());
        btnOutputDir.addActionListener(e -> outputDir = selectDirectory());

        btnRun.addActionListener(e -> runProcessing());
        btnEnd.addActionListener(e -> System.exit(0));
        btnAbout.addActionListener(e -> showAboutInfo());

        frame.add(btnInputWorkingDir);
        frame.add(btnInputExcelFile);
        frame.add(btnInputAllDir);
        frame.add(btnOutputReportFile);
        frame.add(btnOutputDir);
        frame.add(btnRun);
        frame.add(btnEnd);
        frame.add(btnAbout);

        frame.setVisible(true);
    }

    private File selectFile() {
        JFileChooser fileChooser = new JFileChooser();
        int returnValue = fileChooser.showOpenDialog(null);
        return (returnValue == JFileChooser.APPROVE_OPTION) ? fileChooser.getSelectedFile() : null;
    }

    private File selectDirectory() {
        JFileChooser directoryChooser = new JFileChooser();
        directoryChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
        int returnValue = directoryChooser.showOpenDialog(null);
        return (returnValue == JFileChooser.APPROVE_OPTION) ? directoryChooser.getSelectedFile() : null;
    }

    private void runProcessing() {
        if (inputExcelFile != null && outputReportFile != null) {
            String inputExcelPath = inputExcelFile.getAbsolutePath();
            String outputReportPath = outputReportFile.getAbsolutePath();

            String result = ecmController.processFiles(inputExcelPath, outputReportPath);
            JOptionPane.showMessageDialog(null, "Processing complete: " + result);
        } else {
            JOptionPane.showMessageDialog(null, "Please select all required files before running.");
        }
    }

    private void showAboutInfo() {
        JOptionPane.showMessageDialog(null, "ECM File Selector GUI\nVersion 1.0\nDeveloped by Chenna.");
    }

    public File getInputWorkingDir() { return inputWorkingDir; }
    public File getInputExcelFile() { return inputExcelFile; }
    public File getInputAllDir() { return inputAllDir; }
    public File getOutputReportFile() { return outputReportFile; }
    public File getOutputDir() { return outputDir; }
}

package com.ecm1.ECM1;

import com.ecm1.ECM1.ui.FileSelectorGUI;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import javax.swing.*;

@SpringBootApplication
public class Ecm1Application {

    @Autowired
    private FileSelectorGUI fileSelectorGUI;

    public static void main(String[] args) {
        System.setProperty("java.awt.headless", "false"); // Enable GUI mode
        SpringApplication.run(Ecm1Application.class, args);
        System.out.println("ECM Application is running...");
    }

    @javax.annotation.PostConstruct
    public void run() {
        SwingUtilities.invokeLater(() -> fileSelectorGUI);
    }
}





package com.ecm1.ECM1;

import com.ecm1.ECM1.controller.ECMcontroller;
import com.ecm1.ECM1.ui.FileSelectorGUI;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import javax.swing.*;
import java.awt.*;
import java.io.File;

@SpringBootApplication
public class Ecm1Application {

    @Autowired
    private ECMcontroller ecmController;

    public static void main(String[] args) {
        System.setProperty("java.awt.headless", "false"); // Ensure GUI mode
        SpringApplication.run(Ecm1Application.class, args);


        System.out.println("Running...");
    }
    @PostConstruct
    public void run() {

        SwingUtilities.invokeLater(() -> {
            new FileSelectorGUI(); // Start GUI safely
        });
        String filePath = "C:\\ECM\\PVR\\REPORT_2362_01DEC2023.xlsx";
        String result = ecmController.processFiles();
        System.out.println(result);
    }


}





public static void main(String[] args) {
    System.setProperty("java.awt.headless", "false"); // Ensure GUI mode
    SpringApplication.run(EcmApplication.class, args);
    
    SwingUtilities.invokeLater(() -> {
        new FileSelectorGUI(); // Start GUI safely
    });

    System.out.println("Running...");
}




package com.ecm1.ECM1;

import com.ecm1.ECM1.controller.ECMcontroller;
import com.ecm1.ECM1.ui.FileSelectorGUI;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.awt.*;

@SpringBootApplication
public class Ecm1Application {

    @Autowired
    private ECMcontroller ecmController;

    public static void main(String[] args) {
        SpringApplication.run(Ecm1Application.class, args);
        System.out.println("ECM Application is running!");

        // Ensure GUI is only launched if the environment supports it
        if (!GraphicsEnvironment.isHeadless()) {
            new FileSelectorGUI();
        } else {
            System.out.println("Headless mode detected. GUI will not start.");
        }
    }

    @PostConstruct
    public void run() {
        String filePath = "C:\\ECM\\PVR\\REPORT_2362_01DEC2023.xlsx";
        String result = ecmController.processFiles(filePath);
        System.out.println(result);
    }
}







package com.ecm1.ECM1;

import com.ecm1.ECM1.controller.ECMcontroller;
import com.ecm1.ECM1.ui.FileSelectorGUI;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class Ecm1Application {

    @Autowired
    private ECMcontroller ecmController;


    public static void main(String[] args) {
        SpringApplication.run(Ecm1Application.class, args);

        System.out.println("ECM Application is running!");
    }

    @PostConstruct
    public void run() {
        String filePath = "C:\\ECM\\PVR\\REPORT_2362_01DEC2023.xlsx";
        FileSelectorGUI gui new FileSelectorGUI();
        String result = ecmController.processFiles(filePath);
        System.out.println(result);
    }

}




Started Ecm1Application in 7.782 seconds (process running for 9.185)
Exception in thread "main" java.awt.HeadlessException
	at java.desktop/java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:166)
	at java.desktop/java.awt.Window.<init>(Window.java:553)
	at java.desktop/java.awt.Frame.<init>(Frame.java:428)
	at java.desktop/javax.swing.JFrame.<init>(JFrame.java:224)
	at com.ecm1.ECM1.ui.FileSelectorGUI.<init>(FileSelectorGUI.java:14)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:20)




package com.ecm;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;

public class FileSelectorGUI {
    private JFrame frame;
    private JTextField inputWorkingDirField, inputExcelFileField, inputAllDirField, outputReportFileField, outputDirField;
    private JButton runButton, endButton, aboutButton;

    public FileSelectorGUI() {
        frame = new JFrame("File & Directory Selector");
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setSize(600, 400);
        frame.setLayout(new GridLayout(7, 1));

        // Creating file selection fields
        inputWorkingDirField = addFileSelector("Input Working Directory:", true);
        inputExcelFileField = addFileSelector("Input Excel File:", false);
        inputAllDirField = addFileSelector("Input All Directory:", true);
        outputReportFileField = addFileSelector("Output Report File:", false);
        outputDirField = addFileSelector("Output Directory:", true);

        // Buttons
        JPanel buttonPanel = new JPanel();
        runButton = new JButton("Run");
        endButton = new JButton("End");
        aboutButton = new JButton("About");

        buttonPanel.add(runButton);
        buttonPanel.add(endButton);
        buttonPanel.add(aboutButton);
        frame.add(buttonPanel);

        // Button Actions
        runButton.addActionListener(e -> System.out.println("running"));
        endButton.addActionListener(e -> System.exit(0));
        aboutButton.addActionListener(e -> JOptionPane.showMessageDialog(frame, "This tool processes files and generates reports."));

        frame.setVisible(true);
    }

    private JTextField addFileSelector(String label, boolean isDirectory) {
        JPanel panel = new JPanel();
        panel.setLayout(new FlowLayout());

        JLabel jLabel = new JLabel(label);
        JTextField textField = new JTextField(30);
        JButton browseButton = new JButton("Browse");

        browseButton.addActionListener(e -> {
            JFileChooser fileChooser = new JFileChooser();
            fileChooser.setFileSelectionMode(isDirectory ? JFileChooser.DIRECTORIES_ONLY : JFileChooser.FILES_ONLY);
            int option = fileChooser.showOpenDialog(frame);
            if (option == JFileChooser.APPROVE_OPTION) {
                textField.setText(fileChooser.getSelectedFile().getAbsolutePath());
            }
        });

        panel.add(jLabel);
        panel.add(textField);
        panel.add(browseButton);
        frame.add(panel);

        return textField;
    }



    // Getter methods to retrieve selected paths anytime
    public String getInputWorkingDirectory() {
        return inputWorkingDirField.getText();
    }

    public String getInputExcelFile() {
        return inputExcelFileField.getText();
    }

    public String getInputAllDirectory() {
        return inputAllDirField.getText();
    }

    public String getOutputReportFile() {
        return outputReportFileField.getText();
    }

    public String getOutputDirectory() {
        return outputDirField.getText();
    }
}




Invoke-WebRequest -Uri "sandbox:/mnt/data/Cloudwatch_Email_Alerts.docx" -OutFile "C:\Users\YourUser\Downloads\Cloudwatch_Email_Alerts.docx"



Workflow
	1. Get email address from Excel ss report
	2. Send email through SMTP
	3. After 30 minutes, query Splunk
		a. Use from address in query
		b. DSN code returned, 2 is success, 4 is soft bounce, 5 is hard bounce
		c. If a 4, wait for system to resend
	4. For hard bounces, send a message to admin to clean up offending email address
	5. Save hard bounce emails in a DBMS to not resend
	
Chris Scott - another team that is looking at using Proofpoint for bounceback.
New concept from ProofPoint, a process that does a response code DSN Deliver System Notification
Submit mail to SMTP, hop to PostFix, then to ProofPoint, then to customer
Message tracking detail is in ProofPoint, stored in Splunk. The DSN JSON response is on an event. Stored in a JSON format.
Unique From address - not just reply-to for example. 123456789reply-to
DSN 2 success
DSN 4 soft bounce
DSN 5 hard bounce

Logging to Splunk is not immediate, takes a while to propagate
Use from email address to search Splunk
Takes time to propagate - give it 30 minutes to propagate
REST API - Splunk - Jim Foster
Pre-staged query to Splunk, use from address, sub-domain of empower
SpecialProducts.empower.com for example as domain

Tami and Jen reach out to other group
Bounce mgmt is key to "email reputation" for a company
Each app would have its own boundary with sub-domains
Hrlc-5144





Invoke-WebRequest -Uri https://s3.amazonaws.com/amazoncloudwatch-agent/windows/amd64/latest/AmazonCloudWatchAgent.msi -OutFile C:\AmazonCloudWatchAgent.msi



Install-WindowsFeature : ArgumentNotValid: The role, role service, or feature name is not valid: 'CloudWatchAgent'.
The name was not found.
At line:1 char:1
+ Install-WindowsFeature -Name "CloudWatchAgent"
+ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    + CategoryInfo          : InvalidArgument: (CloudWatchAgent:String) [Install-WindowsFeature], Exception
    + FullyQualifiedErrorId : NameDoesNotExist,Microsoft.Windows.ServerManager.Command



Step 1: Install & Start CloudWatch Agent on EC2.
✅ Step 2: Configure CloudWatch to collect Event Viewer logs.
✅ Step 3: Set up SNS for email/SMS alerts.
✅ Step 4: Create a CloudWatch Alarm to trigger alerts.


sudo yum install -y amazon-cloudwatch-agent  # For Amazon Linux/RHEL
sudo apt-get install -y amazon-cloudwatch-agent  # For Ubuntu/Debian




Monitor a specific machine
	• Do this in HRLC DEV account
	• For AWS EC2 appcompl04d
	• Open up Event Viewer - search Event Viewer in search box
		○ Focus on Windows Logs > Applications
		○ Focus on errors and warnings
	• Discover errors and send SNS or SES
Use either AWS or Windows services/APIs


123

n
123

$smtpServer = "smtp.yourserver.com"
$smtpFrom = "your-email@domain.com"
$smtpTo = "recipient-email@domain.com"
$messageSubject = "Application Error Alert"
$messageBody = "An application error occurred. Please check the Event Viewer for more details."

$smtp = New-Object Net.Mail.SmtpClient($smtpServer)
$smtp.Send($smtpFrom, $smtpTo, $messageSubject, $messageBody)





<dependency>
    <groupId>xerces</groupId>
    <artifactId>xercesImpl</artifactId>
    <version>2.12.2</version> <!-- Use the latest compatible version -->
</dependency>


"C:\Program Files\Java\jdk-21\bin\java.exe" -XX:TieredStopAtLevel=1 -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true "-Dmanagement.endpoints.jmx.exposure.include=*" "-javaagent:C:\Program Files\JetBrains\IntelliJ IDEA 2024.1.1\lib\idea_rt.jar=55702:C:\Program Files\JetBrains\IntelliJ IDEA 2024.1.1\bin" -Dfile.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8 -classpath C:\Compliance\ECM1\target\classes;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-data-jpa\3.3.4\spring-boot-starter-data-jpa-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-aop\3.3.4\spring-boot-starter-aop-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-aop\6.1.13\spring-aop-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\aspectj\aspectjweaver\1.9.22.1\aspectjweaver-1.9.22.1.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-jdbc\3.3.4\spring-boot-starter-jdbc-3.3.4.jar;C:\Users\chnksv\.m2\repository\com\zaxxer\HikariCP\5.1.0\HikariCP-5.1.0.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-jdbc\6.1.13\spring-jdbc-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\hibernate\orm\hibernate-core\6.5.3.Final\hibernate-core-6.5.3.Final.jar;C:\Users\chnksv\.m2\repository\jakarta\persistence\jakarta.persistence-api\3.1.0\jakarta.persistence-api-3.1.0.jar;C:\Users\chnksv\.m2\repository\jakarta\transaction\jakarta.transaction-api\2.0.1\jakarta.transaction-api-2.0.1.jar;C:\Users\chnksv\.m2\repository\org\jboss\logging\jboss-logging\3.5.3.Final\jboss-logging-3.5.3.Final.jar;C:\Users\chnksv\.m2\repository\org\hibernate\common\hibernate-commons-annotations\6.0.6.Final\hibernate-commons-annotations-6.0.6.Final.jar;C:\Users\chnksv\.m2\repository\io\smallrye\jandex\3.1.2\jandex-3.1.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\classmate\1.7.0\classmate-1.7.0.jar;C:\Users\chnksv\.m2\repository\net\bytebuddy\byte-buddy\1.14.19\byte-buddy-1.14.19.jar;C:\Users\chnksv\.m2\repository\org\glassfish\jaxb\jaxb-runtime\4.0.5\jaxb-runtime-4.0.5.jar;C:\Users\chnksv\.m2\repository\org\glassfish\jaxb\jaxb-core\4.0.5\jaxb-core-4.0.5.jar;C:\Users\chnksv\.m2\repository\org\eclipse\angus\angus-activation\2.0.2\angus-activation-2.0.2.jar;C:\Users\chnksv\.m2\repository\org\glassfish\jaxb\txw2\4.0.5\txw2-4.0.5.jar;C:\Users\chnksv\.m2\repository\com\sun\istack\istack-commons-runtime\4.1.2\istack-commons-runtime-4.1.2.jar;C:\Users\chnksv\.m2\repository\jakarta\inject\jakarta.inject-api\2.0.1\jakarta.inject-api-2.0.1.jar;C:\Users\chnksv\.m2\repository\org\antlr\antlr4-runtime\4.13.0\antlr4-runtime-4.13.0.jar;C:\Users\chnksv\.m2\repository\org\springframework\data\spring-data-jpa\3.3.4\spring-data-jpa-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\data\spring-data-commons\3.3.4\spring-data-commons-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-orm\6.1.13\spring-orm-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-context\6.1.13\spring-context-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-tx\6.1.13\spring-tx-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-beans\6.1.13\spring-beans-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-aspects\6.1.13\spring-aspects-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-web\3.3.4\spring-boot-starter-web-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-json\3.3.4\spring-boot-starter-json-3.3.4.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.17.2\jackson-databind-2.17.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.17.2\jackson-annotations-2.17.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.17.2\jackson-core-2.17.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.17.2\jackson-datatype-jdk8-2.17.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.17.2\jackson-datatype-jsr310-2.17.2.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.17.2\jackson-module-parameter-names-2.17.2.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\3.3.4\spring-boot-starter-tomcat-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\10.1.30\tomcat-embed-core-10.1.30.jar;C:\Users\chnksv\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\10.1.30\tomcat-embed-el-10.1.30.jar;C:\Users\chnksv\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\10.1.30\tomcat-embed-websocket-10.1.30.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-web\6.1.13\spring-web-6.1.13.jar;C:\Users\chnksv\.m2\repository\io\micrometer\micrometer-observation\1.13.4\micrometer-observation-1.13.4.jar;C:\Users\chnksv\.m2\repository\io\micrometer\micrometer-commons\1.13.4\micrometer-commons-1.13.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-webmvc\6.1.13\spring-webmvc-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-expression\6.1.13\spring-expression-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\poi\poi-ooxml\5.0.0\poi-ooxml-5.0.0.jar;C:\Users\chnksv\.m2\repository\org\apache\poi\poi-ooxml-lite\5.0.0\poi-ooxml-lite-5.0.0.jar;C:\Users\chnksv\.m2\repository\org\apache\commons\commons-compress\1.20\commons-compress-1.20.jar;C:\Users\chnksv\.m2\repository\com\github\virtuald\curvesapi\1.06\curvesapi-1.06.jar;C:\Users\chnksv\.m2\repository\org\bouncycastle\bcpkix-jdk15on\1.68\bcpkix-jdk15on-1.68.jar;C:\Users\chnksv\.m2\repository\org\bouncycastle\bcprov-jdk15on\1.68\bcprov-jdk15on-1.68.jar;C:\Users\chnksv\.m2\repository\org\apache\santuario\xmlsec\2.2.1\xmlsec-2.2.1.jar;C:\Users\chnksv\.m2\repository\com\fasterxml\woodstox\woodstox-core\5.2.1\woodstox-core-5.2.1.jar;C:\Users\chnksv\.m2\repository\org\codehaus\woodstox\stax2-api\4.2\stax2-api-4.2.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-all\1.13\batik-all-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-anim\1.13\batik-anim-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-shared-resources\1.13\batik-shared-resources-1.13.jar;C:\Users\chnksv\.m2\repository\xml-apis\xml-apis-ext\1.3.04\xml-apis-ext-1.3.04.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-awt-util\1.13\batik-awt-util-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\xmlgraphics-commons\2.4\xmlgraphics-commons-2.4.jar;C:\Users\chnksv\.m2\repository\commons-io\commons-io\1.3.1\commons-io-1.3.1.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-bridge\1.13\batik-bridge-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-codec\1.13\batik-codec-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-constants\1.13\batik-constants-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-css\1.13\batik-css-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-dom\1.13\batik-dom-1.13.jar;C:\Users\chnksv\.m2\repository\xalan\xalan\2.7.2\xalan-2.7.2.jar;C:\Users\chnksv\.m2\repository\xalan\serializer\2.7.2\serializer-2.7.2.jar;C:\Users\chnksv\.m2\repository\xml-apis\xml-apis\1.4.01\xml-apis-1.4.01.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-ext\1.13\batik-ext-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-extension\1.13\batik-extension-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-gui-util\1.13\batik-gui-util-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-gvt\1.13\batik-gvt-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-i18n\1.13\batik-i18n-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-parser\1.13\batik-parser-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-rasterizer-ext\1.13\batik-rasterizer-ext-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-rasterizer\1.13\batik-rasterizer-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-script\1.13\batik-script-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-slideshow\1.13\batik-slideshow-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-squiggle-ext\1.13\batik-squiggle-ext-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-squiggle\1.13\batik-squiggle-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-svg-dom\1.13\batik-svg-dom-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-svgbrowser\1.13\batik-svgbrowser-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-svggen\1.13\batik-svggen-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-svgpp\1.13\batik-svgpp-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-svgrasterizer\1.13\batik-svgrasterizer-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-swing\1.13\batik-swing-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-transcoder\1.13\batik-transcoder-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-util\1.13\batik-util-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-ttf2svg\1.13\batik-ttf2svg-1.13.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlgraphics\batik-xml\1.13\batik-xml-1.13.jar;C:\Users\chnksv\.m2\repository\de\rototor\pdfbox\graphics2d\0.30\graphics2d-0.30.jar;C:\Users\chnksv\.m2\repository\org\apache\pdfbox\pdfbox\2.0.22\pdfbox-2.0.22.jar;C:\Users\chnksv\.m2\repository\org\apache\pdfbox\fontbox\2.0.22\fontbox-2.0.22.jar;C:\Users\chnksv\.m2\repository\com\mysql\mysql-connector-j\8.3.0\mysql-connector-j-8.3.0.jar;C:\Users\chnksv\.m2\repository\jakarta\xml\bind\jakarta.xml.bind-api\4.0.2\jakarta.xml.bind-api-4.0.2.jar;C:\Users\chnksv\.m2\repository\jakarta\activation\jakarta.activation-api\2.1.3\jakarta.activation-api-2.1.3.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-core\6.1.13\spring-core-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\springframework\spring-jcl\6.1.13\spring-jcl-6.1.13.jar;C:\Users\chnksv\.m2\repository\org\jetbrains\annotations\26.0.2\annotations-26.0.2.jar;C:\Users\chnksv\.m2\repository\org\apache\poi\poi\5.0.0\poi-5.0.0.jar;C:\Users\chnksv\.m2\repository\org\slf4j\slf4j-api\2.0.16\slf4j-api-2.0.16.jar;C:\Users\chnksv\.m2\repository\org\slf4j\jcl-over-slf4j\2.0.16\jcl-over-slf4j-2.0.16.jar;C:\Users\chnksv\.m2\repository\commons-codec\commons-codec\1.16.1\commons-codec-1.16.1.jar;C:\Users\chnksv\.m2\repository\org\apache\commons\commons-collections4\4.4\commons-collections4-4.4.jar;C:\Users\chnksv\.m2\repository\org\apache\commons\commons-math3\3.6.1\commons-math3-3.6.1.jar;C:\Users\chnksv\.m2\repository\com\zaxxer\SparseBitSet\1.2\SparseBitSet-1.2.jar;C:\Users\chnksv\.m2\repository\org\apache\xmlbeans\xmlbeans\5.0.0\xmlbeans-5.0.0.jar;C:\Users\chnksv\.m2\repository\org\apache\logging\log4j\log4j-api\2.23.1\log4j-api-2.23.1.jar;C:\Users\chnksv\.m2\repository\org\apache\commons\commons-lang3\3.12.0\commons-lang3-3.12.0.jar;C:\Users\chnksv\.m2\repository\org\apache\commons\commons-exec\1.3\commons-exec-1.3.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter\3.3.4\spring-boot-starter-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot\3.3.4\spring-boot-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\3.3.4\spring-boot-autoconfigure-3.3.4.jar;C:\Users\chnksv\.m2\repository\org\springframework\boot\spring-boot-starter-logging\3.3.4\spring-boot-starter-logging-3.3.4.jar;C:\Users\chnksv\.m2\repository\ch\qos\logback\logback-classic\1.5.8\logback-classic-1.5.8.jar;C:\Users\chnksv\.m2\repository\ch\qos\logback\logback-core\1.5.8\logback-core-1.5.8.jar;C:\Users\chnksv\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.23.1\log4j-to-slf4j-2.23.1.jar;C:\Users\chnksv\.m2\repository\org\slf4j\jul-to-slf4j\2.0.16\jul-to-slf4j-2.0.16.jar;C:\Users\chnksv\.m2\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;C:\Users\chnksv\.m2\repository\org\yaml\snakeyaml\2.2\snakeyaml-2.2.jar com.ecm1.ECM1.Ecm1Application

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.3.4)

2025-01-29T05:15:03.930-07:00  INFO 9532 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Starting Ecm1Application using Java 21.0.2 with PID 9532 (C:\Compliance\ECM1\target\classes started by chnksv in C:\Compliance\ECM1)
2025-01-29T05:15:03.935-07:00  INFO 9532 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : No active profile set, falling back to 1 default profile: "default"
2025-01-29T05:15:05.790-07:00  INFO 9532 --- [ECM1] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFAULT mode.
2025-01-29T05:15:05.834-07:00  INFO 9532 --- [ECM1] [           main] .s.d.r.c.RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 30 ms. Found 0 JPA repository interfaces.
2025-01-29T05:15:06.920-07:00  INFO 9532 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8082 (http)
2025-01-29T05:15:06.954-07:00  INFO 9532 --- [ECM1] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2025-01-29T05:15:06.955-07:00  INFO 9532 --- [ECM1] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.30]
2025-01-29T05:15:07.112-07:00  INFO 9532 --- [ECM1] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2025-01-29T05:15:07.114-07:00  INFO 9532 --- [ECM1] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3075 ms
2025-01-29T05:15:07.464-07:00  INFO 9532 --- [ECM1] [           main] o.hibernate.jpa.internal.util.LogHelper  : HHH000204: Processing PersistenceUnitInfo [name: default]
2025-01-29T05:15:08.705-07:00  INFO 9532 --- [ECM1] [           main] org.hibernate.Version                    : HHH000412: Hibernate ORM core version 6.5.3.Final
2025-01-29T05:15:08.842-07:00  INFO 9532 --- [ECM1] [           main] o.h.c.internal.RegionFactoryInitiator    : HHH000026: Second-level cache disabled
2025-01-29T05:15:09.563-07:00  INFO 9532 --- [ECM1] [           main] o.s.o.j.p.SpringPersistenceUnitInfo      : No LoadTimeWeaver setup: ignoring JPA class transformer
2025-01-29T05:15:09.706-07:00  INFO 9532 --- [ECM1] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-01-29T05:15:10.725-07:00  INFO 9532 --- [ECM1] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection com.mysql.cj.jdbc.ConnectionImpl@6fced25c
2025-01-29T05:15:10.729-07:00  INFO 9532 --- [ECM1] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-01-29T05:15:11.643-07:00  INFO 9532 --- [ECM1] [           main] o.h.e.t.j.p.i.JtaPlatformInitiator       : HHH000489: No JTA platform available (set 'hibernate.transaction.jta.platform' to enable JTA platform integration)
2025-01-29T05:15:11.652-07:00  INFO 9532 --- [ECM1] [           main] j.LocalContainerEntityManagerFactoryBean : Initialized JPA EntityManagerFactory for persistence unit 'default'
2025-01-29T05:15:12.531-07:00  WARN 9532 --- [ECM1] [           main] o.apache.xmlbeans.impl.common.SAXHelper  : SAX Security Manager could not be setup [log suppressed for 5 minutes]

java.lang.ClassNotFoundException: org.apache.xerces.util.SecurityManager
	at java.base/jdk.internal.loader.BuiltinClassLoader.loadClass(BuiltinClassLoader.java:641) ~[na:na]
	at java.base/jdk.internal.loader.ClassLoaders$AppClassLoader.loadClass(ClassLoaders.java:188) ~[na:na]
	at java.base/java.lang.ClassLoader.loadClass(ClassLoader.java:526) ~[na:na]
	at java.base/java.lang.Class.forName0(Native Method) ~[na:na]
	at java.base/java.lang.Class.forName(Class.java:421) ~[na:na]
	at java.base/java.lang.Class.forName(Class.java:412) ~[na:na]
	at org.apache.xmlbeans.impl.common.SAXHelper.trySetXercesSecurityManager(SAXHelper.java:98) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.common.SAXHelper.newXMLReader(SAXHelper.java:50) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.store.Locale.getSaxLoader(Locale.java:2229) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.store.Locale.lambda$parseToXmlObject$3(Locale.java:715) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.store.Locale.syncWrap(Locale.java:488) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.store.Locale.parseToXmlObject(Locale.java:714) ~[xmlbeans-5.0.0.jar:na]
	at org.apache.xmlbeans.impl.schema.SchemaTypeLoaderBase.parse(SchemaTypeLoaderBase.java:233) ~[xmlbeans-5.0.0.jar:na]
	at org.openxmlformats.schemas.drawingml.x2006.main.ThemeDocument$Factory.parse(ThemeDocument.java:78) ~[poi-ooxml-lite-5.0.0.jar:na]
	at org.apache.poi.xssf.model.ThemesTable.<init>(ThemesTable.java:86) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at org.apache.poi.ooxml.POIXMLFactory.createDocumentPart(POIXMLFactory.java:61) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at org.apache.poi.ooxml.POIXMLDocumentPart.read(POIXMLDocumentPart.java:660) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at org.apache.poi.ooxml.POIXMLDocument.load(POIXMLDocument.java:165) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at org.apache.poi.xssf.usermodel.XSSFWorkbook.<init>(XSSFWorkbook.java:278) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at org.apache.poi.xssf.usermodel.XSSFWorkbook.<init>(XSSFWorkbook.java:299) ~[poi-ooxml-5.0.0.jar:5.0.0]
	at com.ecm1.ECM1.service.Service1.parseExcelFile(Service1.java:86) ~[classes/:na]
	at com.ecm1.ECM1.service.Service1.processFilesAndCreateJson(Service1.java:31) ~[classes/:na]
	at com.ecm1.ECM1.controller.ECMcontroller.processFiles(ECMcontroller.java:36) ~[classes/:na]
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:24) ~[classes/:na]
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103) ~[na:na]
	at java.base/java.lang.reflect.Method.invoke(Method.java:580) ~[na:na]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971) ~[spring-context-6.1.13.jar:6.1.13]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625) ~[spring-context-6.1.13.jar:6.1.13]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352) ~[spring-boot-3.3.4.jar:3.3.4]
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:17) ~[classes/:na]

File processed and data saved successfully!
2025-01-29T05:15:16.132-07:00  WARN 9532 --- [ECM1] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-01-29T05:15:17.062-07:00  INFO 9532 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8082 (http) with context path '/'
2025-01-29T05:15:17.079-07:00  INFO 9532 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Started Ecm1Application in 13.987 seconds (process running for 16.472)
ECM Application is running!






Could not transfer artifact com.aspose:aspose-words:pom:23.3.0 from/to AsposeRepository (https://repository.aspose.com/repo/): Connection reset



<dependencies>

    <!-- Spring Boot Starter -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>

    <!-- Aspose Words -->
    <dependency>
        <groupId>com.aspose</groupId>
        <artifactId>aspose-words</artifactId>
        <version>23.3.0</version>
    </dependency>

    <!-- Aspose PDF -->
    <dependency>
        <groupId>com.aspose</groupId>
        <artifactId>aspose-pdf</artifactId>
        <version>23.3.0</version>
    </dependency>

    <!-- Swing UI Support -->
    <dependency>
        <groupId>org.swinglabs</groupId>
        <artifactId>swingx</artifactId>
        <version>1.6.4</version>
    </dependency>

    <!-- Spring Boot DevTools (Optional - For Fast Restart) -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-devtools</artifactId>
        <scope>runtime</scope>
        <optional>true</optional>
    </dependency>

</dependencies>
<repositories>
    <repository>
        <id>AsposeRepository</id>
        <url>https://repository.aspose.com/repo/</url>
    </repository>
</repositories>




package com.ecm1.ECM1;

import com.ecm1.ECM1.controller.ECMcontroller;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;


@SpringBootApplication
public class Ecm1Application {

    @Autowired
    private ECMcontroller ecmController;

    public static void main(String[] args) {
        SpringApplication.run(Ecm1Application.class, args);
        System.out.println("ECM Application is running!");
    }

//    @PostConstruct
//    public void run() {
//        String filePath = "C:\\ECM\\PVR\\REPORT_2362_01DEC2023.xlsx";
//        String result = ecmController.processFiles(filePath);
//        System.out.println(result);
//    }
    private static void loadLicense() throws Exception
    {
        com.aspose.words.License license = new com.aspose.words.License();
        com.aspose.pdf.License pdfLicense = new com.aspose.pdf.License();
        license.setLicense(Thread.currentThread().getContextClassLoader().getResourceAsStream(CONST_ASPOSE_LICENSE));
        pdfLicense.setLicense(Thread.currentThread().getContextClassLoader().getResourceAsStream(CONST_ASPOSE_LICENSE));
    }
    @Override
    public void run(String... args) throws Exception
    {
        loadLicense();
        UIManager.setLookAndFeel(UIManager.getCrossPlatformLookAndFeelClassName());
        System.out.println("License Loaded");
        SwingUtilities.invokeLater(() -> {

            frameMain.validate();
            frameMain.setVisible(true);
        });
    }

}




package com.hrlc.mmpruecm.ui.entity;

import java.awt.AWTEvent;
import java.awt.BorderLayout;

import javax.swing.JFrame;
import javax.swing.JPanel;

import org.springframework.stereotype.Component;

import com.hrlc.mmpruecm.entity.ModelMain;
import com.hrlc.mmpruecm.ui.service.PanelMain;
@Component
public class FrameMain extends JFrame {

	private static final long serialVersionUID = 1L;
	
	private JPanel contentPane;
  
	private ModelMain modelMain;
	private PanelMain panelMain;
	
	
	public FrameMain(ModelMain modelMain,PanelMain panelMain) {
		this.modelMain = modelMain;
		this.panelMain= panelMain;
		panelMain.setModelMain(modelMain);
		this.enableEvents(AWTEvent.WINDOW_EVENT_MASK);
		initGui();
	}

	private void initGui() {
		panelMain.setFrame(this);
		panelMain.setModel(this.modelMain);
		this.setSize(600,800);
		this.setLocationRelativeTo(null);
		this.setDefaultCloseOperation(EXIT_ON_CLOSE);
//		this.setIconImage(Toolkit.getDefaultToolkit().createImage(FrameMain.class.getResource("EMPR_stack_med_4c.png")));
		contentPane = (JPanel)this.getContentPane();
		BorderLayout borderLayout = new BorderLayout();
		contentPane.setLayout(borderLayout);
		this.setLocationRelativeTo(null);
		modelMain.addObserver(panelMain);
		contentPane.add(panelMain);
//		this.setContentPane(panelMain);
		this.pack();
		this.setVisible(true);
		
	}
}
package com.hrlc.mmpruecm.ui.service;

import java.awt.Color;
import java.awt.Dimension;
import java.awt.GridBagConstraints;
import java.awt.GridBagLayout;
import java.awt.Insets;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;

import javax.annotation.PostConstruct;
import javax.swing.BorderFactory;
import javax.swing.ButtonGroup;
import javax.swing.JButton;
import javax.swing.JCheckBox;
import javax.swing.JComboBox;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.JScrollPane;
import javax.swing.JSeparator;
import javax.swing.JTextArea;
import javax.swing.JTextField;
import javax.swing.JTextPane;
import javax.swing.ScrollPaneConstants;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Component;

import com.hrlc.mmpruecm.entity.ModelMain;
import com.hrlc.mmpruecm.ui.entity.FrameMain;
import com.hrlc.mmpruecm.service.impl.OnBaseStore;

@Component
@PropertySource("classpath:application.properties")
public class PanelMain extends JPanel implements ActionListener, PropertyChangeListener {

	OnBaseStore onBaseStore = null;
	private JButton buttonWork;
	private JTextField textFieldWork;
	private JButton buttonInExcel;
	private JTextField textFieldInExcel;
	private JButton buttonInAll;
	private JTextField textFieldInAll;
	private JButton buttonOutReport;
	private JTextField textFieldOutReport;
	private JButton buttonOutDir;
	private JTextField textFieldOutDir;
	private JButton buttonAbout;
	private JButton buttonRun;
	private JButton buttonEnd;
	private JTextArea textAreaStatus;
	private JTextField textFieldStatus;
	private JCheckBox outputDirectorytoBeErased;

	// private JLabel outPutFolderLebel;
	// private JTextField outPutFolderInput;

	private JLabel textQualifierLabel;
	private final String[] TEXTQUALIFIER = { "\"", "'", "None" };
	private JComboBox textQualifierCombo;

	JLabel fieldLineLabel;
	JRadioButton delimitedBox;
	JRadioButton userDefinedBox;
	JButton defineButton;

	private JLabel delimiterTypeLabel;
	JRadioButton spaceBox;
	JRadioButton commaBox;

	private JLabel numberOfHeaderRecordsLabel;
	JTextField numberOfHeaderRecordsField;

	private JLabel numberOfDataRecordsLabel;
	JTextField numberOfDataRecordsField;

	private JSeparator delimiterSeparator;

	/**
	 * Field line definition
	 */
	JLabel fieldDefinitionLabel;
	JRadioButton addBox;
	JRadioButton moveBox;
	JRadioButton deleteBox;
	JRadioButton focusBox;
	JButton deleteAllButton;

	JLabel selectLabel;
	JRadioButton startBox;
	JRadioButton endBox;
	private String aboutMessage;
	private FrameMain frameMain;

	// Create a file chooser
	final JFileChooser fc = new JFileChooser();
	private ModelMain modelMain;

	@Value("${movefiles.application-name}")
	private String appName;
	@Value("${movefiles.description}")
	private String appdesc;
	@Value("${movefiles.version}")
	private String appVersion;
	@Value("${movefiles.version-date}")
	private String appVersionDate;

	@Value("${movefiles.baseDir}")
	private String baseDir;

	public PanelMain() {

		initGui();

	}

	@Override
	public Dimension getPreferredSize() {
		return new Dimension(600, 800);
	}

	@PostConstruct
	private void init() {
		onBaseStore = new OnBaseStore();
		fc.setCurrentDirectory(new File(baseDir));
		aboutMessage = "Name : " + appName + "\n" + "Description : " + appdesc + "\n" + "Version : " + appVersion + "\n"
				+ "Date : " + appVersionDate;

		System.out.println(aboutMessage);

	}

	public void setFrame(FrameMain frameMain) {
		this.frameMain = frameMain;
	}

	public void setModel(ModelMain modelMain) {
		this.modelMain = modelMain;
		/*
		 * Set initial type condition
		 */
		onBaseStore.setModel(this.modelMain);
	}

	private void initGui() {

		GridBagLayout gridBagMain = new GridBagLayout();
		setLayout(gridBagMain);
		setBorder(BorderFactory.createEtchedBorder());
		GridBagConstraints c;

		/*
		 * Panel objects
		 */
		ArrayList xmfConstraints = new ArrayList();
		int conCount = 0;

		/*
		 * Define GUI objects
		 */
		buttonWork = new JButton("Input Working Directory");
		buttonWork.addActionListener(this);
		textFieldWork = new JTextField(20);
		textFieldWork.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonWork.top=form.top+8"));
		xmfConstraints.add(conCount++, new String("buttonWork.left=form.left+6"));
		xmfConstraints.add(conCount++, new String("textFieldWork.top=buttonWork.top"));
		xmfConstraints.add(conCount++, new String("textFieldWork.left=buttonWork.right+24"));
		xmfConstraints.add(conCount++, new String("textFieldWork.right=textFieldWork.left+250"));

		buttonInExcel = new JButton("Input Excel Spreadsheet");
		buttonInExcel.addActionListener(this);
		textFieldInExcel = new JTextField(20);
		textFieldInExcel.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonInExcel.top=buttonWork.bottom+14"));
		xmfConstraints.add(conCount++, new String("buttonInExcel.left=buttonWork.left"));
		xmfConstraints.add(conCount++, new String("textFieldInExcel.top=buttonInExcel.top"));
		xmfConstraints.add(conCount++, new String("textFieldInExcel.left=buttonInExcel.right+24"));
		xmfConstraints.add(conCount++, new String("textFieldInExcel.right=textFieldInExcel.left+250"));

		buttonInAll = new JButton("Input All Directory");
		buttonInAll.addActionListener(this);
		textFieldInAll = new JTextField(20);
		textFieldInAll.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonInAll.top=buttonInExcel.bottom+14"));
		xmfConstraints.add(conCount++, new String("buttonInAll.left=buttonInExcel.left"));
		xmfConstraints.add(conCount++, new String("textFieldInAll.top=buttonInAll.top"));
		xmfConstraints.add(conCount++, new String("textFieldInAll.left=buttonInAll.right+24"));
		xmfConstraints.add(conCount++, new String("textFieldInAll.right=textFieldInAll.left+250"));

		buttonOutReport = new JButton("Output Report File");
		buttonOutReport.addActionListener(this);
		textFieldOutReport = new JTextField(20);
		textFieldOutReport.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonOutReport.top=buttonInAll.bottom+14"));
		xmfConstraints.add(conCount++, new String("buttonOutReport.left=buttonInAll.left"));
		xmfConstraints.add(conCount++, new String("textFieldOutReport.top=buttonOutReport.top"));
		xmfConstraints.add(conCount++, new String("textFieldOutReport.left=buttonOutReport.right+24"));
		xmfConstraints.add(conCount++, new String("textFieldOutReport.right=textFieldOutReport.left+250"));

		buttonOutDir = new JButton("Output Directory");
		buttonOutDir.addActionListener(this);
		textFieldOutDir = new JTextField(20);
		textFieldOutDir.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonOutDir.top=buttonOutReport.bottom+14"));
		xmfConstraints.add(conCount++, new String("buttonOutDir.left=buttonOutReport.left"));
		xmfConstraints.add(conCount++, new String("textFieldOutDir.top=buttonOutDir.top"));
		xmfConstraints.add(conCount++, new String("textFieldOutDir.left=buttonOutDir.right+24"));
		xmfConstraints.add(conCount++, new String("textFieldOutDir.right=textFieldOutDir.left+250"));

		outputDirectorytoBeErased = new JCheckBox("Delete Previous Output Files", false);
		outputDirectorytoBeErased.addActionListener(this);
		xmfConstraints.add(conCount++, new String("outputDirectorytoBeErased.top=buttonOutDir.bottom+14"));
		xmfConstraints.add(conCount++, new String("outputDirectorytoBeErased.left=buttonOutDir.left"));

		buttonRun = new JButton("Run");
		buttonRun.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonRun.top=outputDirectorytoBeErased.bottom+14"));
		xmfConstraints.add(conCount++, new String("buttonRun.left=outputDirectorytoBeErased.left"));

		buttonEnd = new JButton("End");
		buttonEnd.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonEnd.top=buttonRun.top"));
		xmfConstraints.add(conCount++, new String("buttonEnd.left=buttonRun.right+24"));

		buttonAbout = new JButton("About");
		buttonAbout.addActionListener(this);
		xmfConstraints.add(conCount++, new String("buttonAbout.top=buttonEnd.top"));
		xmfConstraints.add(conCount++, new String("buttonAbout.left=buttonEnd.right+24"));

		textAreaStatus = new JTextArea(10, 50);
		textAreaStatus.setEditable(false);
		textAreaStatus.setBackground(Color.white);
		JScrollPane scrollPane = new JScrollPane(textAreaStatus);
		scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);
//		scrollPane.setPreferredSize(new Dimension(600,600));
		textAreaStatus.setEditable(false);
		xmfConstraints.add(conCount++, new String("scrollPane.top=buttonRun.bottom+14"));
		xmfConstraints.add(conCount++, new String("scrollPane.left=buttonRun.left"));
		xmfConstraints.add(conCount++, new String("scrollPane.bottom=scrollPane.top+200"));

		/*
		 * Create layout and add objects
		 */
		XmFormLayout xfl = new XmFormLayout(xmfConstraints);
		this.setLayout(xfl);
		this.add("buttonWork", buttonWork);
		this.add("textFieldWork", textFieldWork);
		this.add("buttonInExcel", buttonInExcel);
		this.add("textFieldInExcel", textFieldInExcel);
		this.add("buttonInAll", buttonInAll);
		this.add("textFieldInAll", textFieldInAll);
		this.add("buttonOutReport", buttonOutReport);
		this.add("textFieldOutReport", textFieldOutReport);
		this.add("buttonOutDir", buttonOutDir);
		this.add("textFieldOutDir", textFieldOutDir);
		this.add("outputDirectorytoBeErased", outputDirectorytoBeErased);
		this.add("buttonRun", buttonRun);
		this.add("buttonEnd", buttonEnd);
		this.add("buttonAbout", buttonAbout);
		this.add("scrollPane", scrollPane);
		c = new GridBagConstraints();
		c.anchor = GridBagConstraints.WEST;
		c.insets = new Insets(0, 6, 0, 6);
		c.gridx = 0;
		c.gridy = 0;
		c.gridwidth = GridBagConstraints.REMAINDER;
		c.fill = GridBagConstraints.HORIZONTAL;
		gridBagMain.setConstraints(this, c);
		c.gridwidth = 1;
		c.fill = GridBagConstraints.NONE;
	}

	@Override
	public void actionPerformed(ActionEvent e) {
		if (e.getSource() == buttonWork) {
			getWork();
		}
		else if (e.getSource() == buttonInExcel) {
			getInExcel();
		}
		else if (e.getSource() == buttonInAll) {
			getInAll();
		} 
		else if (e.getSource() == buttonOutReport) {
			getOutReport();
		} 
		else if (e.getSource() == buttonOutDir) {
			getOutDir();
		} 
		else if (e.getSource() == outputDirectorytoBeErased) {
			setDeleteCheckBoxVal();
		} 
		else if (e.getSource() == buttonRun) {
			getRun();
		} 
		else if (e.getSource() == buttonEnd) {
			getEnd();
		} 
		else if (e.getSource() == buttonAbout) {
			getAbout();
		}
	}

	private void setDeleteCheckBoxVal() {
		modelMain.setFilesToBeDeleted(outputDirectorytoBeErased.isSelected());
	}

	private void getWork() {
		fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		int returnVal = fc.showOpenDialog(frameMain);
		String inFileWork = null;
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			inFileWork = file.getPath();
			modelMain.setWork(inFileWork);
			textFieldWork.setText(inFileWork);
			textAreaStatus.append(inFileWork + "\n");
		} else {
			System.out.println("Open command cancelled by user");
		}
		File f = new File(inFileWork);
		if(f.exists() && f.isDirectory()) { 
			fc.setCurrentDirectory(new File(inFileWork));
		}
	}

	private void getInExcel() {
		fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
		int returnVal = fc.showOpenDialog(frameMain);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			String inFileExcel = file.getPath();
			modelMain.setInExcel(inFileExcel);
			textFieldInExcel.setText(inFileExcel);
			textAreaStatus.append(inFileExcel + "\n");
		} else {
			System.out.println("Open command cancelled by user");
		}
	}

	private void getInAll() {
		fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		int returnVal = fc.showOpenDialog(frameMain);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			String inFileAll = file.getPath();
			modelMain.setInAll(inFileAll);
			textFieldInAll.setText(inFileAll);
			textAreaStatus.append(inFileAll + "\n");
		} else {
			System.out.println("Open command cancelled by user");
		}
	}

	private void getOutReport() {
		fc.setFileSelectionMode(JFileChooser.FILES_ONLY);
		int returnVal = fc.showOpenDialog(frameMain);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			String outFileReport = file.getPath();
			modelMain.setOutFileReport(outFileReport);
			textFieldOutReport.setText(outFileReport);
			textAreaStatus.append(outFileReport + "\n");
		} else {
			System.out.println("Open command cancelled by user");
		}
	}

	private void getOutDir() {
		fc.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		int returnVal = fc.showOpenDialog(frameMain);

		if (returnVal == JFileChooser.APPROVE_OPTION) {
			File file = fc.getSelectedFile();
			String outDir = file.getPath();
			modelMain.setOutDir(outDir);
			textFieldOutDir.setText(outDir);
			textAreaStatus.append(outDir + "\n");
		} else {
			System.out.println("Open command cancelled by user");
		}
	}
	
	private void getRun() {
		onBaseStore.loadEcm();
		textAreaStatus.append("Run done" + "\n");
		System.out.println("Run done");
	}

	private void getEnd() {
		textAreaStatus.append("End" + "\n");
		System.exit(0);
	}

	private void getAbout() {
		JOptionPane.showMessageDialog(frameMain, aboutMessage);
	}

	@Override
	public void propertyChange(PropertyChangeEvent evt) {
		System.out.println("Variation of " + evt.getPropertyName());
		System.out.println("\t(" + evt.getOldValue() + " -> " + evt.getNewValue() + ")");
		System.out.println("Property in object " + evt.getSource());
		// textAreaStatus.append(evt.getNewValue() + "\n");
		String status = (String) evt.getNewValue();
		this.textFieldStatus.setText("Test2");
		this.repaint();
		this.textFieldStatus.setText(status);
		String testStr = this.textFieldStatus.getText();
		this.repaint();
	}

	public void setModelMain(ModelMain modelMain2) {
		this.modelMain = modelMain;
	}

}
package com.hrlc.mmpruecm.ui.service;

/*
 *  XmFormLayout.java $Revision: 1.2 $ (a Java layout manager
 *  for AWT 1.1 which was inspired by the Motif XmForm widget)
 *  Copyright (C) 1997 Softbear Inc.  (info@softbear.com)
 *  Latest version at http://www.softbear.com/java/xmformlm
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.Insets;
import java.awt.LayoutManager;
import java.awt.Point;
import java.util.BitSet;
import java.util.Hashtable;
import java.util.Vector;
import java.util.ArrayList;

/**
 * The XmFormLayout lays out components according to
 * a list of constraints.
 *
 * Example 1: Fixed coordinates (form-relative).
 * =============================================
 * The following constraints will cause the component named "foo"
 * to be positioned at the point (x=10, y=10).
 *
 *  String constraints[] = {
 *   "foo.top=form.top+10",
 *   "foo.left=form.left+10"
 *  };
 *
 * Example 2: Relative coordinates
 * ===============================
 * The following constraints will cause the component named
 * "bar" to be positioned to the right of "foo" and made wide
 * enough to reach the right side of the form.
 *
 *  String constraints[] = {
 *   "foo.top=form.top+10",
 *   "foo.left=form.left+10",
 *   "bar.top=foo.top",
 *   "bar.left=foo.right+10",
 *   "bar.right=form.right-10"
 *  };
 *
 * Note: in order to understand the runtime operation (or errors)
 * in the code below, you may need to uncomment-out debug statements.
 */

public class XmFormLayout implements LayoutManager {

  /*
   * Component tuple constants, these must range from 0...9.
   * Attribute numbers must range from BOTTOM...TOP.
   */
  private final static int COMPONENT = 0;
  private final static int BOTTOM = 1;
  private final static int LEFT = 2;
  private final static int HCENTER = 3;
  private final static int VCENTER = 4;
  private final static int RIGHT = 5;
  private final static int TOP = 6;
  private final static int BITSET = 7;
  private final static int DIMENSION = 8;
  private final static int NAME = 9;


  /*
   * Other constants.
   */
  private final static int FORM = -32765;
  private final static int INVALID = -32766;
  private final static int UNBOUND = -32767;
  private final static boolean m_debug = false;
  private final static boolean m_bigDebug = false;

  /*
   * The constraints and the results of the
   * last reshape() computations.
   */
  private String   m_myName;
  private Dimension m_formDimensions; // (as of last reconstrain)
  private Point  m_formLocation; // (as of last reconstrain)
  private Vector m_tuples; // (4 attrs, component, bitset)
  private Hashtable m_nameToIndex;
  private String m_constraints[];
  private boolean m_changedFlag;

  /**
   * The constructor.
   */
  public XmFormLayout(ArrayList newConstraints) {
    m_myName = (((Object) this).getClass()).getName();
    m_constraints = new String[newConstraints.size()];
    for (int i=0;i<newConstraints.size();i++) {
      m_constraints[i] = (String)newConstraints.get(i);
    }
    m_formDimensions = new Dimension(0,0);
    m_formLocation = new Point(0,0);
    m_nameToIndex = new Hashtable();
    m_tuples = new Vector();
    m_changedFlag = true;
  }

  /**
   * Add a component.
   */
  public void addLayoutComponent(String name, Component component) {
    Object tuple[] = new Object[10];
    tuple[XmFormLayout.COMPONENT] = component;
    tuple[XmFormLayout.BITSET] = new BitSet();
    tuple[XmFormLayout.NAME] = name;
    int componentNr = m_tuples.size();
    m_tuples.addElement(tuple);
    m_nameToIndex.put(name, new Integer(componentNr));
    m_changedFlag = true;
  }

  /**
   * Parses an expression 'a.b+c' (or 'a.b-c' or 'a.b' or
   * '+c' or '-c') into an rvalue 'a.b' and a signed
   * number 'c'.  If the rvalue is unbound then return
   * XmFormLayout.UNBOUND, otherwise return the value of
   * the expression.
   */
  private final int evaluate(String expression) throws Exception {
    int i, s = 1, v = 0;
    i = expression.indexOf('+');
    if (i == -1) {
      i = expression.indexOf('-');
      s = -1;
    }

    if (i == -1) {
      v = this.getAttr(expression);
    }
    else if (i > 1) {
      String rvalue = expression.substring(0, i);
      v = this.getAttr(rvalue);
    }

    if (i != -1 && v != XmFormLayout.UNBOUND) {
      String unicodeNumber = expression.substring(i+1);
      int number = Integer.parseInt(unicodeNumber, 10);
      v += (s*number);
    }

    return v;
  }

  /**
   * Enforce explicit constraints by binding lvalues and
   * also marking those lvalues which can't be bound.
   * Parses an explicit constraint 'a.b=c.d+e' into
   * an lvalue 'a.b' and an expression 'c.d+e'.
   * Returns true if all possible explicit lvalues are bound.
   */
  private final boolean explicit(BitSet constraintBitset) throws Exception {
    boolean deferFlag = false;
    if (m_constraints == null || m_constraints.length == 0) {
      throw new Exception("no constraints (explicit)");
    }
    for (int i = 0; i < m_constraints.length; ++i) {
      if (constraintBitset.get(i)) {
        continue;
      }
      String constraint = m_constraints[i];
      int j = constraint.indexOf('=');
      if (j < 3) {
        throw new Exception("invalid constraint, expected '=': " +
			    constraint + "(explicit)");
      }
      String lvalue =  constraint.substring(0, j);
      String expression =  constraint.substring(j+1);
      if (this.setAttr(lvalue, this.evaluate(expression))) {
        constraintBitset.set(i);
      }
      else {
        deferFlag = true;
      }
    }
    return !deferFlag;
  }

  /*
   * If the attribute is bound then return its'
   * value, otherwise return XmFormLayout.UNBOUND.
   */
  private final int getAttr(int componentNr, int attrNr) {
    int v = XmFormLayout.UNBOUND;
    if (componentNr == XmFormLayout.FORM) {
      if (attrNr == XmFormLayout.BOTTOM) {
        v = m_formLocation.y +
          m_formDimensions.height;
      }
      else if (attrNr == XmFormLayout.LEFT) {
        v = m_formLocation.x;
      }
      else if (attrNr == XmFormLayout.HCENTER) {
        v = m_formLocation.x + m_formDimensions.width/2;
      }
      else if (attrNr == XmFormLayout.VCENTER) {
        v = m_formLocation.y + m_formDimensions.height/2;
      }
      else if (attrNr == XmFormLayout.RIGHT) {
        v = m_formLocation.x + m_formDimensions.width;
      }
      else if (attrNr == XmFormLayout.TOP) {
        v = m_formLocation.y;
      }
    }
    else if (isBound(componentNr, attrNr)) {
      Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
      v = ((Integer) tuple[attrNr]).intValue();
    }
    return v;
  }

  /**
   * If the attribute is bound then return its'
   * value, otherwise return XmFormLayout.UNBOUND.
   */
  private final int getAttr(String fqAttrName) throws Exception {
    int tuple[] = this.parseAttr(fqAttrName);
    int value = this.getAttr(tuple[0], tuple[1]);
    return value;
  }

  /**
   * Get the attribute number.
   */
  private final int getAttrNr(String attrName) {
    int attrNr = XmFormLayout.INVALID; // invalid attr # (never happens)
    if (attrName.equals("bottom")) {
      attrNr = XmFormLayout.BOTTOM;
    }
    else if (attrName.equals("left") || attrName.equals("x")) {
      attrNr = XmFormLayout.LEFT;
    }
    else if (attrName.equals("hcenter") || attrName.equals("c")) {
      attrNr = XmFormLayout.HCENTER;
    }
    else if (attrName.equals("vcenter")) {
      attrNr = XmFormLayout.VCENTER;
    }
    else if (attrName.equals("right")) {
      attrNr = XmFormLayout.RIGHT;
    }
    else if (attrName.equals("top") || attrName.equals("y")) {
      attrNr = XmFormLayout.TOP;
    }
    return attrNr;
  }

  /**
   * Get the bit set.
   */
  private final BitSet getBitset(int componentNr) {
    Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
    return (BitSet) tuple[XmFormLayout.BITSET];
  }

  /**
   * Get the AWT Component.
   */
  private final Component getComponent(int componentNr) {
    Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
    return (Component) tuple[XmFormLayout.COMPONENT];
  }

  /**
   * Get the AWT Component name.
   */
  private final String getComponentName(int componentNr) {
    Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
    return (String) tuple[XmFormLayout.NAME];
  }

  /**
   * Get the AWT Component number.
   */
  private final int getComponentNr(String componentName) throws Exception {
    Object n = m_nameToIndex.get(componentName);
    if (n == null) {
      /*
       * This exception occurs if there is a component
       * mentioned in the constraints that isn't
       * also in the form.  There are two common
       * reasons for this:
       *
       *  1. The "add(name, component)" method was
       *  never called, or was called with the
       *  wrong name; or
       *
       *  2. The same component was added twice but
       *  with a different name (the second name
       *  will automatically remove the first name).
       *
       */
      throw new Exception("component not found: '" +
			  componentName + "' (getComponentNr)");
    }
    return ((Integer)n).intValue();
  }

  /**
   * Returns the preferred dimension of the specified
   * component. Results are cached for greater efficiency.
   */
  private final Dimension getDimension(int componentNr) {
    Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
    Dimension dimension;
    if (tuple[XmFormLayout.DIMENSION] == null) {
      Component component = (Component) tuple[XmFormLayout.COMPONENT];
      dimension = component.getPreferredSize();
      tuple[XmFormLayout.DIMENSION] = (Object) dimension;
    }
    else {
      dimension = (Dimension) tuple[XmFormLayout.DIMENSION];
    }
    return dimension;
  }

  /**
   * Returns the preferred offset (width or height)
   * between the specified attribute and its' opposite.
   */
  private final int getOppsOffset(int componentNr, int attrNr) {
    int offset = XmFormLayout.INVALID; // invalid offset (never happens)
    Dimension componentDimensions = this.getDimension(componentNr);

    if (attrNr == XmFormLayout.BOTTOM) {
      offset = -componentDimensions.height;
    }
    else if (attrNr == XmFormLayout.LEFT) {
      offset = componentDimensions.width;
    }
    else if (attrNr == XmFormLayout.RIGHT) {
      offset = -componentDimensions.width;
    }
    else if (attrNr == XmFormLayout.TOP) {
      offset = componentDimensions.height;
    }
    return offset;
  }

  /**
   * Returns the preferred offset (width or height)
   * between the specified attribute and its' relative.
   */
  private final int getRelsOffset(int componentNr, int attrNr) {
    int offset = XmFormLayout.INVALID; // invalid offset (never happens)
    Dimension componentDimensions = this.getDimension(componentNr);

    if (attrNr == XmFormLayout.HCENTER) {
      offset = -componentDimensions.width/2;
    }
    else if (attrNr == XmFormLayout.LEFT) {
      offset = componentDimensions.width/2;
    }
    else if (attrNr == XmFormLayout.TOP) {
      offset = componentDimensions.height/2;
    }
    else if (attrNr == XmFormLayout.VCENTER) {
      offset = -componentDimensions.height/2;
    }
    return offset;
  }


  /**
   * Enforces implicit constraints by binding component
   * attributes which haven't an lvalue in ANY explicit
   * constraint and whose opposite attribute is already
   * bound, e.g. if foo.top isn't an lvalue in any explicit
   * constraint, and foo.bottom is bound, and foo has a
   * preferred height of 123, then enforce this implicit
   * constraint:
   *   "foo.top=foo.bottom-123"
   * Returns true if all possible implicit constraints are bound.
   */
  private final boolean implicit() throws Exception {
    boolean deferFlag = false;
    for (int c = 0; c < m_tuples.size(); ++c) {
      for (int a = XmFormLayout.BOTTOM; a <= XmFormLayout.TOP; ++a) {
        if (this.isMarked(c, a) == false) {
          int r = this.relative(a);
          if (r != XmFormLayout.INVALID && this.isBound(c, r) == true) {
            /*
             * This also marks the attr
             */
            this.setAttr(c, a, this.getAttr(c, r) + this.getRelsOffset(c, r));
          }
          else {
            int o = this.opposite(a);
            if (o != XmFormLayout.INVALID && this.isBound(c, o) == true) {
              /*
               * This also marks the attr
               */
              this.setAttr(c, a, this.getAttr(c, o) + this.getOppsOffset(c, o));
            }
            else {
              deferFlag = true;
            }
          }
        }
      }
    }
    return !deferFlag;
  }

  /**
   * Returns true if this component's attribute was
   * bound; that is, if this.setAttr() was called.
   */
  private final boolean isBound(int componentNr, int attributeNr) {
    BitSet bitset = this.getBitset(componentNr);
    return bitset.get(attributeNr);
  }

  /**
   * Returns true if this component's attribute is
   * an lvalue in any explicit constraint; that is,
   * if this.setMarked() was called.
   */
  private final boolean isMarked(int componentNr, int attributeNr) {
    BitSet bitset = this.getBitset(componentNr);
    return bitset.get(attributeNr + (XmFormLayout.TOP+1));
  }

  /**
   * Reshape all components in the container. Typically,
   * this causes a call to this.reconstrain() only the first time.
   */
  public void layoutContainer(Container parent) {
    Dimension dummy = this.preferredLayoutSize(parent); // reconstrain if necessary
    if (!m_changedFlag) {
      for (int c = 0; c < m_tuples.size(); ++c) {
        Object tuple[] = (Object[]) m_tuples.elementAt(c);
        int x = ((Integer)tuple[XmFormLayout.LEFT]).intValue();
        int y = ((Integer)tuple[XmFormLayout.TOP]).intValue();
        int w = ((Integer)tuple[XmFormLayout.RIGHT]).intValue() - x;
        int h = ((Integer)tuple[XmFormLayout.BOTTOM]).intValue() - y;
        Component component = (Component) tuple[XmFormLayout.COMPONENT];
        component.setBounds(x, y, w, h);
      }
    }
  }

  /**
   * XmFormLayout knowns only one size (the preferred size).
   */
  public Dimension minimumLayoutSize(Container parent) {
    return preferredLayoutSize(parent);
  }

  /**
   * Get opposite attribute.
   */
  private final int opposite(int attrNr) {
    int oppositeAttrNr = XmFormLayout.INVALID; // attr doesn't have an opposite

    if (attrNr == XmFormLayout.BOTTOM) {
      oppositeAttrNr = XmFormLayout.TOP;
    }
    else if (attrNr == XmFormLayout.LEFT) {
      oppositeAttrNr = XmFormLayout.RIGHT;
    }
    else if (attrNr == XmFormLayout.RIGHT) {
      oppositeAttrNr = XmFormLayout.LEFT;
    }
    else if (attrNr == XmFormLayout.TOP) {
      oppositeAttrNr = XmFormLayout.BOTTOM;
    }
    return oppositeAttrNr;
  }

  /**
   * Parse a fully-qualified attribute name 'a.b' into
   * a component 'a' and an attribute 'b', and return
   * the component number and attribute number.
   */
  private final int[] parseAttr(String fqAttrName) throws Exception {
    int i = fqAttrName.indexOf('.');
    if (i < 1) {
      throw new Exception(m_myName +
			  "invalid attribute, expected '.': '" + fqAttrName + "' (parseAttr)");
    }
    String componentName = fqAttrName.substring(0, i);
    String attrName = fqAttrName.substring(i+1);
    int tuple[] = new int[2];
    if (componentName.equals("form")) {
      tuple[0] = XmFormLayout.FORM;
    }
    else {
      tuple[0] = this.getComponentNr(componentName);
    }
    tuple[1] = this.getAttrNr(attrName);
    return tuple;
  }

  /**
   * Get the preferred layout size.
   */
  public Dimension preferredLayoutSize(Container parent) {
    Insets insets = parent.getInsets();
    int dx = insets.left + insets.right;
    int dy = insets.top + insets.bottom;
    int x = insets.left;
    int y = insets.top;
    int w = parent.getSize().width - dx;
    int h = parent.getSize().height - dy;
    this.setBounds(x, y, w, h);

    return new Dimension(m_formDimensions.width + dx,
			 m_formDimensions.height + dy);
  }

  /**
   * Get the relative attribute.
   */
  private final int relative(int attrNr) {
    int relativeAttrNr = XmFormLayout.INVALID; // attr doesn't have a relative

    if (attrNr == XmFormLayout.HCENTER) {
      relativeAttrNr = XmFormLayout.LEFT;
    }
    else if (attrNr == XmFormLayout.LEFT) {
      relativeAttrNr = XmFormLayout.HCENTER;
    }
    else if (attrNr == XmFormLayout.TOP) {
      relativeAttrNr = XmFormLayout.VCENTER;
    }
    else if (attrNr == XmFormLayout.VCENTER) {
      relativeAttrNr = XmFormLayout.TOP;
    }
    return relativeAttrNr;
  }


  /**
   * Removes a component.  This isn't particularly fast,
   * but it is rarely called, if ever.
   */
  public void removeLayoutComponent(Component oldComponent) {
    int nrComponents = m_tuples.size();
    for (int c = 0; c < nrComponents; ++c) {
      if (this.getComponent(c) == oldComponent) {
        String componentName = this.getComponentName(c);
        m_nameToIndex.remove(componentName);
        m_changedFlag = true;
      }
    }
  }

  /**
   * Layout the container according to constraints.
   * This may be time-consuming, so it should only be
   * done if changedFlag is true.
   */
  private final void reconstrain() throws Exception {
    BitSet constraintBitset = new BitSet();
    for (int c = 0; c < m_tuples.size(); ++c) {
      Object tuple[] = (Object[]) m_tuples.elementAt(c);
      tuple[XmFormLayout.DIMENSION] = null; // component's preferred size may have changed
      BitSet componentBitset = (BitSet) tuple[XmFormLayout.BITSET];

      /*
       * The componentBitset has no clearAllBits()
       * method so AND with any blank bitset to clear it.
       */
      componentBitset.and(constraintBitset);
    }
    boolean deferFlag;
    int nrTries = 0;
    do {
      deferFlag = false;
      if (! this.explicit(constraintBitset)) {
        deferFlag = true;
      }
      if (! this.implicit()) {
        deferFlag = true;
      }
    }
    while (deferFlag && ++nrTries < 30);

    if (deferFlag) {
      throw new Exception("possible cycle in constraints, failed after " +
			  nrTries + " iterations (reconstrain)");
    }
    m_changedFlag = false;
  }

  /**
   * If the container's location or shape has
   * changed, or if any of the component's have
   * changed, then re-compute the constraints;
   * otherwise use what was already computed.
   */
  private final void setBounds(int x, int y, int w, int h) {
    if (m_formDimensions.width != w ||
        m_formDimensions.height != h) {
      m_formDimensions.width = w;
      m_formDimensions.height = h;
      m_changedFlag = true;
    }
    if (m_formLocation.x != x ||
        m_formLocation.y != y) {
      m_formLocation.x = x;
      m_formLocation.y = y;
      m_changedFlag = true;
    }
    if (m_changedFlag) {
      try {
        this.reconstrain();
      }
      catch (Exception exception) {
        System.out.println(m_myName +
			   " error: " +
			   exception.getMessage() + "\n");
      }
    }
  }

  /**
   * Try to set a attribute; returns true if the was set
   * or false if it was deferred (the latter will happen
   * if the value is XmFormLayout.UNBOUND).
   */
  private final boolean setAttr(int componentNr, int attrNr, int value) throws Exception {
    if (componentNr == XmFormLayout.FORM) {
      throw new Exception("invalid constraint, can't set attributes of form (setAtttr)");
    }
    this.setMarked(componentNr, attrNr);
    boolean boundFlag = false;
    if (value != XmFormLayout.UNBOUND) {
      Object tuple[] = (Object[]) m_tuples.elementAt(componentNr);
      tuple[attrNr] = new Integer(value);
      this.setBound(componentNr, attrNr);
      boundFlag = true;
    }
    return boundFlag;
  }

  /**
   * Try to set a attribute 'c.a'; returns true if the
   * was set or false if it was deferred (the latter
   * will happen if the value is XmFormLayout.UNBOUND).
   */
  private final boolean setAttr(String fqAttrName, int value) throws Exception {
    int tuple[] = this.parseAttr(fqAttrName);
    return this.setAttr(tuple[0], tuple[1], value);
  }

  /**
   * Set the bound of a component.
   */
  private final void setBound(int componentNr, int attrNr) {
    BitSet bitset = this.getBitset(componentNr);
    bitset.set(attrNr);
  }

  /**
   * Set a component as marked..
   */
  private final void setMarked(int componentNr, int attrNr) {
    BitSet bitset = this.getBitset(componentNr);
    bitset.set(attrNr + (XmFormLayout.TOP+1));
  }

}
-----



    private static void auditLog(String fileName, String status, String errorMessage) {
        String logEntry = String.format("%s | File: %s | Status: %s | Error: %s",
                LocalDateTime.now(), fileName, status, (errorMessage != null ? errorMessage : "None"));
        
        // Append to an audit log file
        try {
            Files.write(Paths.get("audit.log"), (logEntry + System.lineSeparator()).getBytes(),
                        StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        } catch (IOException e) {
            logger.log(Level.SEVERE, "Failed to write to audit log", e);
        }
    }


package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Service;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

@Service
public class CreateJsonForFiles {

    // Create a JSON file for the given PDF file using its metadata
    public boolean createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // Build the metadata JSON in the new format
        String json = buildJsonFromMeta(metaData);

        // Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        return true;
    }

    // Convert the ModelMain metadata to JSON in the new format
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // Create the new structured JSON object
        JsonStructure jsonStructure = new JsonStructure();

        // Populate the "plan" part
        jsonStructure.getPlan().setNumber(metaData.getPlanNumber());
        jsonStructure.getPlan().setName(metaData.getPlanName());
        jsonStructure.getPlan().setSource("401K");

        // Populate the "document" part
        jsonStructure.getDocument().setDocumentTypeCode("testdmtycode");
        jsonStructure.getDocument().setCategory(metaData.getCategory());

        // Convert the JsonStructure object to a JSON string
        return objectMapper.writeValueAsString(jsonStructure);
    }

    // Class to represent the new JSON structure
    private static class JsonStructure {
        private Plan plan = new Plan();
        private Document document = new Document();

        public Plan getPlan() {
            return plan;
        }

        public void setPlan(Plan plan) {
            this.plan = plan;
        }

        public Document getDocument() {
            return document;
        }

        public void setDocument(Document document) {
            this.document = document;
        }

        // Inner class for "plan" structure
        static class Plan {
            private String number;
            private String name;
            private String source;

            public String getNumber() {
                return number;
            }

            public void setNumber(String number) {
                this.number = number;
            }

            public String getName() {
                return name;
            }

            public void setName(String name) {
                this.name = name;
            }

            public String getSource() {
                return source;
            }

            public void setSource(String source) {
                this.source = source;
            }
        }

        // Inner class for "document" structure
        static class Document {
            private String documentTypeCode;
            private String category;

            public String getDocumentTypeCode() {
                return documentTypeCode;
            }

            public void setDocumentTypeCode(String documentTypeCode) {
                this.documentTypeCode = documentTypeCode;
            }

            public String getCategory() {
                return category;
            }

            public void setCategory(String category) {
                this.category = category;
            }
        }
    }
}



package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.stereotype.Service;

import java.io.File;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
@Service
public class CreateJsonForFiles {

    // Create a JSON file for the given PDF file using its metadata
    public boolean createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // Build the metadata JSON (model object)
        String json = buildJsonFromMeta(metaData);

        // Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        return true;
    }

    // Convert the ModelMain metadata to JSON
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // Convert the ModelMain object into JSON
        return objectMapper.writeValueAsString(metaData);
    }

}
package com.ecm1.ECM1;



public class ModelMain {

    private String planNumber;
    private String planName;
    private String category;
    private String ssn;
    private String individualId;
    private String database;
    private String documentDetails;
    private String certificateIssueDate;
    private String participantName;


    public ModelMain(String planName, String planNumber, String ssn, String individualId, String database, String certificateIssueDate, String participantName) {
        this.planName = planName;
        this.planNumber = planNumber;
        this.category = "MassMutual";
        this.ssn = ssn;
        this.individualId = individualId;
        this.database = database;
        this.documentDetails = "Regulatory";
        this.certificateIssueDate = certificateIssueDate;
        this.participantName = participantName;
    }

    public ModelMain(String planNumber, String planName) {
        this.planNumber = planNumber;
        this.planName = planName;
        this.category = "MassMutual";
    }

    public ModelMain() {

    }
//    private String category;


    public String getPlanName() {
        return planName;
    }

    public String getCategory() {
        return category;
    }

    public String getSsn() {
        return ssn;
    }

    public String getIndividualId() {
        return individualId;
    }

    public String getDatabase() {
        return database;
    }

    public String getDocumentDetails() {
        return documentDetails;
    }

    public String getCertificateIssueDate() {
        return certificateIssueDate;
    }

    public void setSsn(String ssn) {
        this.ssn = ssn;
    }

    public void setCategory(String category) {
        this.category = category;
    }

    public void setDatabase(String database) {
        this.database = database;
    }

    public void setIndividualId(String individualId) {
        this.individualId = individualId;
    }

    public void setDocumentDetails(String documentDetails) {
        this.documentDetails = documentDetails;
    }

    public void setCertificateIssueDate(String certificateIssueDate) {
        this.certificateIssueDate = certificateIssueDate;
    }

    public void setParticipantName(String participantName) {
        this.participantName = participantName;
    }

    public String getParticipantName() {
        return participantName;
    }

    public void setPlanName(String planName) {
        this.planName = planName;
    }

    public String getPlanNumber() {
        return planNumber;
    }

    public void setPlanNumber(String planNumber) {
        this.planNumber = planNumber;
    }

    @Override
    public String toString() {
        return "ModelMain{" +
                "planNumber='" + planNumber + '\'' +
                ", planName='" + planName + '\'' +
                ", category='" + category + '\'' +
                ", ssn='" + ssn + '\'' +
                ", individualId='" + individualId + '\'' +
                ", database='" + database + '\'' +
                ", documentDetails='" + documentDetails + '\'' +
                ", certificateIssueDate='" + certificateIssueDate + '\'' +
                ", participantName='" + participantName + '\'' +
                '}';
    }
}

{
    "plan": {
        "number": "932777-01",
        "name": "ABC Corporation, Inc",
        "source": "401K"
     },
    "document": 
     {
        "documentTypeCode": "testdmtycode",
        "category": "testCategory"
     }
}




package com.ecm1.ECM1;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log"; // Path to the log file

    // Flags for tracking success and failure counts
    private static int successCount = 0;
    private static int failureCount = 0;

    // Flag to track if the headers are written
    private static boolean headersWritten = false;

    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        // Ensure headers are written only once
        if (!headersWritten) {
            writeHeaders();
            headersWritten = true;
        }

        String timestamp = dateFormat.format(new Date());

        // Update the success or failure count
        if ("Success".equalsIgnoreCase(status)) {
            successCount++;
        } else if ("Failure".equalsIgnoreCase(status)) {
            failureCount++;
        }

        // Format the log entry to be in a single line
        String logEntry = String.format(
                "%s | Action: %s | Status: %s | Message: %s | File Name: %s | File Path: %s | User: %s",
                timestamp, actionType, status, message, fileName, filePath, user
        );

        // Write the log entry to the file
        writeLogToFile(logEntry);
        // Add a space (new line) after each log entry for better readability
        writeLogToFile("\n");
    }

    // Writes the header only once at the beginning of the log file
    private static void writeHeaders() {
        String header = String.format(
                "==================================================\n" +
                "                 ECM1 Audit Log\n" +
                "              Environment: Production\n" +
                "            Log Start Time: %s\n" +
                "==================================================\n\n", 
                dateFormat.format(new Date())
        );

        writeLogToFile(header);
    }

    // Writes the footer with success and failure counts
    private static void writeFooter() {
        String footer = String.format(
                "\n==================================================\n" +
                "           End of ECM1 Audit Log\n" +
                "           Success Count: %d\n" +
                "           Failure Count: %d\n" +
                "==================================================\n",
                successCount, failureCount
        );

        writeLogToFile(footer);
    }

    // Writes log entries to the specified log file
    private static void writeLogToFile(String logEntry) {
        try {
            Files.write(
                    Paths.get(LOG_FILE_PATH),
                    logEntry.getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND
            );
        } catch (IOException e) {
            System.err.println("Error writing log to file: " + e.getMessage());
        }
    }

    // Method to call at the end of the program to write footer
    public static void closeLogFile() {
        writeFooter();
    }
}




package com.ecm1.ECM1;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log"; // Path to the log file

    // Flag to track if the headers are written
    private static boolean headersWritten = false;

    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        // Ensure headers are written only once
        if (!headersWritten) {
            writeHeaders();
            headersWritten = true;
        }

        String timestamp = dateFormat.format(new Date());
        String logEntry = String.format(
                "Date: %s\nAction: %s\nStatus: %s\nMessage: %s\nFile Name: %s\nFile Path: %s\nUser: %s\n--------------------------------------------------",
                timestamp, actionType, status, message, fileName, filePath, user
        );

        // Write the log entry to the file
        writeLogToFile(logEntry);
    }

    // Writes the header only once at the beginning of the log file
    private static void writeHeaders() {
        String header = String.format(
                "--------------------------------------------------\n" +
                "Project: ECM1 Audit Log\n" +
                "Environment: Production\n" +
                "Log Start Time: %s\n" +
                "--------------------------------------------------\n\n", 
                dateFormat.format(new Date())
        );

        writeLogToFile(header);
    }

    // Writes log entries to the specified log file
    private static void writeLogToFile(String logEntry) {
        try {
            Files.write(
                    Paths.get(LOG_FILE_PATH),
                    (logEntry + System.lineSeparator()).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND
            );
        } catch (IOException e) {
            System.err.println("Error writing log to file: " + e.getMessage());
        }
    }
}





package com.ecm1.ECM1;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log"; // Path to the log file

    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        String timestamp = dateFormat.format(new Date());
        String logEntry = String.format(
                "Date: %s\nAction: %s\nStatus: %s\nMessage: %s\nFile Name: %s\nFile Path: %s\nUser: %s\n--------------------------------------------------",
                timestamp, actionType, status, message, fileName, filePath, user
        );

        // Write the log entry to the file
        writeLogToFile(logEntry);
    }

    // Writes log entries to the specified log file
    private static void writeLogToFile(String logEntry) {
        try {
            Files.write(
                    Paths.get(LOG_FILE_PATH),
                    (logEntry + System.lineSeparator()).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND
            );
        } catch (IOException e) {
            System.err.println("Error writing log to file: " + e.getMessage());
        }
    }
}




package com.ecm1.ECM1;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {


    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        String timestamp = dateFormat.format(new Date());
        String logEntry = String.format(
                "Date: %s\nAction: %s\nStatus: %s\nMessage: %s\nFile Name: %s\nFile Path: %s\nUser: %s\n--------------------------------------------------",
                timestamp, actionType, status, message, fileName, filePath, user
        );
        System.out.println(logEntry);

        // You can also write the log entry to a file if needed:
         writeLogToFile(logEntry);
    }

    // Example of writing log entries to a file (optional)
    private static void writeLogToFile(String logEntry) {
          final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log";

        try {
            Files.write(
                    Paths.get(LOG_FILE_PATH),
                    (logEntry + System.lineSeparator()).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}



public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
    int successCount = 0; // Counter for successful actions
    int failureCount = 0; // Counter for failed actions

    try (InputStream inputStream = new FileInputStream(excelFilePath)) {
        // Read and parse the Excel file
        List<ModelMain> rows = parseExcelFile(inputStream);

        // Debugging: Print parsed rows
        for (ModelMain m : rows) {
            System.out.println(m);
        }

        for (ModelMain row : rows) {
            // Get the file based on plan number from the Excel metadata
            File pdfFile = getPdf.getFile(row.getPlanNumber(), sourceDirPath, fileCount);
            if (pdfFile != null) {
                // Log file retrieval success
                AuditTrailLogger.logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                        pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                // Copy the file to the destination directory
                boolean fileCopied = getPdf.copyFile(pdfFile, destinationDirPath);
                if (fileCopied) {
                    // Log successful file copy
                    AuditTrailLogger.logAction("File Copy", "Success", "File copied successfully.",
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                    // Create JSON for the copied file
                    boolean jsonCreated = createJson.createJsonForFile(pdfFile, row, destinationDirPath);
                    if (jsonCreated) {
                        // Log successful JSON creation
                        AuditTrailLogger.logAction("JSON Creation", "Success", "JSON created successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        successCount++; // Increment success counter
                    } else {
                        // Log failed JSON creation
                        AuditTrailLogger.logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        failureCount++; // Increment failure counter
                    }
                } else {
                    // Log failure in file copy
                    AuditTrailLogger.logAction("File Copy", "Failure", "Failed to copy file.",
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                    failureCount++; // Increment failure counter
                }
            } else {
                // Log failure in file retrieval
                AuditTrailLogger.logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                        row.getPlanNumber(), sourceDirPath, currentUser);
                failureCount++; // Increment failure counter
            }
        }
    }

    // Log summary of processing
    AuditTrailLogger.logAction(
            "Summary",
            "Info",
            "Processing completed. Total Success: " + successCount + ", Total Failure: " + failureCount,
            "Summary",
            excelFilePath,
            currentUser
    );
}
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        String timestamp = dateFormat.format(new Date());
        String logEntry = String.format(
                "Date: %s\nAction: %s\nStatus: %s\nMessage: %s\nFile Name: %s\nFile Path: %s\nUser: %s\n--------------------------------------------------",
                timestamp, actionType, status, message, fileName, filePath, user
        );
        System.out.println(logEntry);

        // You can also write the log entry to a file if needed:
        // writeLogToFile(logEntry);
    }

    // Example of writing log entries to a file (optional)
    private static void writeLogToFile(String logEntry) {
        try {
            Files.write(
                    Paths.get("audit-trail.log"),
                    (logEntry + System.lineSeparator()).getBytes(),
                    StandardOpenOption.CREATE, StandardOpenOption.APPEND
            );
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}




/ Main method for processing the files and creating JSON files
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            // Read and parse the Excel file
            List<ModelMain> rows = parseExcelFile(inputStream);
            for(ModelMain m : rows){
                System.out.println(m);
            }

            for (ModelMain row : rows) {
                // Get the file based on plan number from the Excel metadata
                File pdfFile = getPdf.getFile(row.getPlanNumber(), sourceDirPath,fileCount);
                if (pdfFile != null) {
                    // 1. Log file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                    // Copy the file to the destination directory
                    boolean fileCopied = getPdf.copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // 2. Log successful file copy
                        AuditTrailLogger.logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                        // 3. Create JSON for the copied file
                        boolean jsonCreated = createJson.createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // 4. Log successful JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        } else {
                            // 4. Log failed JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        }
                    } else {
                        // Log failure in file copy
                        AuditTrailLogger.logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                    }
                } else {
                    // Log failure in file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath, currentUser);
                }
            }
        }
    }




package com.ecm1.ECM1;

import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log";

    // Tracks successes and failures
    private static int successCount = 0;
    private static int failureCount = 0;

    // Log the start of file processing
    public static void logProcessingStart(String inputFileName, String sheetName) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            String timestamp = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date());
            writer.write(String.format("Date: %s\n", timestamp));
            writer.write(String.format("Input File Name: %s\n", inputFileName));
            writer.write(String.format("Sheet Name: %s\n", sheetName));
            writer.write("File Processing Starts\n");
            writer.newLine();
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }

    // Log processing details for a specific plan
    public static void logProcessingPlan(String planNumber, String templateFile) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            writer.write(String.format("Processing Plan: %s\n", planNumber));
            writer.write(String.format("Template File: %s\n", templateFile));
            writer.newLine();
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }

    // Log actions with status and user information
    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            String timestamp = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date());
            String logEntry = String.format("[%s] Action: %s, Status: %s, Message: %s, File: %s, File Path: %s, User: %s",
                    timestamp, actionType, status, message, fileName, filePath, user);
            writer.write(logEntry);
            writer.newLine();

            // Increment success or failure counts
            if ("Success".equalsIgnoreCase(status)) {
                successCount++;
            } else {
                failureCount++;
            }
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }

    // Log the end of processing with a summary
    public static void logProcessingSummary() {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            writer.write("File Processing Ends\n");
            writer.write(String.format("Total Successes: %d\n", successCount));
            writer.write(String.format("Total Failures: %d\n", failureCount));
            writer.newLine();

            // Reset counters for the next run
            successCount = 0;
            failureCount = 0;
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }
}




package com.ecm1.ECM1;



import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log";

    // Method to log actions to the audit trail file, including who performed the action
    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            // Prepare log entry with timestamp, file details, and user
            String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
            String logEntry = String.format("[%s] Action: %s, Status: %s, Message: %s, File: %s, File Path: %s, User: %s",
                    timestamp, actionType, status, message, fileName, filePath, user);
            // Write the log entry to the file
            writer.write(logEntry);
            writer.newLine(); // Add a new line after each log entry
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }
}





package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class Service1 {

    private HashMap<String, Integer> fileCount = new HashMap<>();
    private String currentUser = "User123"; // This could be fetched dynamically, e.g., from session.

    // Main method for processing the files and creating JSON files
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            // Read and parse the Excel file
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                // Get the file based on plan number from the Excel metadata
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // 1. Log file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                    // Copy the file to the destination directory
                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // 2. Log successful file copy
                        AuditTrailLogger.logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                        // 3. Create JSON for the copied file
                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // 4. Log successful JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        } else {
                            // 4. Log failed JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        }
                    } else {
                        // Log failure in file copy
                        AuditTrailLogger.logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                    }
                } else {
                    // Log failure in file retrieval
                    System.out.println("failt not found qw");
                    AuditTrailLogger.logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath, currentUser);
                }
            }
        }
    }

    // Parse the Excel file and extract rows of metadata
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if it's empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();
                String ssn = row.getCell(9) + "";
                String individualId = row.getCell(8) + "";
                String database = row.getCell(3).getStringCellValue();
                String certificateIssueDate = row.getCell(7)+"";
                String participantName = row.getCell(13).getStringCellValue();

                // Create a ModelMain object and add it to the list
                ModelMain ecm = new ModelMain(plan_number, plan_name, ssn, individualId, database, certificateIssueDate, participantName);
                excelRows.add(ecm);
            }
        }
        return excelRows;
    }

    // Locate the file corresponding to a plan number
    public File getFile(String planNumber, String sourceDirPath) throws Exception {
        // Retrieve the current count for the plan number
        int count = fileCount.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically to match file names
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber, count);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the source directory path
        File directory = new File(sourceDirPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            fileCount.put(planNumber, count + 1);
            return matchingFiles[0];
        }
        return null;
    }

    // Copy the file to the destination directory
    public boolean copyFile(File file, String destinationDirPath) throws IOException {
        if (file == null || !file.exists()) {
            return false;
        }

        Path sourcePath = file.toPath();
        Path destinationPath = Paths.get(destinationDirPath, file.getName());

        // Create destination directory if it does not exist
        File destinationFolder = new File(destinationDirPath);
        if (!destinationFolder.exists()) {
            destinationFolder.mkdirs();
        }

        // Copy the file to the destination directory
        Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        return true;
    }

    // Create a JSON file for the given PDF file using its metadata
    private boolean createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // Build the metadata JSON (model object)
        String json = buildJsonFromMeta(metaData);

        // Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        return true;
    }

    // Convert the ModelMain metadata to JSON
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // Convert the ModelMain object into JSON
        return objectMapper.writeValueAsString(metaData);
    }

}






Initialized JPA EntityManagerFactory for persistence unit 'default'
java.lang.IllegalStateException: Cannot get a STRING value from a NUMERIC cell
	at org.apache.poi.xssf.usermodel.XSSFCell.typeMismatch(XSSFCell.java:987)
	at org.apache.poi.xssf.usermodel.XSSFCell.getRichStringCellValue(XSSFCell.java:336)
	at org.apache.poi.xssf.usermodel.XSSFCell.getStringCellValue(XSSFCell.java:280)
	at com.ecm1.ECM1.Service1.parseExcelFile(Service1.java:82)
	at com.ecm1.ECM1.Service1.processFilesAndCreateJson(Service1.java:24)
	at com.ecm1.ECM1.ECMcontroller.processFiles(ECMcontroller.java:36)
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:22)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:15)
Failed to process file: Cannot get a STRING value from a NUMERIC cell
2025-01-20T01:05:56.496-07:00  WARN 13072 --- [ECM1] [           main] JpaBaseConfiguration$JpaWebConfiguration : spring.jpa.open-in-view is enabled by default. Therefore, database queries may be performed during view rendering. Explicitly configure spring.jpa.open-in-view to disable this warning
2025-01-20T01:05:57.232-07:00  INFO 13072 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8082 (http) with context path '/'
2025-01-20T01:05:57.279-07:00  INFO 13072 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Started Ecm1Application in 8.371 seconds (process running for 9.784)
ECM Application is running!

package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class Service1 {

    private HashMap<String, Integer> fileCount = new HashMap<>();
    private String currentUser = "User123"; // This could be fetched dynamically, e.g., from session.

    // Main method for processing the files and creating JSON files
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            // Read and parse the Excel file
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                // Get the file based on plan number from the Excel metadata
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // 1. Log file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                    // Copy the file to the destination directory
                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // 2. Log successful file copy
                        AuditTrailLogger.logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                        // 3. Create JSON for the copied file
                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // 4. Log successful JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        } else {
                            // 4. Log failed JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        }
                    } else {
                        // Log failure in file copy
                        AuditTrailLogger.logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                    }
                } else {
                    // Log failure in file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath, currentUser);
                }
            }
        }
    }

    // Parse the Excel file and extract rows of metadata
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if it's empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();
                String ssn = row.getCell(9) + "";
                String individualId = row.getCell(8) + "";
                String database = row.getCell(3).getStringCellValue();
                String certificateIssueDate = row.getCell(7).getStringCellValue();
                String participantName = row.getCell(13).getStringCellValue();

                // Create a ModelMain object and add it to the list
                ModelMain ecm = new ModelMain(plan_number, plan_name,ssn, individualId, database, certificateIssueDate, participantName);
                excelRows.add(ecm);
            }
        }
        return excelRows;
    }

    // Locate the file corresponding to a plan number
    public File getFile(String planNumber, String sourceDirPath) throws Exception {
        // Retrieve the current count for the plan number
        int count = fileCount.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically to match file names
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber, count);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the source directory path
        File directory = new File(sourceDirPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            fileCount.put(planNumber, count + 1);
            return matchingFiles[0];
        }
        return null;
    }

    // Copy the file to the destination directory
    public boolean copyFile(File file, String destinationDirPath) throws IOException {
        if (file == null || !file.exists()) {
            return false;
        }

        Path sourcePath = file.toPath();
        Path destinationPath = Paths.get(destinationDirPath, file.getName());

        // Create destination directory if it does not exist
        File destinationFolder = new File(destinationDirPath);
        if (!destinationFolder.exists()) {
            destinationFolder.mkdirs();
        }

        // Copy the file to the destination directory
        Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        return true;
    }

    // Create a JSON file for the given PDF file using its metadata
    private boolean createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // Build the metadata JSON (model object)
        String json = buildJsonFromMeta(metaData);

        // Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        return true;
    }

    // Convert the ModelMain metadata to JSON
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // Convert the ModelMain object into JSON
        return objectMapper.writeValueAsString(metaData);
    }

}


Code/Url: https://plum.gift/At1f9XjNGUnrPjzB ExpiryDate: 2026-01-17
https://empower.achievers.com/orders/status/111478276/abcdfgiklmnpqrsuvw3efijkmqsvxy13

Use RK - Participant type
		○ SSN - If blank, put in audit trail as error
		○ SSN Extension - 1, 2, 3, … - is it there? Will we add from EASY? If exists, use it, if not, leave blank
		○ IndividualID - another primary key - IND_ID column - If blank, put in audit trail as error
		○ Plan Number
		○ Plan Name
		○ DBINST - 401k, … - Database column - Add from EASY? - DATABASE, SOURCE_SYSTEM - Column D
		○ CATEGORY - "PARTICIPANT CERTIFICATE" (50 characters)  - Hard coded?
		○ Document Details - "Regulatory" (100 characters)  - Hard coded?
		○ Legacy Plan Number - think about - Legacy Doc ID, Date - Not for now - Prior Plan
		○ Certificate Issue Date
		○ Participant Name - How to store? Is it in OnBase
		○ Date - Timestamped on load



package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

@Service
public class Service1 {

    private static final Logger LOGGER = Logger.getLogger(Service1.class.getName());

    // Holds the count of files processed for each planNumber to handle versioning of files
    private final Map<String, Integer> fileCount = new HashMap<>();

    // Placeholder for user info, typically fetched dynamically from user session/context
    private String currentUser = "User123";

    @Value("${onbase.api.url}")  // Assuming the OnBase API URL is stored in application.properties or yml
    private String onbaseApiUrl;

    @Value("${onbase.api.key}")
    private String onbaseApiKey;

    /**
     * Main method that processes the files based on the given Excel data, copying them 
     * to a destination folder and creating corresponding JSON metadata files.
     *
     * @param excelFilePath path to the Excel file that contains metadata
     * @param sourceDirPath path where the source PDF files are located
     * @param destinationDirPath path where the PDF files should be copied, and JSON files should be created
     * @throws Exception if any error occurs during processing
     */
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // Log the success of file retrieval
                    logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath());

                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // Log success of file copy
                        logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());

                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // Log success of JSON creation
                            logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());

                            // Step 3: QC Validation
                            boolean isValid = performQC(pdfFile, row);
                            if (isValid) {
                                // QC Passed, proceed to OnBase upload
                                boolean uploadedToOnBase = uploadToOnBase(pdfFile, row);
                                if (uploadedToOnBase) {
                                    logAction("OnBase Upload", "Success", "File uploaded to OnBase successfully.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                } else {
                                    logAction("OnBase Upload", "Failure", "Failed to upload file to OnBase.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                }
                            } else {
                                logAction("QC Validation", "Failure", "File failed QC validation.",
                                        pdfFile.getName(), pdfFile.getAbsolutePath());
                            }
                        } else {
                            logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());
                        }
                    } else {
                        logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());
                    }
                } else {
                    logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath);
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "An error occurred during file processing", e);
            throw new Exception("Error occurred while processing files", e);
        }
    }

    /**
     * QC Validation step to verify file quality and metadata.
     *
     * @param pdfFile the PDF file to validate
     * @param row the metadata associated with the file
     * @return true if the file passes QC, false otherwise
     */
    private boolean performQC(File pdfFile, ModelMain row) {
        // Implement your QC checks here (e.g., file format, metadata validity)
        // Example: checking if the PDF file is not empty and the metadata is non-empty
        boolean isFileValid = pdfFile.exists() && pdfFile.length() > 0;
        boolean isMetadataValid = row != null && row.getPlanNumber() != null && !row.getPlanNumber().isEmpty();

        if (!isFileValid) {
            LOGGER.log(Level.WARNING, "File failed QC check (empty or invalid file): " + pdfFile.getAbsolutePath());
        }
        if (!isMetadataValid) {
            LOGGER.log(Level.WARNING, "Metadata failed QC check (missing or invalid): " + row.getPlanNumber());
        }

        return isFileValid && isMetadataValid;
    }

    /**
     * Uploads the file and metadata to OnBase using its API.
     *
     * @param pdfFile the PDF file to upload
     * @param row the metadata to send to OnBase
     * @return true if the file and metadata were uploaded successfully, false otherwise
     */
    private boolean uploadToOnBase(File pdfFile, ModelMain row) {
        try {
            // Construct the payload (metadata + file path) for OnBase API
            OnBaseUploadRequest request = new OnBaseUploadRequest();
            request.setPlanNumber(row.getPlanNumber());
            request.setPlanName(row.getPlanName());
            request.setFilePath(pdfFile.getAbsolutePath());

            // Create RestTemplate to send data to OnBase API
            RestTemplate restTemplate = new RestTemplate();
            restTemplate.getInterceptors().add(new HttpRequestInterceptor(onbaseApiKey));

            // Send the POST request to OnBase API
            String url = onbaseApiUrl + "/upload";
            String response = restTemplate.postForObject(url, request, String.class);

            // Handle the response to check if the upload was successful
            return response != null && response.contains("success");
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error uploading to OnBase", e);
            return false;
        }
    }

    /**
     * Parse the Excel file to extract the metadata.
     *
     * @param inputStream InputStream for the Excel file
     * @return List of ModelMain objects representing rows of the Excel sheet
     * @throws Exception if an error occurs during parsing
     */
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume first sheet contains data

            for (int i = 1; i <= sheet.getLastRowNum(); i++) {  // Skipping header row (index 0)
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip if row is empty
                    continue;
                }

                String planName = getStringCellValue(row, 5); // Plan Name column (adjust index as needed)
                String planNumber = getStringCellValue(row, 4); // Plan Number column (adjust index as needed)

                ModelMain ecm = new ModelMain(planNumber, planName);
                excelRows.add(ecm);
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error while parsing Excel file", e);
            throw new Exception("Error while parsing the Excel file", e);
        }
        return excelRows;
    }

    /**
     * Fetches the value of a cell, safely handling nulls and blank cells.
     *
     * @param row the row containing the cell
     * @param columnIndex the index of the cell to fetch
     * @return the cell value as a String, or empty string if the cell is null
     */
    private String getStringCellValue(Row row, int columnIndex) {
        Cell cell = row.getCell(columnIndex);
        if (cell == null) {
            return "";
        }
        return cell.toString().trim();
    }

    /**
     * Logs actions for auditing purposes.
     *
     * @param action the action performed (e.g., "File Retrieval")
     * @param status the status of the action (e.g., "Success")
     * @param message a descriptive message about the action
     * @param fileName the name of the file associated with the action
     * @param filePath the full path of the file associated with the action
     */
    private void logAction(String action, String status, String message, String fileName, String filePath) {
        try {
            // Here we can use a custom audit logger that writes to a database or a file
            AuditTrailLogger.logAction(action, status, message, fileName, filePath, currentUser);
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Error logging action: " + action, e);
        }
    }

    /**
     * Copies the PDF file to the destination directory.
     *
     * @param pdfFile the PDF file to copy
     * @param destinationDirPath the path of the destination directory
     * @return true if the file was copied successfully, false otherwise
     */
    private boolean copyFile(File pdfFile, String destinationDirPath) {
        try {
            Path destinationPath = Paths.get(destinationDirPath, pdfFile.getName());
            Files.copy(pdfFile.toPath(), destinationPath, StandardCopyOption.REPLACE_EXISTING);
            return true;
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Failed to copy file: " + pdfFile.getAbsolutePath(), e);
            return false;
        }
    }

    /**
     * Creates a JSON file with metadata for the given PDF file.
     *
     * @param pdfFile the PDF file
     * @param row the metadata for the file
     * @param destinationDirPath the destination directory where the JSON will be saved
     * @return true if the JSON was created successfully, false otherwise
     */
    private boolean createJsonForFile(File pdfFile, ModelMain row, String destinationDirPath) {
        try {
            ObjectMapper objectMapper = new ObjectMapper();
            String jsonFilePath = destinationDirPath + "/" + pdfFile.getName() + ".json";

            Map<String, String> metadata = new HashMap<>();
            metadata.put("planNumber", row.getPlanNumber());
            metadata.put("planName", row.getPlanName());
            metadata.put("filePath", pdfFile.getAbsolutePath());

            // Write the JSON metadata to the file
            objectMapper.writeValue(new File(jsonFilePath), metadata);
            return true;
        } catch (IOException e) {
            LOGGER.log(Level.SEVERE, "Failed to create JSON file for: " + pdfFile.getAbsolutePath(), e);
            return false;
        }
    }

    /**
     * Gets the PDF file associated with the planNumber from the source directory.
     *
     * @param planNumber the plan number to search for
     * @param sourceDirPath the path of the source directory containing PDF files
     * @return the file if found, or null if not found
     */
    private File getFile(String planNumber, String sourceDirPath) {
        File sourceDir = new File(sourceDirPath);
        File[] files = sourceDir.listFiles((dir, name) -> name.contains(planNumber) && name.endsWith(".pdf"));
        if (files != null && files.length > 0) {
            return files[0];  // Assuming the first match is the correct file
        }
        return null;
    }
}





package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.logging.Level;
import java.util.logging.Logger;

@Service
public class Service1 {

    private static final Logger LOGGER = Logger.getLogger(Service1.class.getName());
    
    // Holds the count of files processed for each planNumber to handle versioning of files
    private final Map<String, Integer> fileCount = new HashMap<>();
    
    // Placeholder for user info, typically fetched dynamically from user session/context
    private String currentUser = "User123";
    
    @Value("${onbase.api.url}")  // Assuming the OnBase API URL is stored in application.properties or yml
    private String onbaseApiUrl;
    
    @Value("${onbase.api.key}")
    private String onbaseApiKey;

    /**
     * Main method that processes the files based on the given Excel data, copying them 
     * to a destination folder and creating corresponding JSON metadata files.
     *
     * @param excelFilePath path to the Excel file that contains metadata
     * @param sourceDirPath path where the source PDF files are located
     * @param destinationDirPath path where the PDF files should be copied, and JSON files should be created
     * @throws Exception if any error occurs during processing
     */
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // Log the success of file retrieval
                    logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath());

                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // Log success of file copy
                        logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());

                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // Log success of JSON creation
                            logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());

                            // Step 3: QC Validation
                            boolean isValid = performQC(pdfFile, row);
                            if (isValid) {
                                // QC Passed, proceed to OnBase upload
                                boolean uploadedToOnBase = uploadToOnBase(pdfFile, row);
                                if (uploadedToOnBase) {
                                    logAction("OnBase Upload", "Success", "File uploaded to OnBase successfully.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                } else {
                                    logAction("OnBase Upload", "Failure", "Failed to upload file to OnBase.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                }
                            } else {
                                logAction("QC Validation", "Failure", "File failed QC validation.",
                                        pdfFile.getName(), pdfFile.getAbsolutePath());
                            }
                        } else {
                            logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());
                        }
                    } else {
                        logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());
                    }
                } else {
                    logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath);
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "An error occurred during file processing", e);
            throw new Exception("Error occurred while processing files", e);
        }
    }

    /**
     * QC Validation step to verify file quality and metadata.
     *
     * @param pdfFile the PDF file to validate
     * @param row the metadata associated with the file
     * @return true if the file passes QC, false otherwise
     */
    private boolean performQC(File pdfFile, ModelMain row) {
        // Implement your QC checks here (e.g., file format, metadata validity)
        // Example: checking if the PDF file is not empty and the metadata is non-empty
        boolean isFileValid = pdfFile.exists() && pdfFile.length() > 0;
        boolean isMetadataValid = row != null && row.getPlanNumber() != null && !row.getPlanNumber().isEmpty();

        if (!isFileValid) {
            LOGGER.log(Level.WARNING, "File failed QC check (empty or invalid file): " + pdfFile.getAbsolutePath());
        }
        if (!isMetadataValid) {
            LOGGER.log(Level.WARNING, "Metadata failed QC check (missing or invalid): " + row.getPlanNumber());
        }

        return isFileValid && isMetadataValid;
    }

    /**
     * Uploads the file and metadata to OnBase using its API.
     *
     * @param pdfFile the PDF file to upload
     * @param row the metadata to send to OnBase
     * @return true if the file and metadata were uploaded successfully, false otherwise
     */
    private boolean uploadToOnBase(File pdfFile, ModelMain row) {
        try {
            // Construct the payload (metadata + file path) for OnBase API
            OnBaseUploadRequest request = new OnBaseUploadRequest();
            request.setPlanNumber(row.getPlanNumber());
            request.setPlanName(row.getPlanName());
            request.setFilePath(pdfFile.getAbsolutePath());

            // Create RestTemplate to send data to OnBase API
            RestTemplate restTemplate = new RestTemplate();
            restTemplate.getInterceptors().add(new HttpRequestInterceptor(onbaseApiKey));

            // Send the POST request to OnBase API
            String url = onbaseApiUrl + "/upload";
            String response = restTemplate.postForObject(url, request, String.class);

            // Handle the response to check if the upload was successful
            return response != null && response.contains("success");
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error uploading to OnBase", e);
            return false;
        }
    }

    /**
     * Parse the Excel file to extract the metadata.
     *
     * @param inputStream InputStream for the Excel file
     * @return List of ModelMain objects representing rows of the Excel sheet
     * @throws Exception if an error occurs during parsing
     */
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume first sheet contains data

            for (int i = 1; i <= sheet.getLastRowNum(); i++) {  // Skipping header row (index 0)
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip if row is empty
                    continue;
                }

                String planName = getStringCellValue(row, 5); // Plan Name column (adjust index as needed)
                String planNumber = getStringCellValue(row, 4); // Plan Number column (adjust index as needed)

                ModelMain ecm = new ModelMain(planNumber, planName);
                excelRows.add(ecm);
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error while parsing Excel file", e);
            throw new Exception("Error while parsing the Excel file", e);
        }
        return excelRows;
    }

    /**
     * Fetches the value of a cell, safely handling nulls and blank cells.
     *
     * @param row the row containing the cell
     * @param columnIndex the index of the cell to fetch
     * @return the cell value as a String, or empty string if the cell is null
     */
    private String getStringCellValue(Row row, int columnIndex) {
        Cell cell = row.getCell(columnIndex);
        if (cell == null) {
            return "";
        }
        return cell.toString().trim();
    }

    /**
     * Logs actions for auditing purposes.
     *
     * @param action the action performed (e.g., "File Retrieval")
     * @param status the status of the action (e.g., "Success")
     * @param message a descriptive message about the action
     * @param fileName the name of the file associated with the action
     * @param filePath the full path of the file associated with the action
     */
    private void logAction(String action, String status, String message, String fileName, String filePath) {
        try {
            // Here we can use a custom audit logger that writes to a database or a file
            AuditTrailLogger.logAction(action, status, message, fileName, filePath, currentUser);
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Error logging action: " + action, e);
        }
    }

    /**
     * ModelMain represents the metadata of a plan including plan number and plan name.
     */
    public static class ModelMain {
        private String planNumber;
        private String planName;

        public ModelMain(String planNumber, String planName) {
            this.planNumber = planNumber;
            this.planName = planName;
        }

        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }
    }

    // Request model for uploading to OnBase API
    public static class OnBaseUploadRequest {
        private String planNumber;
        private String planName;
        private String filePath;

        // Getters and setters
        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }

        public String getFilePath() {
            return filePath;
        }

        public void setFilePath(String filePath) {
            this.filePath = filePath;
        }
    }

}






package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;
import java.util.logging.Level;
import java.util.logging.Logger;

@Service
public class Service1 {

    private static final Logger LOGGER = Logger.getLogger(Service1.class.getName());
    
    // Holds the count of files processed for each planNumber to handle versioning of files
    private final Map<String, Integer> fileCount = new HashMap<>();
    
    // Placeholder for user info, typically fetched dynamically from user session/context
    private String currentUser = "User123";
    
    @Value("${onbase.api.url}")  // Assuming the OnBase API URL is stored in application.properties or yml
    private String onbaseApiUrl;
    
    @Value("${onbase.api.key}")
    private String onbaseApiKey;

    /**
     * Main method that processes the files based on the given Excel data, copying them 
     * to a destination folder and creating corresponding JSON metadata files.
     *
     * @param excelFilePath path to the Excel file that contains metadata
     * @param sourceDirPath path where the source PDF files are located
     * @param destinationDirPath path where the PDF files should be copied, and JSON files should be created
     * @throws Exception if any error occurs during processing
     */
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // Log the success of file retrieval
                    logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath());

                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // Log success of file copy
                        logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());

                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // Log success of JSON creation
                            logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());

                            // Step 3: QC Validation
                            boolean isValid = performQC(pdfFile, row);
                            if (isValid) {
                                // QC Passed, proceed to OnBase upload
                                boolean uploadedToOnBase = uploadToOnBase(pdfFile, row);
                                if (uploadedToOnBase) {
                                    logAction("OnBase Upload", "Success", "File uploaded to OnBase successfully.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                } else {
                                    logAction("OnBase Upload", "Failure", "Failed to upload file to OnBase.",
                                            pdfFile.getName(), pdfFile.getAbsolutePath());
                                }
                            } else {
                                logAction("QC Validation", "Failure", "File failed QC validation.",
                                        pdfFile.getName(), pdfFile.getAbsolutePath());
                            }
                        } else {
                            logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath());
                        }
                    } else {
                        logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath());
                    }
                } else {
                    logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath);
                }
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "An error occurred during file processing", e);
            throw new Exception("Error occurred while processing files", e);
        }
    }

    /**
     * QC Validation step to verify file quality and metadata.
     *
     * @param pdfFile the PDF file to validate
     * @param row the metadata associated with the file
     * @return true if the file passes QC, false otherwise
     */
    private boolean performQC(File pdfFile, ModelMain row) {
        // Implement your QC checks here (e.g., file format, metadata validity)
        // Example: checking if the PDF file is not empty and the metadata is non-empty
        boolean isFileValid = pdfFile.exists() && pdfFile.length() > 0;
        boolean isMetadataValid = row != null && row.getPlanNumber() != null && !row.getPlanNumber().isEmpty();

        if (!isFileValid) {
            LOGGER.log(Level.WARNING, "File failed QC check (empty or invalid file): " + pdfFile.getAbsolutePath());
        }
        if (!isMetadataValid) {
            LOGGER.log(Level.WARNING, "Metadata failed QC check (missing or invalid): " + row.getPlanNumber());
        }

        return isFileValid && isMetadataValid;
    }

    /**
     * Uploads the file and metadata to OnBase using its API.
     *
     * @param pdfFile the PDF file to upload
     * @param row the metadata to send to OnBase
     * @return true if the file and metadata were uploaded successfully, false otherwise
     */
    private boolean uploadToOnBase(File pdfFile, ModelMain row) {
        try {
            // Construct the payload (metadata + file path) for OnBase API
            OnBaseUploadRequest request = new OnBaseUploadRequest();
            request.setPlanNumber(row.getPlanNumber());
            request.setPlanName(row.getPlanName());
            request.setFilePath(pdfFile.getAbsolutePath());

            // Create RestTemplate to send data to OnBase API
            RestTemplate restTemplate = new RestTemplate();
            restTemplate.getInterceptors().add(new HttpRequestInterceptor(onbaseApiKey));

            // Send the POST request to OnBase API
            String url = onbaseApiUrl + "/upload";
            String response = restTemplate.postForObject(url, request, String.class);

            // Handle the response to check if the upload was successful
            return response != null && response.contains("success");
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error uploading to OnBase", e);
            return false;
        }
    }

    /**
     * Parse the Excel file to extract the metadata.
     *
     * @param inputStream InputStream for the Excel file
     * @return List of ModelMain objects representing rows of the Excel sheet
     * @throws Exception if an error occurs during parsing
     */
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume first sheet contains data

            for (int i = 1; i <= sheet.getLastRowNum(); i++) {  // Skipping header row (index 0)
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip if row is empty
                    continue;
                }

                String planName = getStringCellValue(row, 5); // Plan Name column (adjust index as needed)
                String planNumber = getStringCellValue(row, 4); // Plan Number column (adjust index as needed)

                ModelMain ecm = new ModelMain(planNumber, planName);
                excelRows.add(ecm);
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, "Error while parsing Excel file", e);
            throw new Exception("Error while parsing the Excel file", e);
        }
        return excelRows;
    }

    /**
     * Fetches the value of a cell, safely handling nulls and blank cells.
     *
     * @param row the row containing the cell
     * @param columnIndex the index of the cell to fetch
     * @return the cell value as a String, or empty string if the cell is null
     */
    private String getStringCellValue(Row row, int columnIndex) {
        Cell cell = row.getCell(columnIndex);
        if (cell == null) {
            return "";
        }
        return cell.toString().trim();
    }

    /**
     * Logs actions for auditing purposes.
     *
     * @param action the action performed (e.g., "File Retrieval")
     * @param status the status of the action (e.g., "Success")
     * @param message a descriptive message about the action
     * @param fileName the name of the file associated with the action
     * @param filePath the full path of the file associated with the action
     */
    private void logAction(String action, String status, String message, String fileName, String filePath) {
        try {
            // Here we can use a custom audit logger that writes to a database or a file
            AuditTrailLogger.logAction(action, status, message, fileName, filePath, currentUser);
        } catch (Exception e) {
            LOGGER.log(Level.WARNING, "Error logging action: " + action, e);
        }
    }

    /**
     * ModelMain represents the metadata of a plan including plan number and plan name.
     */
    public static class ModelMain {
        private String planNumber;
        private String planName;

        public ModelMain(String planNumber, String planName) {
            this.planNumber = planNumber;
            this.planName = planName;
        }

        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }
    }

    // Request model for uploading to OnBase API
    public static class OnBaseUploadRequest {
        private String planNumber;
        private String planName;
        private String filePath;

        // Getters and setters
        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }

        public String getFilePath() {
            return filePath;
        }

        public void setFilePath(String filePath) {
            this.filePath = filePath;
        }
    }

}






import java.io.*;
import java.text.SimpleDateFormat;
import java.util.Date;

public class AuditTrailLogger {

    private static final String LOG_FILE_PATH = "C:\\ECM\\PVR\\audit-trail.log";

    // Method to log actions to the audit trail file, including who performed the action
    public static void logAction(String actionType, String status, String message, String fileName, String filePath, String user) {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(LOG_FILE_PATH, true))) {
            // Prepare log entry with timestamp, file details, and user
            String timestamp = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date());
            String logEntry = String.format("[%s] Action: %s, Status: %s, Message: %s, File: %s, File Path: %s, User: %s",
                    timestamp, actionType, status, message, fileName, filePath, user);
            // Write the log entry to the file
            writer.write(logEntry);
            writer.newLine(); // Add a new line after each log entry
        } catch (IOException e) {
            System.out.println("Error writing to audit trail: " + e.getMessage());
        }
    }
}




package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class Service1 {

    private HashMap<String, Integer> fileCount = new HashMap<>();
    private String currentUser = "User123"; // This could be fetched dynamically, e.g., from session.

    // Main method for processing the files and creating JSON files
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            // Read and parse the Excel file
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                // Get the file based on plan number from the Excel metadata
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // 1. Log file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Success", "File found for plan: " + row.getPlanNumber(),
                            pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                    // Copy the file to the destination directory
                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // 2. Log successful file copy
                        AuditTrailLogger.logAction("File Copy", "Success", "File copied successfully.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);

                        // 3. Create JSON for the copied file
                        boolean jsonCreated = createJsonForFile(pdfFile, row, destinationDirPath);
                        if (jsonCreated) {
                            // 4. Log successful JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Success", "JSON created successfully.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        } else {
                            // 4. Log failed JSON creation
                            AuditTrailLogger.logAction("JSON Creation", "Failure", "Failed to create JSON.",
                                    pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                        }
                    } else {
                        // Log failure in file copy
                        AuditTrailLogger.logAction("File Copy", "Failure", "Failed to copy file.",
                                pdfFile.getName(), pdfFile.getAbsolutePath(), currentUser);
                    }
                } else {
                    // Log failure in file retrieval
                    AuditTrailLogger.logAction("File Retrieval", "Failure", "File not found for plan: " + row.getPlanNumber(),
                            row.getPlanNumber(), sourceDirPath, currentUser);
                }
            }
        }
    }

    // Parse the Excel file and extract rows of metadata
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if it's empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();

                // Create a ModelMain object and add it to the list
                ModelMain ecm = new ModelMain(plan_number, plan_name);
                excelRows.add(ecm);
            }
        }
        return excelRows;
    }

    // Locate the file corresponding to a plan number
    public File getFile(String planNumber, String sourceDirPath) throws Exception {
        // Retrieve the current count for the plan number
        int count = fileCount.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically to match file names
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber, count);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the source directory path
        File directory = new File(sourceDirPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            fileCount.put(planNumber, count + 1);
            return matchingFiles[0];
        }
        return null;
    }

    // Copy the file to the destination directory
    public boolean copyFile(File file, String destinationDirPath) throws IOException {
        if (file == null || !file.exists()) {
            return false;
        }

        Path sourcePath = file.toPath();
        Path destinationPath = Paths.get(destinationDirPath, file.getName());

        // Create destination directory if it does not exist
        File destinationFolder = new File(destinationDirPath);
        if (!destinationFolder.exists()) {
            destinationFolder.mkdirs();
        }

        // Copy the file to the destination directory
        Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        return true;
    }

    // Create a JSON file for the given PDF file using its metadata
    private boolean createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // Build the metadata JSON (model object)
        String json = buildJsonFromMeta(metaData);

        // Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        return true;
    }

    // Convert the ModelMain metadata to JSON
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // Convert the ModelMain object into JSON
        return objectMapper.writeValueAsString(metaData);
    }

    // Simple ModelMain class with plan number and name
    public static class ModelMain {
        private String planNumber;
        private String planName;

        public ModelMain(String planNumber, String planName) {
            this.planNumber = planNumber;
            this.planName = planName;
        }

        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }
    }
}




package com.ecm1.ECM1;

import com.fasterxml.jackson.databind.ObjectMapper;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class Service1 {

    private HashMap<String, Integer> fileCount = new HashMap<>();

    // Main method for processing the files and creating JSON files
    public void processFilesAndCreateJson(String excelFilePath, String sourceDirPath, String destinationDirPath) throws Exception {
        try (InputStream inputStream = new FileInputStream(excelFilePath)) {
            // Read and parse the Excel file
            List<ModelMain> rows = parseExcelFile(inputStream);

            for (ModelMain row : rows) {
                // Get the file based on plan number from the Excel metadata
                File pdfFile = getFile(row.getPlanNumber(), sourceDirPath);
                if (pdfFile != null) {
                    // Copy the file to the destination directory
                    boolean fileCopied = copyFile(pdfFile, destinationDirPath);
                    if (fileCopied) {
                        // 2. Create JSON for the copied file
                        createJsonForFile(pdfFile, row, destinationDirPath);
                    }
                }
            }
        }
    }

    // Parse the Excel file and extract rows of metadata
    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            for (int i = 1; i <= sheet.getLastRowNum(); i++) {
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if it's empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();

                // Create a ModelMain object and add it to the list
                ModelMain ecm = new ModelMain(plan_number, plan_name);
                excelRows.add(ecm);
            }
        }
        return excelRows;
    }

    // Locate the file corresponding to a plan number
    public File getFile(String planNumber, String sourceDirPath) throws Exception {
        // Retrieve the current count for the plan number
        int count = fileCount.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically to match file names
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber, count);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the source directory path
        File directory = new File(sourceDirPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            fileCount.put(planNumber, count + 1);
            return matchingFiles[0];
        }
        return null;
    }

    // Copy the file to the destination directory
    public boolean copyFile(File file, String destinationDirPath) throws IOException {
        if (file == null || !file.exists()) {
            System.out.println("File does not exist or is invalid: " + file);
            return false;
        }

        Path sourcePath = file.toPath();
        Path destinationPath = Paths.get(destinationDirPath, file.getName());

        // Create destination directory if it does not exist
        File destinationFolder = new File(destinationDirPath);
        if (!destinationFolder.exists()) {
            destinationFolder.mkdirs();
        }

        // Copy the file to the destination directory
        Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
        System.out.println("File copied successfully: " + file.getName());
        return true;
    }

    // Create a JSON file for the given PDF file using its metadata
    private void createJsonForFile(File pdfFile, ModelMain metaData, String destinationDirPath) throws Exception {
        // 1. Build the metadata JSON (model object)
        String json = buildJsonFromMeta(metaData);

        // 2. Get the path for the new JSON file (with .json extension)
        Path jsonFilePath = Paths.get(destinationDirPath, pdfFile.getName().replace(".pdf", ".json"));

        // 3. Write the JSON to the file
        Files.write(jsonFilePath, json.getBytes());
        System.out.println("JSON file created: " + jsonFilePath.toString());
    }

    // Convert the ModelMain metadata to JSON
    private String buildJsonFromMeta(ModelMain metaData) throws Exception {
        // 1. Create an ObjectMapper (from Jackson) for JSON conversion
        ObjectMapper objectMapper = new ObjectMapper();

        // 2. Convert the ModelMain object into JSON
        return objectMapper.writeValueAsString(metaData);
    }

    // This is a simple ModelMain class with plan number and name
    public static class ModelMain {
        private String planNumber;
        private String planName;

        // Constructor
        public ModelMain(String planNumber, String planName) {
            this.planNumber = planNumber;
            this.planName = planName;
        }

        // Getters and setters
        public String getPlanNumber() {
            return planNumber;
        }

        public void setPlanNumber(String planNumber) {
            this.planNumber = planNumber;
        }

        public String getPlanName() {
            return planName;
        }

        public void setPlanName(String planName) {
            this.planName = planName;
        }
    }

    // This method is a placeholder for uploading the files to OnBase (this will depend on the OnBase API)
    public void uploadFileToOnBase(Path filePath) throws Exception {
        // Here, you can add the logic for uploading to OnBase. This depends on how OnBase integration is set up.
        System.out.println("Uploading file to OnBase: " + filePath.toString());
    }
}




package com.ecm1.ECM1;

import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Service;

import java.io.*;
import java.nio.file.*;
import java.util.*;
import java.util.regex.Pattern;


@Service
public class Service1 {
    private HashMap<String, Integer> fileCount = new HashMap<>();

    void processFile(String filePath) throws Exception {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            // get the list of rows
            List<ModelMain> rows = parseExcelFile(inputStream);
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Error processing file: " + e.getMessage());
        }
    }

    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            for (int i = 1; i <= sheet.getLastRowNum() ; i++) {
                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if its empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();
                // Get the associated file
                File file = getFile(plan_number);
                if(file != null){
                    if(isMoved(file)){
                        System.out.println("filed moved :"+file.getName());
                    }else{
                        System.out.println("not moved "+file.getName());
                    }
                }else{
                    System.out.println("file is null");
                }

                // Create an ModelMain object and add it to the list with file content
                ModelMain ecm = new ModelMain(plan_number, plan_name);
                excelRows.add(ecm);
            }
            return excelRows;
        }
    }

    public File getFile(String planNumber) throws Exception {
        // Retrieve the current count for the plan number
        int count = fileCount.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber, count);

        // Print the regex for debugging
        System.out.println("Regex: " + regex);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the directory path
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File directory = new File(directoryPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            fileCount.put(planNumber, count + 1);
//            System.out.println("Found file name: " + matchingFiles[0].getName())
            return matchingFiles[0];
        }
        // if file not found
        System.out.println("file not found");
        return null;
    }

    public boolean isMoved(File file) {
        if (file == null || !file.exists()) {
            System.out.println("File does not exist or is invalid: " + file);
            return false; // If the file is invalid or doesn't exist
        }

        try {
            // Define source and destination directories
            String sourceDir = "C:\\ECM\\PVR\\All_20231218_1552MST\\";  // Source directory
            String destinationDir = "C:\\ECM\\PVR\\processed files\\";  // Destination directory

            // Create Path objects for the source file and destination file
            Path sourcePath = file.toPath();
            Path destinationPath = Paths.get(destinationDir, file.getName());

            // Create destination directory if it does not exist
            File destinationFolder = new File(destinationDir);
            if (!destinationFolder.exists()) {
                destinationFolder.mkdirs();  // Create directories if needed
            }

            // Move the file from the source to the destination
            Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File moved successfully: " + file.getName());
            return true;
        } catch (IOException e) {
            System.out.println("Error moving file: " + e.getMessage());
            return false;
        }
    }
    }



• Select a directory
		○ Contains Excel spreadsheet - select this
		○ Contains All… directory containing docs - select this
	• Read excel spreadsheet 
		○ Use PlanNumber and count to select file
		○ For example, 1st PlanNumber is 591121-01 and 1st plan occurrence
			§ File name is 591121-01_PRU_1_6_20231218_1553MST.pdf
			§                       ' PlanNum  '       'Cnt'
		○ For prototype
		○ 1st step
			i. Build a GUI
			ii. Locate and select parent directory, excel ss, and All… directory
			iii. Read excel ss and process plans row by row
			iv. For each row, process while plan number is the same, increment participant counter, select appropriate file
			v. Copy file to a Temp directory
		○ 2nd step 
			§ For each file, extract meta-data for OnBase from excel ss
			§ Build the JSON for meta-data
			§ Write this JSON to the Temp directory with the file  using the file name and file type of .json
			§ Create an audit trail file noting success and failure
		○ 3rd step
			§ QC and ensure we have correct file and json
Write file and json to OnBase





    public boolean isMoved(File file) {
        if (file == null || !file.exists()) {
            System.out.println("File does not exist or is invalid: " + file);
            return false; // If the file is invalid or doesn't exist
        }

        try {
            // Define source and destination directories
            String sourceDir = "C:\\ECM\\PVR\\sourceFiles";  // Source directory
            String destinationDir = "C:\\ECM\\PVR\\processed files";  // Destination directory

            // Create Path objects for the source file and destination file
            Path sourcePath = file.toPath();
            Path destinationPath = Paths.get(destinationDir, file.getName());

            // Create destination directory if it does not exist
            File destinationFolder = new File(destinationDir);
            if (!destinationFolder.exists()) {
                destinationFolder.mkdirs();  // Create directories if needed
            }

            // Move the file from the source to the destination
            Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File moved successfully: " + file.getName());
            return true;
        } catch (IOException e) {
            System.out.println("Error moving file: " + e.getMessage());
            return false;
        }
    }




import java.io.File;
import java.io.IOException;
import java.nio.file.*;

public class FileMover {

    public boolean isMoved(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return false; // If the file name is invalid, return false
        }

        try {
            // Define source and destination directories
            String sourceDir = "C:\\ECM\\PVR\\sourceFiles";  // Source directory
            String destinationDir = "C:\\ECM\\PVR\\processed files";  // Destination directory

            // Create Path objects for the source file and destination file
            Path sourcePath = Paths.get(sourceDir, fileName);
            Path destinationPath = Paths.get(destinationDir, fileName);

            // Check if the source file exists
            File sourceFile = sourcePath.toFile();
            if (!sourceFile.exists()) {
                System.out.println("File not found: " + fileName);
                return false;
            }

            // Create destination directory if it does not exist
            File destinationFolder = new File(destinationDir);
            if (!destinationFolder.exists()) {
                destinationFolder.mkdirs();  // Create directories if needed
            }

            // Move the file from the source to the destination
            Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File moved successfully: " + fileName);
            return true;
        } catch (IOException e) {
            System.out.println("Error moving file: " + e.getMessage());
            return false;
        }
    }

    public static void main(String[] args) {
        FileMover fileMover = new FileMover();
        String fileName = "example.txt"; // Example file name to be moved
        boolean result = fileMover.isMoved(fileName);
        System.out.println("File move result: " + result);
    }
}




import java.io.File;
import java.io.IOException;
import java.nio.file.*;

public class FileMover {

    public boolean isMoved(String fileName) {
        if (fileName == null || fileName.isEmpty()) {
            return false; // If the file name is invalid, return false
        }

        try {
            // Define source and destination directories
            String sourceDir = "C:\\ECM\\PVR\\sourceFiles";  // Source directory
            String destinationDir = "C:\\ECM\\PVR\\processed files";  // Destination directory

            // Create Path objects for the source file and destination file
            Path sourcePath = Paths.get(sourceDir, fileName);
            Path destinationPath = Paths.get(destinationDir, fileName);

            // Check if the source file exists
            File sourceFile = sourcePath.toFile();
            if (!sourceFile.exists()) {
                System.out.println("File not found: " + fileName);
                return false;
            }

            // Create destination directory if it does not exist
            File destinationFolder = new File(destinationDir);
            if (!destinationFolder.exists()) {
                destinationFolder.mkdirs();  // Create directories if needed
            }

            // Move the file from the source to the destination
            Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("File moved successfully: " + fileName);
            return true;
        } catch (IOException e) {
            System.out.println("Error moving file: " + e.getMessage());
            return false;
        }
    }

    public static void main(String[] args) {
        FileMover fileMover = new FileMover();
        String fileName = "example.txt"; // Example file name to be moved
        boolean result = fileMover.isMoved(fileName);
        System.out.println("File move result: " + result);
    }
}




public boolean isMoved(String fileName){
        if(fileName == "") return false;
        try{
            String folder = "C:\\ECM\\PVR\\processed files";
            return true;
        }catch(Exception e){
            System.out.println(" error in proc");
            return false;
        }
                
    }


package com.ecm1.ECM1;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import jakarta.annotation.PostConstruct;

import javax.swing.*;
import java.io.File;

@SpringBootApplication
public class Ecm1Application {

	@Autowired
	private ECMcontroller ecmController;
	private static File PARENT_PATH = null;
	private static File EXCEL_PATH = null;
	private static File ALL_FOLDER_PATH = null;

	public static void main(String[] args) {
		SpringApplication.run(Ecm1Application.class, args);
		System.out.println("ECM Application is running!");
	}

	@PostConstruct
	public void run() {

		PARENT_PATH = selectDirectory("Select parent directory");
		System.out.println(PARENT_PATH);
//		String filePath = "C:\\ECM\\PVR\\REPORT_2362_01DEC2023.xlsx";
//		String result = ecmController.handleFileFromPath(filePath);
//		System.out.println(result);
	}

	// Show a directory chooser dialog
	private static File selectDirectory(String dialogTitle) {
		JFileChooser fileChooser = new JFileChooser();
		fileChooser.setDialogTitle(dialogTitle);
		fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

		int result = fileChooser.showOpenDialog(null);
		if (result == JFileChooser.APPROVE_OPTION) {
			return fileChooser.getSelectedFile();
		}
		return null;
	}
}

Error starting ApplicationContext. To display the condition evaluation report re-run your application with 'debug' enabled.
2025-01-08T04:21:14.255-07:00 ERROR 12104 --- [ECM1] [           main] o.s.boot.SpringApplication               : Application run failed

org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'ecm1Application': Invocation of init method failed
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:222) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975) ~[spring-beans-6.1.13.jar:6.1.13]
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971) ~[spring-context-6.1.13.jar:6.1.13]
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625) ~[spring-context-6.1.13.jar:6.1.13]
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363) ~[spring-boot-3.3.4.jar:3.3.4]
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352) ~[spring-boot-3.3.4.jar:3.3.4]
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:21) ~[classes/:na]
Caused by: java.awt.HeadlessException: null
	at java.desktop/java.awt.GraphicsEnvironment.checkHeadless(GraphicsEnvironment.java:166) ~[na:na]
	at java.desktop/java.awt.Window.<init>(Window.java:553) ~[na:na]
	at java.desktop/java.awt.Frame.<init>(Frame.java:428) ~[na:na]
	at java.desktop/java.awt.Frame.<init>(Frame.java:393) ~[na:na]
	at java.desktop/javax.swing.SwingUtilities$SharedOwnerFrame.<init>(SwingUtilities.java:1925) ~[na:na]
	at java.desktop/javax.swing.SwingUtilities.getSharedOwnerFrame(SwingUtilities.java:2001) ~[na:na]
	at java.desktop/javax.swing.JOptionPane.getRootFrame(JOptionPane.java:1696) ~[na:na]
	at java.desktop/javax.swing.JOptionPane.getWindowForComponent(JOptionPane.java:1637) ~[na:na]
	at java.desktop/javax.swing.JFileChooser.createDialog(JFileChooser.java:815) ~[na:na]
	at java.desktop/javax.swing.JFileChooser.showDialog(JFileChooser.java:762) ~[na:na]
	at java.desktop/javax.swing.JFileChooser.showOpenDialog(JFileChooser.java:668) ~[na:na]
	at com.ecm1.ECM1.Ecm1Application.selectDirectory(Ecm1Application.java:41) ~[classes/:na]
	at com.e




import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import javax.swing.*;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.nio.file.*;
import java.util.*;
import java.util.stream.Collectors;

public class PlanProcessorWithGUI {

    public static void main(String[] args) {
        try {
            // Let user select directories using GUI
            File parentDir = selectDirectory("Select Parent Directory");
            File excelFile = selectFile("Select Excel File");
            File allDocsDir = selectDirectory("Select AllDocs Directory");

            if (parentDir == null || excelFile == null || allDocsDir == null) {
                System.out.println("Operation canceled or invalid selection.");
                return;
            }

            // Process Excel and documents
            Map<String, Integer> planCounts = processExcelAndDocs(excelFile.getPath(), parentDir.getPath(), allDocsDir.getPath());
            planCounts.forEach((planNum, count) ->
                System.out.println("Plan Number: " + planNum + ", Count: " + count));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // Show a directory chooser dialog
    private static File selectDirectory(String dialogTitle) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle(dialogTitle);
        fileChooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);

        int result = fileChooser.showOpenDialog(null);
        if (result == JFileChooser.APPROVE_OPTION) {
            return fileChooser.getSelectedFile();
        }
        return null;
    }

    // Show a file chooser dialog for selecting Excel files
    private static File selectFile(String dialogTitle) {
        JFileChooser fileChooser = new JFileChooser();
        fileChooser.setDialogTitle(dialogTitle);
        fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY);

        // Add a filter for Excel files
        fileChooser.setFileFilter(new javax.swing.filechooser.FileFilter() {
            @Override
            public boolean accept(File file) {
                return file.isDirectory() || file.getName().toLowerCase().endsWith(".xlsx");
            }

            @Override
            public String getDescription() {
                return "Excel Files (*.xlsx)";
            }
        });

        int result = fileChooser.showOpenDialog(null);
        if (result == JFileChooser.APPROVE_OPTION) {
            return fileChooser.getSelectedFile();
        }
        return null;
    }

    public static Map<String, Integer> processExcelAndDocs(String excelFilePath, String parentDirPath, String allDocsDirPath) throws IOException {
        // Read Excel and extract Plan Numbers
        List<String> planNumbers = readExcel(excelFilePath);

        // Locate all files in AllDocs directory
        List<File> allDocs = Files.walk(Paths.get(allDocsDirPath))
                .filter(Files::isRegularFile)
                .map(Path::toFile)
                .collect(Collectors.toList());

        // Process each plan number and count matching files
        Map<String, Integer> planCounts = new HashMap<>();
        for (String planNum : planNumbers) {
            int count = (int) allDocs.stream()
                    .filter(file -> file.getName().contains(planNum))
                    .count();
            planCounts.put(planNum, count);
        }

        return planCounts;
    }

    public static List<String> readExcel(String filePath) throws IOException {
        List<String> planNumbers = new ArrayList<>();
        try (FileInputStream fis = new FileInputStream(new File(filePath));
             Workbook workbook = new XSSFWorkbook(fis)) {

            Sheet sheet = workbook.getSheetAt(0); // Assuming data is in the first sheet
            for (Row row : sheet) {
                Cell cell = row.getCell(0); // Assuming PlanNum is in the first column
                if (cell != null) {
                    planNumbers.add(cell.getStringCellValue().trim());
                }
            }
        }
        return planNumbers;
    }
}









package com.ecm1.ECM1;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class ECMservice {
    private final String runType = "PROD";
    HashMap<String, Integer> user = new HashMap<>();

    public void processFile(String filePath) throws Exception {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            // get the list of rows
            List<ModelMain> rows = parseExcelFile(inputStream);
            //post each row excel dat and corresponding file into onbase
            postApi(rows);
            for (ModelMain cell : rows) {
                System.out.println(cell);
            };
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Error processing file: " + e.getMessage());
        }
    }

    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            // only parsing 4 rows in excel (testing)
            int i = 1;
            int maxRows = 4;
            while (i <= maxRows) {

                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if its empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();
//
//                // Get the associated file
                File file = getFile(plan_number);

                // Create an ModelMain object and add it to the list with file content
                ModelMain ecm = new ModelMain(plan_number, plan_name);
                excelRows.add(ecm);
                i++;
            }
            return excelRows;
        }

    }

    public File getFile(String planNumber) throws Exception {
        // Retrieve the current count for the plan number
        int count = user.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber,count);

        // Print the regex for debugging
        System.out.println("Regex: " + regex);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the directory path
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File directory = new File(directoryPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            user.put(planNumber, count + 1);
            System.out.println("Found file name: " + matchingFiles[0].getName());
            return matchingFiles[0];
        }
        // if file not found
        return null;

    }

    public void postApi(List<ModelMain> rows) throws Exception {
        for (ModelMain cell : rows) {
            sendPostScanSheets(cell);
        }
    }

    boolean status;

    public boolean sendPostScanSheets(ModelMain currCell) throws Exception {
        status = true;

        String authorizationID = getAuthorizationID();

        String url = "";
        if (runType.equals(("PROD"))) {
            url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
        } else if (runType.equals(("DEV"))) {
            url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
        }

        // Get the file associated with the plan number
        File file = getFile(currCell.getPlanNumber());
        if (file == null || !file.exists()) {
            throw new Exception("File not found for plan number: " + currCell.getPlanNumber());
        }

        // Read file content into a byte array
        byte[] fileContent = Files.readAllBytes(file.toPath());

        // Prepare document metadata
        String docuData = buildJsonFromModelMain(currCell);

        // Use ByteArrayResource for file content
        ByteArrayResource resource = new ByteArrayResource(fileContent) {
            @Override
            public String getFilename() {
                return file.getName(); // Set the file name
            }
        };

        // Set up the request body
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", resource); // Add PDF file content
        body.add("typeOfDocument", "plan");
        body.add("mimeType", "application/pdf");
        body.add("documentProperties", docuData); // Add metadata as JSON

        // Set up headers
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
        headers.add("Authorization", "JWT " + authorizationID);

        // Create the HTTP entity
        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        // Use RestTemplate to make the POST request
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

        // Print response details
        System.out.println("Response status: " + response.getStatusCode());
        System.out.println("Response body: " + response.getBody());

        return response.getStatusCode().is2xxSuccessful();
    }

    public String buildJsonFromModelMain(ModelMain modelMain) {
        String planName = modelMain.getPlanName();
        String planNumber = modelMain.getPlanNumber();

        // Build JSON as a String
        String json = "{\n" +
                "    \"plan\": {\n" +
                "        \"name\": \"" + planName + "\",\n" +
                "        \"number\": \"" + planNumber + "\"\n" +
                "       \"category\": \"" + "MassMutual" + "\"\n" +
                "    }\n" +
                "}";

        return json;
    }

    /*
     * Get authorization ID for DocuSign POST
     */
    private String getAuthorizationID() {

        String authorizationID = "";

        try {

            /*
             * Set up POST request for authorization key
             */
            URL authorizationUrl = null;
            if (runType.equals("PROD")) {
                authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
            } else if (runType.equals("DEV")) {
                authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
            }

            /*
             * Define JSON object
             */
            String authorizationJSON = "{\n";
            if (runType.equals("PROD")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
            } else if (runType.equals("DEV")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
            }
            authorizationJSON = authorizationJSON + "}\n";

            /*
             * Open connection
             */
            HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

            /*
             * Setup connection properties
             */
            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");

            /*
             * Write POST request
             */
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = authorizationJSON.getBytes("utf-8");
                os.write(input, 0, input.length);
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
             * Get response status
             */
            int status = connection.getResponseCode();

            /*
             * Should be 204, no content returned But we will get the authorization key
             * returned in a header record
             */
            if (status == HttpURLConnection.HTTP_NO_CONTENT) {
                authorizationID = connection.getHeaderField("Authorization");
                System.out.println(authorizationID);
            }
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return authorizationID;
    }


    public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
        // Retrieve the file based on the provided filename
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File file = new File(directoryPath, filename); // Assuming the filename is the full path or relative path to the file

        // Check if the file exists
        if (!file.exists()) {
//            System.out.println("name is "+filename);
            System.out.println(" found");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        try {
            // Read the file content into a byte array
            byte[] fileContent = Files.readAllBytes(file.toPath());

            // Check if the file content is empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // Set the dynamic filename for the response header
            String dynamicFilename = filename; // You can modify this to extract just the file name if needed
//            System.out.println("helo");
            // Return the file content as a response with the proper headers
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                    .body(fileContent);

        } catch (IOException e) {
            // Handle the exception and return an error response
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

}




egex: 591121-01_PRU_1_\d_\d{8}_\d{4}MST\.pdf
Found file name: 591121-01_PRU_1_6_20231218_1553MST.pdf
Regex: 591121-01_PRU_2_\d_\d{8}_\d{4}MST\.pdf
Found file name: 591121-01_PRU_2_6_20231218_1553MST.pdf
Regex: 591121-01_PRU_3_\d_\d{8}_\d{4}MST\.pdf
Found file name: 591121-01_PRU_3_6_20231218_1553MST.pdf
Regex: 591139-01_PRU_1_\d_\d{8}_\d{4}MST\.pdf
Found file name: 591139-01_PRU_1_6_20231218_1552MST.pdf
java.net.ConnectException: Connection timed out: connect
	at java.base/sun.nio.ch.Net.connect0(Native Method)
	at java.base/sun.nio.ch.Net.connect(Net.java:589)
	at java.base/sun.nio.ch.Net.connect(Net.java:578)
	at java.base/sun.nio.ch.NioSocketImpl.connect(NioSocketImpl.java:583)
	at java.base/java.net.SocksSocketImpl.connect(SocksSocketImpl.java:327)
	at java.base/java.net.Socket.connect(Socket.java:751)
	at java.base/sun.security.ssl.SSLSocketImpl.connect(SSLSocketImpl.java:304)
	at java.base/sun.security.ssl.BaseSSLSocketImpl.connect(BaseSSLSocketImpl.java:181)
	at java.base/sun.net.NetworkClient.doConnect(NetworkClient.java:183)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:531)
	at java.base/sun.net.www.http.HttpClient.openServer(HttpClient.java:636)
	at java.base/sun.net.www.protocol.https.HttpsClient.<init>(HttpsClient.java:264)
	at java.base/sun.net.www.protocol.https.HttpsClient.New(HttpsClient.java:377)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.getNewHttpClient(AbstractDelegateHttpsURLConnection.java:193)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect0(HttpURLConnection.java:1237)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.plainConnect(HttpURLConnection.java:1123)
	at java.base/sun.net.www.protocol.https.AbstractDelegateHttpsURLConnection.connect(AbstractDelegateHttpsURLConnection.java:179)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream0(HttpURLConnection.java:1446)
	at java.base/sun.net.www.protocol.http.HttpURLConnection.getOutputStream(HttpURLConnection.java:1417)
	at java.ba


https://teams.microsoft.com/l/meetup-join/19%3ameeting_MjYyZWE0MWMtZTE4My00MWQ5LTk0ZTktNzc1ODliNGExZTY1%40thread.v2/0?context=%7b%22Tid%22%3a%22d344fc8a-8286-4945-9a21-49aed506d485%22%2c%22Oid%22%3a%22aeb1f80b-21fd-462f-86c6-40255d6bd1b9%22%7d


https://teams.microsoft.com/l/meetup-join/19%3ameeting_NmYyNmE1NmYtYTdkNy00YWY5LWJmNzEtNmZlZTUwMjcxZjQ4%40thread.v2/0?context=%7b%22Tid%22%3a%22d344fc8a-8286-4945-9a21-49aed506d485%22%2c%22Oid%22%3a%22aeb1f80b-21fd-462f-86c6-40255d6bd1b9%22%7d

akarta.mail.NoSuchProviderException: imap
	at jakarta.mail.Session.getService(Session.java:842)
	at jakarta.mail.Session.getStore(Session.java:626)
	at jakarta.mail.Session.getStore(Session.java:589)
	at jakarta.mail.Session.getStore(Session.java:568)
	at com.empower.email.BounceBackMonitor.monitorBounceBacks(BounceBackMonitor.java:39)
	at com.empower.email.EmailApplication.lambda$main$0(EmailApplication.java:24)
	at java.base/java.lang.Thread.run(Thread.java:1583)



fetch('http://localhost:8080/mail', {
  method: 'POST',  // HTTP method
  headers: {
    'Content-Type': 'application/json',  // Tell the server the data is in JSON format
  },
  body: JSON.stringify({
    to: 'recipient@example.com',  // The recipient's email address
    subject: 'Test Email',  // The subject of the email
    body: 'This is the body of the email.'  // The body content of the email
  })
})
.then(response => response.json())  // Parse the response to JSON
.then(data => {
  console.log('Email sent successfully:', data);  // Log success response
})
.catch(error => {
  console.error('Error sending email:', error);  // Log any error that occurs
});




https://teams.microsoft.com/l/meetup-join/19%3ameeting_NTY3YzVjOTYtOTFmMS00Mjc5LWJmNjgtMjk4NmI5ZjUyYWFi%40thread.v2/0?context=%7b%22Tid%22%3a%22d344fc8a-8286-4945-9a21-49aed506d485%22%2c%22Oid%22%3a%22aeb1f80b-21fd-462f-86c6-40255d6bd1b9%22%7d



package com.empower.email;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.RestController;

import javax.mail.*;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import java.util.Properties;
@RestController
public class Helper {

    public void sendEmail() {
        String senderEmail = "chenna.kesavareddy@empower.com";
        String recipientEmail = "puthaesavareddy@gmail.com"; // Intentional typo for testing bounces
        String bounceHandlerEmail = "chenna.kesavareddy@empower.com"; // Email to handle bounces
        String smtpHost = "smtp.east.ssp.aws.gwl.com";

        Properties props = new Properties();
        props.put("mail.smtp.host", smtpHost);
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.port", "25");
        props.put("mail.smtp.debug", "true");

        Session session = Session.getDefaultInstance(props, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("chknsv", "Pandu@12"); // Credentials for SMTP
            }
        });
//        Session session = Session.getDefaultInstance(props);

        try {
            MimeMessage message = new MimeMessage(session);
            message.setFrom(new InternetAddress(senderEmail));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipientEmail));
            message.setSubject("Test Email with Bounce Handling");
            message.setText("This is a test email to check bounce handling.");
            message.setReplyTo(new Address[]{new InternetAddress(bounceHandlerEmail)}); // Bounce reply-to address

            Transport.send(message);
            System.out.println("Email sent successfully!");
        } catch (MessagingException e) {
            System.err.println("Error sending email: " + e.getMessage());
            e.printStackTrace();
        }

        // Check for bounce emails after sending
//        checkBounceEmails(bounceHandlerEmail, "Pandu@12"); // Pass bounce email credentials
    }

    public void checkBounceEmails(String bounceMail, String password) {
        String imapHost = "imap.empower.com"; // Update with your IMAP host
        int imapPort = 993;

        Properties props = new Properties();
        props.put("mail.store.protocol", "imaps");
        props.put("mail.imap.host", imapHost);
        props.put("mail.imap.port", String.valueOf(imapPort));
        props.put("mail.imap.ssl.enable", "true");
        props.put("mail.debug", "true"); // Enable debug logs

        try {
            // Connect to IMAP server
            Session session = Session.getInstance(props);
            Store store = session.getStore("imaps");
            store.connect(imapHost, bounceMail, password);

            // Open inbox
            Folder inbox = store.getFolder("INBOX");
            inbox.open(Folder.READ_ONLY);

            System.out.println("Connected to the inbox. Checking for bounce emails...");
            Message[] messages = inbox.getMessages();

            for (Message message : messages) {
                if (message.getSubject().contains("Undelivered Mail") || message.getSubject().contains("Failure")) {
                    System.out.println("\nBounce Email Detected:");
                    System.out.println("From: " + message.getFrom()[0]);
                    System.out.println("Subject: " + message.getSubject());

                    // Handle message content
                    if (message.isMimeType("text/plain")) {
                        System.out.println("Content: " + message.getContent());
                    } else if (message.isMimeType("multipart/*")) {
                        Multipart multipart = (Multipart) message.getContent();
                        for (int i = 0; i < multipart.getCount(); i++) {
                            BodyPart bodyPart = multipart.getBodyPart(i);
                            System.out.println("Part Content: " + bodyPart.getContent());
                        }
                    }
                }
            }

            inbox.close(false);
            store.close();
        } catch (Exception e) {
            System.err.println("Error checking bounce emails: " + e.getMessage());
            e.printStackTrace();
        }
    }
}






import javax.mail.*;
import javax.mail.internet.*;
import java.util.Properties;

public class SimpleEmail {

    public static void sendEmail(String recipient, String subject, String body) {
        // Sender's email ID and password
        String senderEmail = "your-email@gmail.com"; // Your email address
        String senderPassword = "your-email-password"; // Your email password or app password

        // SMTP server configuration
        String smtpHost = "smtp.gmail.com";  // For Gmail SMTP
        int smtpPort = 587; // For Gmail's TLS

        // Set the properties for the session
        Properties properties = new Properties();
        properties.put("mail.smtp.host", smtpHost);
        properties.put("mail.smtp.port", smtpPort);
        properties.put("mail.smtp.auth", "true");
        properties.put("mail.smtp.starttls.enable", "true");  // Enables STARTTLS for encryption

        // Get the Session object
        Session session = Session.getInstance(properties, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication(senderEmail, senderPassword);
            }
        });

        try {
            // Create the email message
            MimeMessage message = new MimeMessage(session);
            message.setFrom(new InternetAddress(senderEmail));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipient));
            message.setSubject(subject);
            message.setText(body);

            // Send the email
            Transport.send(message);
            System.out.println("Email sent successfully.");
        } catch (MessagingException e) {
            e.printStackTrace();
            System.out.println("Error while sending email.");
        }
    }

    public static void main(String[] args) {
        String recipient = "recipient-email@example.com"; // Recipient's email
        String subject = "Test Email from Java";
        String body = "Hello, this is a test email sent from Java using SMTP.";
        sendEmail(recipient, subject, body);
    }
}





EBUG: JavaMail version 1.4.7
DEBUG: successfully loaded resource: /META-INF/javamail.default.providers
DEBUG: Tables of loaded providers
DEBUG: Providers Listed By Class Name: {com.sun.mail.smtp.SMTPSSLTransport=javax.mail.Provider[TRANSPORT,smtps,com.sun.mail.smtp.SMTPSSLTransport,Oracle], com.sun.mail.smtp.SMTPTransport=javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle], com.sun.mail.imap.IMAPSSLStore=javax.mail.Provider[STORE,imaps,com.sun.mail.imap.IMAPSSLStore,Oracle], com.sun.mail.pop3.POP3SSLStore=javax.mail.Provider[STORE,pop3s,com.sun.mail.pop3.POP3SSLStore,Oracle], com.sun.mail.imap.IMAPStore=javax.mail.Provider[STORE,imap,com.sun.mail.imap.IMAPStore,Oracle], com.sun.mail.pop3.POP3Store=javax.mail.Provider[STORE,pop3,com.sun.mail.pop3.POP3Store,Oracle]}
DEBUG: Providers Listed By Protocol: {imaps=javax.mail.Provider[STORE,imaps,com.sun.mail.imap.IMAPSSLStore,Oracle], imap=javax.mail.Provider[STORE,imap,com.sun.mail.imap.IMAPStore,Oracle], smtps=javax.mail.Provider[TRANSPORT,smtps,com.sun.mail.smtp.SMTPSSLTransport,Oracle], pop3=javax.mail.Provider[STORE,pop3,com.sun.mail.pop3.POP3Store,Oracle], pop3s=javax.mail.Provider[STORE,pop3s,com.sun.mail.pop3.POP3SSLStore,Oracle], smtp=javax.mail.Provider[TRANSPORT,smtp,com.sun.mail.smtp.SMTPTransport,Oracle]}
DEBUG: successfully loaded resource: /META-INF/javamail.default.address.map
DEBUG: getProvider() returning javax.mail.Provider[STORE,imaps,com.sun.mail.imap.IMAPSSLStore,Oracle]
DEBUG IMAPS: mail.imap.fetchsize: 16384
DEBUG IMAPS: mail.imap.ignorebodystructuresize: false
DEBUG IMAPS: mail.imap.statuscachetimeout: 1000
DEBUG IMAPS: mail.imap.appendbuffersize: -1
DEBUG IMAPS: mail.imap.minidletime: 10
DEBUG IMAPS: trying to connect to host "imap.empower.com", port 993, isSSL true





package com.empower.email;

import javax.mail.*;
import javax.mail.internet.*;
import java.util.Properties;

public class EmailHandler {

    public void sendEmail() {
        String senderEmail = "chenna.kesavareddy@empower.com";
        String recipientEmail = "ch--ennakeava13579gmail.com"; // Intentional typo for testing bounces
        String bounceHandlerEmail = "chenna.kesavareddy@empower.com"; // Email to handle bounces
        String smtpHost = "smtp.east.ssp.aws.gwl.com";

        Properties props = new Properties();
        props.put("mail.smtp.host", smtpHost);
        props.put("mail.smtp.auth", "true");
        props.put("mail.smtp.port", "25");

        Session session = Session.getDefaultInstance(props, new Authenticator() {
            protected PasswordAuthentication getPasswordAuthentication() {
                return new PasswordAuthentication("chknsv", "Pandu@12"); // Credentials for SMTP
            }
        });

        try {
            MimeMessage message = new MimeMessage(session);
            message.setFrom(new InternetAddress(senderEmail));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(recipientEmail));
            message.setSubject("Test Email with Bounce Handling");
            message.setText("This is a test email to check bounce handling.");
            message.setReplyTo(new Address[]{new InternetAddress(bounceHandlerEmail)}); // Bounce reply-to address

            Transport.send(message);
            System.out.println("Email sent successfully!");
        } catch (MessagingException e) {
            System.err.println("Error sending email: " + e.getMessage());
            e.printStackTrace();
        }

        // Check for bounce emails after sending
        checkBounceEmails(bounceHandlerEmail, "Pandu@12"); // Pass bounce email credentials
    }

    public void checkBounceEmails(String bounceMail, String password) {
        String imapHost = "imap.empower.com"; // Update with your IMAP host
        int imapPort = 993;

        Properties props = new Properties();
        props.put("mail.store.protocol", "imaps");
        props.put("mail.imap.host", imapHost);
        props.put("mail.imap.port", String.valueOf(imapPort));
        props.put("mail.imap.ssl.enable", "true");
        props.put("mail.debug", "true"); // Enable debug logs

        try {
            // Connect to IMAP server
            Session session = Session.getInstance(props);
            Store store = session.getStore("imaps");
            store.connect(imapHost, bounceMail, password);

            // Open inbox
            Folder inbox = store.getFolder("INBOX");
            inbox.open(Folder.READ_ONLY);

            System.out.println("Connected to the inbox. Checking for bounce emails...");
            Message[] messages = inbox.getMessages();

            for (Message message : messages) {
                if (message.getSubject().contains("Undelivered Mail") || message.getSubject().contains("Failure")) {
                    System.out.println("\nBounce Email Detected:");
                    System.out.println("From: " + message.getFrom()[0]);
                    System.out.println("Subject: " + message.getSubject());

                    // Handle message content
                    if (message.isMimeType("text/plain")) {
                        System.out.println("Content: " + message.getContent());
                    } else if (message.isMimeType("multipart/*")) {
                        Multipart multipart = (Multipart) message.getContent();
                        for (int i = 0; i < multipart.getCount(); i++) {
                            BodyPart bodyPart = multipart.getBodyPart(i);
                            System.out.println("Part Content: " + bodyPart.getContent());
                        }
                    }
                }
            }

            inbox.close(false);
            store.close();
        } catch (Exception e) {
            System.err.println("Error checking bounce emails: " + e.getMessage());
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        EmailHandler handler = new EmailHandler();
        handler.sendEmail();
    }
}










package com.empower.email;
import org.springframework.stereotype.Service;
import org.springframework.web.bind.annotation.RestController;

import javax.mail.*;
import javax.mail.internet.AddressException;
import javax.mail.internet.InternetAddress;
import javax.mail.internet.MimeMessage;

import java.util.Properties;
@RestController
public class Helper {

    public void sendEmail() {

        String bounceMail = "chenna.kesavareddy@empower.com";
        Properties props = System.getProperties();

        props.put("mail.smtp.host", "smtp.east.ssp.aws.gwl.com");
        props.put("mail.smtp.auth", "true");
//        props.put("mail.debug", "true");
        props.put("mail.smtp.port", "25");

        Session session = Session.getDefaultInstance(props,
                new javax.mail.Authenticator() {
                    protected PasswordAuthentication getPasswordAuthentication() {
                        return new PasswordAuthentication("chknsv", "Pandu@12");
                    }
                });
        MimeMessage message = new MimeMessage(session);
        String context = "This email is being sent to you after a successful transmission of\n" +
                "your DocuSign document(s).\n";
        try {
            message.setFrom(new InternetAddress("chenna.kesavareddy@empower.com"));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress("ch--ennakeava13579gmail.com"));
            message.setSubject("Successful transmission - Compliance DocuSign");
            message.setText(context);
            message.setReplyTo(new Address[]{new InternetAddress(bounceMail)});
            Transport.send(message);
            checkBounceEmails(bounceMail);
            System.out.println("successfully send the email");
        } catch (SendFailedException sfe) {
            // Handle invalid recipient(s)
            Address[] invalidAddresses = sfe.getInvalidAddresses();
            if (invalidAddresses != null) {
                System.out.println("Invalid addresses:");
                for (Address address : invalidAddresses) {
                    System.out.println(address);
                }
            }

            // Handle valid but failed recipients
            Address[] validUnsentAddresses = sfe.getValidUnsentAddresses();
            if (validUnsentAddresses != null) {
                System.out.println("Valid addresses but unsent:");
                for (Address address : validUnsentAddresses) {
                    System.out.println(address);
                }
            }

            // Handle successfully sent recipients
            Address[] validSentAddresses = sfe.getValidSentAddresses();
            if (validSentAddresses != null) {
                System.out.println("Successfully sent to:");
                for (Address address : validSentAddresses) {
                    System.out.println(address);
                }
            }
        } catch (MessagingException me) {
            System.out.println("Error while sending email: " + me.getMessage());
            me.printStackTrace();
        }
    }

            public  void checkBounceEmails(String bounceMail) {
                String host = "imap.gmail.com"; // Use "pop.gmail.com" for POP3
                String username = bounceMail;
                String password = "Pandu@12";

                Properties properties = new Properties();
                properties.put("mail.store.protocol", "imaps"); // Use "pop3" for POP3
                properties.put("mail.imap.host", host);
                properties.put("mail.imap.port", "993");

                try {
                    // Connect to the email server
                    Session session = Session.getInstance(properties);
                    Store store = session.getStore("imaps");
                    store.connect(host, username, password);

                    // Open the inbox folder
                    Folder inbox = store.getFolder("INBOX");
                    inbox.open(Folder.READ_ONLY);

                    // Fetch all messages
                    Message[] messages = inbox.getMessages();
                    for (Message message : messages) {
                        if (message.getSubject().contains("Undelivered Mail") || message.getSubject().contains("Failure")) {
                            System.out.println("Bounce Email Detected:");
                            System.out.println("From: " + message.getFrom()[0]);
                            System.out.println("Subject: " + message.getSubject());
                            System.out.println("Content: " + message.getContent().toString());
                        }
                    }

                    inbox.close(false);
                    store.close();
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }

        }







import javax.mail.*;
import javax.mail.internet.MimeMessage;
import java.util.Properties;

public class BounceHandler {
    public static void checkBounceEmails() {
        String host = "imap.gmail.com"; // Use "pop.gmail.com" for POP3
        String username = "bounce-handler@example.com";
        String password = "your-password";

        Properties properties = new Properties();
        properties.put("mail.store.protocol", "imaps"); // Use "pop3" for POP3
        properties.put("mail.imap.host", host);
        properties.put("mail.imap.port", "993");

        try {
            // Connect to the email server
            Session session = Session.getInstance(properties);
            Store store = session.getStore("imaps");
            store.connect(host, username, password);

            // Open the inbox folder
            Folder inbox = store.getFolder("INBOX");
            inbox.open(Folder.READ_ONLY);

            // Fetch all messages
            Message[] messages = inbox.getMessages();
            for (Message message : messages) {
                if (message.getSubject().contains("Undelivered Mail") || message.getSubject().contains("Failure")) {
                    System.out.println("Bounce Email Detected:");
                    System.out.println("From: " + message.getFrom()[0]);
                    System.out.println("Subject: " + message.getSubject());
                    System.out.println("Content: " + message.getContent().toString());
                }
            }

            inbox.close(false);
            store.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public static void main(String[] args) {
        checkBounceEmails();
    }
}




try {
    Transport.send(message);
    System.out.println("Email sent successfully.");
} catch (SendFailedException sfe) {
    // Handle invalid recipient(s)
    Address[] invalidAddresses = sfe.getInvalidAddresses();
    if (invalidAddresses != null) {
        System.out.println("Invalid addresses:");
        for (Address address : invalidAddresses) {
            System.out.println(address);
        }
    }

    // Handle valid but failed recipients
    Address[] validUnsentAddresses = sfe.getValidUnsentAddresses();
    if (validUnsentAddresses != null) {
        System.out.println("Valid addresses but unsent:");
        for (Address address : validUnsentAddresses) {
            System.out.println(address);
        }
    }

    // Handle successfully sent recipients
    Address[] validSentAddresses = sfe.getValidSentAddresses();
    if (validSentAddresses != null) {
        System.out.println("Successfully sent to:");
        for (Address address : validSentAddresses) {
            System.out.println(address);
        }
    }
} catch (MessagingException me) {
    System.out.println("Error while sending email: " + me.getMessage());
    me.printStackTrace();
}



@PostMapping("/process-file")
    public String handleFileFromPath(@RequestParam("filePath") String filePath) {


public String buildJsonFromModelMain(ModelMain modelMain) {
    try {
        ObjectMapper objectMapper = new ObjectMapper();

        // Plan details
        Map<String, String> plan = new HashMap<>();
        plan.put("number", modelMain.getPlanNumber());
        plan.put("name", modelMain.getPlanName());
        plan.put("source", "401K"); // Example static value, replace as needed

        // Document details
        Map<String, String> document = new HashMap<>();
        document.put("documentTypeCode", "testdmtycode"); // Example value
        document.put("category", "testCategory"); // Example value

        // Full JSON
        Map<String, Object> jsonMap = new HashMap<>();
        jsonMap.put("plan", plan);
        jsonMap.put("document", document);

        return objectMapper.writeValueAsString(jsonMap);
    } catch (JsonProcessingException e) {
        throw new RuntimeException("Error building JSON", e);
    }
}





Add a Document

REST method POST – adds a document to the ECM

headers Content-Type = multipart/form-data

Body = form-data

typeOfDocument = <use TypeOfDocument Above>

mimeType = real mimetype of the image, example application/pdf

startWorkFlow = true or false.. defaults to false... Only groups that corrordinate with ECM should use this field

documentProperties = JSON string using documentProperties 

example

{
    "plan": {
        "number": "932777-01",
        "name": "ABC Corporation, Inc",
        "source": "401K"
     },
    "document": 
     {
        "documentTypeCode": "testdmtycode",
        "category": "testCategory"
     }
}

file = <byte array>

Response example

{
    "document": {
        "id": "76058815",
        "token": "6d6b1bc0fd4efd79561d30130bfdf3c05760d3ae8dadc741ee6c01b20cec96b1c3a5fc6ed6c5a40a310b580a54b8a523"
    }
}





	@Override
	public ResponseEntity<AddDocumentResponseDTO> addDocument(String typeOfDocument, String documentStringProperties,
															  String mimeType, Boolean startWorkFlow, MultipartFile file) {
		DocumentProperties documentProperties = null;
		if (logger.isDebugEnabled())
			logger.debug("Enering ECMOperationsController-addDocument");
		
		if (startWorkFlow == null) {
			startWorkFlow = Boolean.FALSE;
		}
		
		//verify inputs
		List<ErrorResponseErrorDetails> errorList = ECMUtilities.validateAddDocumentAddData(metaDataTranslationDao.getDocumentTypeObject(), file, documentStringProperties, typeOfDocument, mimeType);
		if (logger.isDebugEnabled())
			logger.debug("ECMOperationsController-addDocument after validate");
		
		if (!errorList.isEmpty()) {
			throw new ECMDocumentsException(ECMConstants.INVALID_REQUEST_MSG + ":" + errorList, null);
		}
		
		try {
			documentProperties = objectMapper.readValue(documentStringProperties, DocumentProperties.class);
		}catch (JsonProcessingException jpe) {
			throw new ECMDocumentsException(ECMConstants.INVALID_REQUEST_MSG + ":JsonProcessingException documentProperties likely a field is unknown:" + jpe.getMessage(), jpe);
		}catch(Exception e) {
			throw new ECMDocumentsException(ECMConstants.INVALID_REQUEST_MSG + ":Exception documentProperties:", e);
		}
		
		
		documentProperties = ECMUtilities.validateBadCharProperties(documentProperties);
		
		
		if (logger.isDebugEnabled())
			logger.debug("ECMOperationsController-addDocument after isEmpty");
		AddDocumentResponseVO addDocumentResponseVO = ecmServiceInterface.addDocument(file, documentProperties, typeOfDocument, mimeType, startWorkFlow);
		
		AddDocumentResponseDTO addDocumentResponseDTO = new AddDocumentResponseDTO();
		AddDocumentResponseDTODocuments responseDTODocument = new AddDocumentResponseDTODocuments();
		responseDTODocument.setId(addDocumentResponseVO.getDocumentId());
		responseDTODocument.setToken(addDocumentResponseVO.getDocumentToken());
		addDocumentResponseDTO.setDocuments(responseDTODocument);
		if (logger.isDebugEnabled())
			logger.debug("Exiting ECMOperationsController-addDocument");
		return ne


public AddDocumentResponseVO addDocument(MultipartFile file, DocumentProperties documentProperties, String typeOfDocument, String mimeType, Boolean startWorkFlow) {
		if (logger.isDebugEnabled())
			logger.debug("Entering ECMService-addDocument");
		AddDocumentResponseVO responseVO;

		byte[] inputFile = null;
		try {
			inputFile = file.getBytes();

		} catch (Exception e) {
			logger.error("Error in getting bytes from input file - {}", e.getMessage());
			List<ErrorResponseErrorDetails> details = new ArrayList<>();
			details.add(ECMUtilities.setErrorDetails(ECMConstants.FILE_INPUT_PARAM, e.getMessage(),
					"Please provide valid and correct file", LocationEnum.BODY));
			throw new ECMDocumentsException("FILE_ERROR Input file is not valid or corrupt:" + details);
		}

		responseVO = onbaseService.addDocument(typeOfDocument, mimeType, inputFile, documentProperties, startWorkFlow);

		if (logger.isDebugEnabled())
			logger.debug("Exiting CommonECMService-addDocument");
		return (responseVO);
	}







org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"ADD_DOCUMENT_ERROR: Error adding document to OnBase:[class ErrorResponseErrorDetails {\n    field: addDocument\n    issue: RuntimeException: createDocumentWithContent createDocumentWithContentWithString required fields are not present or null/empty:[RK - DBINST]:\n    location: body\n    hint: Please check the error details\n}]","details":[{"field":null,"issue":"ADD_DOCUMENT_ERROR: Error adding document to OnBase:[class ErrorResponseErrorDetails {\n    field: addDocument\n    issue: RuntimeException: createDocumentWithContent createDocumentWithContentWithString required fields are not present or null/empty:[RK - DBINST]:\n    location: body\n    hint: Please check the error details\n}]","location":null,"hint":null}],"link":null,"correlationId":"6745e69645f2a17821cc02364377dd1b"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)





org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"category\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan), not marked as ignorable (6 known properties: \"accountGrouping\", \"groupClientBasis\", \"groupClientValue\", \"number\", \"name\", \"source\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\",\n        \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 22] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"]->com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan[\"category\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"category\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan), not marked as ignorable (6 known properties: \"accountGrouping\", \"groupClientBasis\", \"groupClientValue\", \"number\", \"name\", \"source\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\",\n        \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 22] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"]->com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan[\"category\"])","location":null,"hint":null}],"link":null,"correlationId":"6745e499340b193b31a738eb4c4da624"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.


public String buildJsonFromModelMain(ModelMain modelMain) {
    String planName = modelMain.getPlanName();
    String planNumber = modelMain.getPlanNumber();

    // Build JSON as a String
    String json = "{\n" +
            "    \"plan\": {\n" +
            "        \"name\": \"" + planName + "\",\n" +
            "        \"number\": \"" + planNumber + "\",\n" + // Added missing comma
            "        \"category\": \"" + "MassMutual" + "\"\n" +
            "    }\n" +
            "}";

    return json;
}






org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","location":null,"hint":null}],"link":null,"correlationId":"673f57f30133798b3d46067f4763c5ab"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at org.spring
























org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","location":null,"hint":null}],"link":null,"correlationId":"673f57f30133798b3d46067f4763c5ab"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at org.spring




org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"RK - DBINST\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties), not marked as ignorable (3 known properties: \"plan\", \"participant\", \"document\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n    },\n    \"RK - DBINST\": \"some_value\"\n}\"; line: 6, column: 21] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"RK - DBINST\"])","location":null,"hint":null}],"link":null,"correlationId":"673f57f30133798b3d46067f4763c5ab"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at org.springframework


public String buildJsonFromModelMain(ModelMain modelMain) {
    // Retrieve the required fields from ModelMain
    String planName = modelMain.getPlanName();
    String planNumber = modelMain.getPlanNumber();
    
    // Assume that you need to include more fields such as "RK - DBINST"
    String rkDbinst = "some_value"; // Replace with actual value or logic to fetch it

    // Create the JSON body with all required fields
    return "{\n" +
            "    \"plan\": {\n" +
            "        \"name\": \"" + planName + "\",\n" +
            "        \"number\": \"" + planNumber + "\"\n" +
            "    },\n" +
            "    \"RK - DBINST\": \"" + rkDbinst + "\"\n" +  // Include RK - DBINST here
            "}";
}





    public boolean sendPostScanSheets(ModelMain currCell) throws Exception {
        String authorizationID = getAuthorizationID();
        String url = getUrlForEnvironment();

        File file = getFile(currCell.getPlanNumber());

        if (file == null) {
            System.out.println("No file found for plan number " + currCell.getPlanNumber());
            return false;
        }

        byte[] fileContent = Files.readAllBytes(file.toPath());

        // Prepare headers and body for the request
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
        headers.set("Authorization", "Bearer " + authorizationID);

        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("typeOfDocument", "plan"); // Adjust as necessary
        body.add("mimeType", "application/pdf"); // Example mime type
        body.add("startWorkFlow", "false"); // Adjust as necessary
        body.add("documentProperties", getDocumentPropertiesJson());
        body.add("file", new FileSystemResource(file));

        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        // Send POST request
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

        if (response.getStatusCode() == HttpStatus.OK) {
            System.out.println("Document uploaded successfully");
            return true;
        } else {
            System.out.println("Failed to upload document");
            return false;
        }
    }




public String buildJsonFromModelMain(ModelMain modelMain) {
    String planName = modelMain.getPlanName();
    String planNumber = modelMain.getPlanNumber();

    // Assuming [RK - DBINST] is a required field, you should populate it accordingly
    String rkDbInst = "some_value"; // Replace this with the actual value

    // Build JSON as a String
    String json = "{\n" +
            "    \"plan\": {\n" +
            "        \"name\": \"" + planName + "\",\n" +
            "        \"number\": \"" + planNumber + "\",\n" +
            "        \"RK - DBINST\": \"" + rkDbInst + "\"\n" +  // Added the missing field
            "    }\n" +
            "}";

    return json;
}




Add a Document

REST method POST – adds a document to the ECM

headers Content-Type = multipart/form-data

Body = form-data

typeOfDocument = <use TypeOfDocument Above>

mimeType = real mimetype of the image, example application/pdf

startWorkFlow = true or false.. defaults to false... Only groups that corrordinate with ECM should use this field

documentProperties = JSON string using documentProperties 

example

{
    "plan": {
        "number": "932777-01",
        "name": "ABC Corporation, Inc",
        "source": "401K"
     },
    "document": 
     {
        "documentTypeCode": "testdmtycode",
        "category": "testCategory"
     }
}

file = <byte array>

Response example

{
    "document": {
        "id": "76058815",
        "token": "6d6b1bc0fd4efd79561d30130bfdf3c05760d3ae8dadc741ee6c01b20cec96b1c3a5fc6ed6c5a40a310b580a54b8a523"
    }
}



Get a Document List – query the ECM for a list of documents

/documents-list
REST method POST - queries the ECM for a document list

headers  Content-Type = application/json

URI Parameters

typeOfDocument  String  see typeOfDocuments list above. But with spring/boot... if you want multiple use the key/value multiple times 

                                example typeOfDocument=plan&typeOfDocument=participant   

maxResults  100  defaults to 100

returnLatestDocument   true or false defaults to false

includeMimeType  true or false, defaults to false.. its faster to return the data without each docs mimetype.  Only enable if needed

dateFilter – if you are searching by dates.. what is the date field to use for the search

startingDate – if searching by date what date to start with using Date format 2023-01-01

endingDate – if searching by date what date to end with using Date format 2023-03-01

queryTimeout - integer defaults to 15 seconds

tokenTimeToLive – how long should the encrypted token be valid for. defaults to 15 minutes

      IF you want to search for document data with only the onbase document handle (id) use this in the request body

{

"document": 
    {
      "id": "123456789"
    }

}

          Normal search by data...

Request Body  – this is the json search criteria you are searching for.  Some fields can have comma separated for multiple value searches .. comma seperated SSN, planNumber and EventId

{
  "plan": {
    "number": "12345-01",
    "name": "ABC Corporation, Inc",
    "source": "401K",
    "accountGrouping": "123456",
    "groupClientBasis": "654321",
    "groupClientValue": "123456"
  },
  "participant": {
    "name": "John P Smith",
    "individualId": "123456789",
    "socialSecurity": {
      "number": "123456789",
      "numberExtension": "3"
    }
  },
  "document": 
    {
      "batchName": "batch12345"
    }
}

Response for an onbase document

{
    "documents": [
        {
            "id": "76068728",
            "token": "922ee5d61fea2efcb9514977922b742aa61ac6089482e01bcd4d4779097187e559bf06323e27f931395ba30245f3d90b",
            "documentProperties": {
                "document": {
                    "batchName": "TESTBATCH",
                    "createdDate": "2023-02-15T13:35:48-07:00",
                    "documentTypeCode": "TESTJLSR",
                    "documentTitle": "RK - Plan - 2/15/2023 - 932777-01 -  -  -  -  -"
                },
                "plan": {
                    "planName": "ABC CORPORATION, INC",
                    "source": "401K",
                    "planNumber": "932777-01"
                }
            }
        }
    ]
}

response for a filenet document

{{
    "documents": [
        {
            "id": "{3A26CCAF-DFF2-4A6D-8F41-6A8E06884E4E}",
            "token": "33919535781264c010fb6e7345802347a990a9c6438afe82daf02645e10c4487af49adef82d3653b0066dc9041594066c156fd60b6348b9c4fc233d98a5c5248deb2adb25e5eb1cf6a2a52f1fa91aee0267d5bfeec7664c4bd41184be9ac1fee",
            "documentProperties": {
                "document": {
                    "createdDate": "2015-08-31T14:36:12-06:00",
                    "emailBody": "*** Email Body is truncated to 1200 Characters ****     \nSaving transfer checklist to ECM for Plan #",
                    "emailTo": "LCProcessForms-PROD@gwl.com",
                    "emailFrom": "jeff.tenhaken@retirementpartner.com",
                    "mimeType": "application/pdf",
                    "documentTitle": "PlanOnBoarding_READONLY_T2_915800-20.pdf",
                    "emailSubject": "Saving Transfer Checklist for #915800-20",
                    "application_transition_guide": "Historical Client Submission"
                },
                "plan": {
                    "planName": "JTH Dev Test Plan 8-31-15",
                    "planNumber": "932777-01"
                }
            }
        }
    ]
}





org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"ADD_DOCUMENT_ERROR: Error adding document to OnBase:[class ErrorResponseErrorDetails {\n    field: addDocument\n    issue: RuntimeException: createDocumentWithContent createDocumentWithContentWithString required fields are not present or null/empty:[RK - DBINST]:\n    location: body\n    hint: Please check the error details\n}]","details":[{"field":null,"issue":"ADD_DOCUMENT_ERROR: Error adding document to OnBase:[class ErrorResponseErrorDetails {\n    field: addDocument\n    issue: RuntimeException: createDocumentWithContent createDocumentWithContentWithString required fields are not present or null/empty:[RK - DBINST]:\n    location: body\n    hint: Please check the error details\n}]","location":null,"hint":null}],"link":null,"correlationId":"673f4f843f73f14b2eb26ec871925f24"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at org.springframework.web.client.ResponseErrorHandler.handleError(ResponseErrorHandler.java:63)
	at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:942)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:891)
	at or




org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"category\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan), not marked as ignorable (6 known properties: \"accountGrouping\", \"groupClientBasis\", \"groupClientValue\", \"number\", \"name\", \"source\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\",\n        \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 22] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"]->com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan[\"category\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unrecognized field \"category\" (class com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan), not marked as ignorable (6 known properties: \"accountGrouping\", \"groupClientBasis\", \"groupClientValue\", \"number\", \"name\", \"source\"])\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\",\n        \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 22] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"]->com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentPropertiesPlan[\"category\"])","location":null,"hint":null}],"link":null,"correlationId":"673f4e326e6ee1c94025db3d71b88a33"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at 



public String buildJsonFromModelMain(ModelMain modelMain) {
    String planName = modelMain.getPlanName();
    String planNumber = modelMain.getPlanNumber();

    // Build JSON as a String
    String json = "{\n" +
                  "    \"plan\": {\n" +
                  "        \"name\": \"" + planName + "\",\n" +
                  "        \"number\": \"" + planNumber + "\",\n" +  // Added a comma here
                  "        \"category\": \"MassMutual\"\n" +
                  "    }\n" +
                  "}";

    return json;
}





package com.ecm1.ECM1;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class ECMservice {
    private final String runType = "PROD";
    HashMap<String, Integer> user = new HashMap<>();

    public void processFile(String filePath) throws Exception {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            // get the list of rows
            List<ModelMain> rows = parseExcelFile(inputStream);
//            postApi(rows);
            for (ModelMain cell : rows) {
                System.out.println(cell);
            };
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Error processing file: " + e.getMessage());
        }
    }

    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> excelRows = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            // only parsing 4 rows in excel (testing)
            int i = 1;
            int maxRows = 4;
            while (i <= maxRows) {

                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if its empty
                    continue;
                }
                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();
//
//                // Get the associated file
                File file = getFile(plan_number);

                // Create an ModelMain object and add it to the list with file content
                ModelMain ecm = new ModelMain(plan_number, plan_name);
                excelRows.add(ecm);
                i++;
            }
            return excelRows;
        }

    }

    public File getFile(String planNumber) throws Exception {
        // Retrieve the current count for the plan number
        int count = user.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber,count);

        // Print the regex for debugging
        System.out.println("Regex: " + regex);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the directory path
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File directory = new File(directoryPath);

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            user.put(planNumber, count + 1);
            System.out.println("Found file name: " + matchingFiles[0].getName());
            return matchingFiles[0];
        }
        // if file not found
        return null;

    }

    public void postApi(List<ModelMain> rows) throws Exception {
        for (ModelMain cell : rows) {
            sendPostScanSheets(cell);
        }
    }

    boolean status;

    public boolean sendPostScanSheets(ModelMain currCell) throws Exception {
        status = true;

        String authorizationID = getAuthorizationID();

        String url = "";
        if (runType.equals(("PROD"))) {
            url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
        } else if (runType.equals(("DEV"))) {
            url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
        }

        // Get the file associated with the plan number
        File file = getFile(currCell.getPlanNumber());
        if (file == null || !file.exists()) {
            throw new Exception("File not found for plan number: " + currCell.getPlanNumber());
        }

        // Read file content into a byte array
        byte[] fileContent = Files.readAllBytes(file.toPath());

        // Prepare document metadata
        String docuData = buildJsonFromModelMain(currCell);

        // Use ByteArrayResource for file content
        ByteArrayResource resource = new ByteArrayResource(fileContent) {
            @Override
            public String getFilename() {
                return file.getName(); // Set the file name
            }
        };

        // Set up the request body
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", resource); // Add PDF file content
        body.add("typeOfDocument", "plan");
        body.add("mimeType", "application/pdf");
        body.add("documentProperties", docuData); // Add metadata as JSON

        // Set up headers
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);
        headers.add("Authorization", "JWT " + authorizationID);

        // Create the HTTP entity
        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        // Use RestTemplate to make the POST request
        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

        // Print response details
        System.out.println("Response status: " + response.getStatusCode());
        System.out.println("Response body: " + response.getBody());

        return response.getStatusCode().is2xxSuccessful();
    }

    public String buildJsonFromModelMain(ModelMain modelMain) {
        String planName = modelMain.getPlanName();
        String planNumber = modelMain.getPlanNumber();

        // Build JSON as a String
        String json = "{\n" +
                "    \"plan\": {\n" +
                "        \"name\": \"" + planName + "\",\n" +
                "        \"number\": \"" + planNumber + "\"\n" +
                "       \"category\": \"" + "MassMutual" + "\"\n" +
                "    }\n" +
                "}";

        return json;
    }

    /*
     * Get authorization ID for DocuSign POST
     */
    private String getAuthorizationID() {

        String authorizationID = "";

        try {

            /*
             * Set up POST request for authorization key
             */
            URL authorizationUrl = null;
            if (runType.equals("PROD")) {
                authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
            } else if (runType.equals("DEV")) {
                authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
            }

            /*
             * Define JSON object
             */
            String authorizationJSON = "{\n";
            if (runType.equals("PROD")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
            } else if (runType.equals("DEV")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
            }
            authorizationJSON = authorizationJSON + "}\n";

            /*
             * Open connection
             */
            HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

            /*
             * Setup connection properties
             */
            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");

            /*
             * Write POST request
             */
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = authorizationJSON.getBytes("utf-8");
                os.write(input, 0, input.length);
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
             * Get response status
             */
            int status = connection.getResponseCode();

            /*
             * Should be 204, no content returned But we will get the authorization key
             * returned in a header record
             */
            if (status == HttpURLConnection.HTTP_NO_CONTENT) {
                authorizationID = connection.getHeaderField("Authorization");
                System.out.println(authorizationID);
            }
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return authorizationID;
    }


    public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
        // Retrieve the file based on the provided filename
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File file = new File(directoryPath, filename); // Assuming the filename is the full path or relative path to the file

        // Check if the file exists
        if (!file.exists()) {
//            System.out.println("name is "+filename);
            System.out.println(" found");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        try {
            // Read the file content into a byte array
            byte[] fileContent = Files.readAllBytes(file.toPath());

            // Check if the file content is empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // Set the dynamic filename for the response header
            String dynamicFilename = filename; // You can modify this to extract just the file name if needed
//            System.out.println("helo");
            // Return the file content as a response with the proper headers
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                    .body(fileContent);

        } catch (IOException e) {
            // Handle the exception and return an error response
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

}




"C:\Program Files\Java\jdk-21\bin\java.exe" -XX:TieredStopAtLevel=1 -Dspring.output.ansi.enabled=always -Dcom.sun.management.jmxremote -Dspring.jmx.enabled=true -Dspring.liveBeansView.mbeanDomain -Dspring.application.admin.enabled=true "-Dmanagement.endpoints.jmx.exposure.include=*" "-javaagent:C:\Program Files\JetBrains (1)\JetBrains\IntelliJ IDEA 2024.1.1\lib\idea_rt.jar=57504:C:\Program Files\JetBrains (1)\JetBrains\IntelliJ IDEA 2024.1.1\bin" -Dfile.encoding=UTF-8 -Dsun.stdout.encoding=UTF-8 -Dsun.stderr.encoding=UTF-8 -classpath C:\ECM\ECM1\ECM1\target\classes;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-starter-web\3.3.4\spring-boot-starter-web-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-starter\3.3.4\spring-boot-starter-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot\3.3.4\spring-boot-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-autoconfigure\3.3.4\spring-boot-autoconfigure-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-starter-logging\3.3.4\spring-boot-starter-logging-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\ch\qos\logback\logback-classic\1.5.8\logback-classic-1.5.8.jar;C:\Users\service-ascscripting\.m2\repository\ch\qos\logback\logback-core\1.5.8\logback-core-1.5.8.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\logging\log4j\log4j-to-slf4j\2.23.1\log4j-to-slf4j-2.23.1.jar;C:\Users\service-ascscripting\.m2\repository\org\slf4j\jul-to-slf4j\2.0.16\jul-to-slf4j-2.0.16.jar;C:\Users\service-ascscripting\.m2\repository\jakarta\annotation\jakarta.annotation-api\2.1.1\jakarta.annotation-api-2.1.1.jar;C:\Users\service-ascscripting\.m2\repository\org\yaml\snakeyaml\2.2\snakeyaml-2.2.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-starter-json\3.3.4\spring-boot-starter-json-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.17.2\jackson-databind-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.17.2\jackson-annotations-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.17.2\jackson-core-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jdk8\2.17.2\jackson-datatype-jdk8-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\datatype\jackson-datatype-jsr310\2.17.2\jackson-datatype-jsr310-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\com\fasterxml\jackson\module\jackson-module-parameter-names\2.17.2\jackson-module-parameter-names-2.17.2.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\boot\spring-boot-starter-tomcat\3.3.4\spring-boot-starter-tomcat-3.3.4.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\tomcat\embed\tomcat-embed-core\10.1.30\tomcat-embed-core-10.1.30.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\tomcat\embed\tomcat-embed-el\10.1.30\tomcat-embed-el-10.1.30.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\tomcat\embed\tomcat-embed-websocket\10.1.30\tomcat-embed-websocket-10.1.30.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-web\6.1.13\spring-web-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-beans\6.1.13\spring-beans-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\io\micrometer\micrometer-observation\1.13.4\micrometer-observation-1.13.4.jar;C:\Users\service-ascscripting\.m2\repository\io\micrometer\micrometer-commons\1.13.4\micrometer-commons-1.13.4.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-webmvc\6.1.13\spring-webmvc-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-aop\6.1.13\spring-aop-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-context\6.1.13\spring-context-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-expression\6.1.13\spring-expression-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\poi\poi-ooxml\5.2.3\poi-ooxml-5.2.3.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\poi\poi\5.2.3\poi-5.2.3.jar;C:\Users\service-ascscripting\.m2\repository\commons-codec\commons-codec\1.16.1\commons-codec-1.16.1.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\commons\commons-math3\3.6.1\commons-math3-3.6.1.jar;C:\Users\service-ascscripting\.m2\repository\com\zaxxer\SparseBitSet\1.2\SparseBitSet-1.2.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\poi\poi-ooxml-lite\5.2.3\poi-ooxml-lite-5.2.3.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\xmlbeans\xmlbeans\5.1.1\xmlbeans-5.1.1.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\commons\commons-compress\1.21\commons-compress-1.21.jar;C:\Users\service-ascscripting\.m2\repository\commons-io\commons-io\2.11.0\commons-io-2.11.0.jar;C:\Users\service-ascscripting\.m2\repository\com\github\virtuald\curvesapi\1.07\curvesapi-1.07.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\logging\log4j\log4j-api\2.23.1\log4j-api-2.23.1.jar;C:\Users\service-ascscripting\.m2\repository\org\apache\commons\commons-collections4\4.4\commons-collections4-4.4.jar;C:\Users\service-ascscripting\.m2\repository\org\slf4j\slf4j-api\2.0.16\slf4j-api-2.0.16.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-core\6.1.13\spring-core-6.1.13.jar;C:\Users\service-ascscripting\.m2\repository\org\springframework\spring-jcl\6.1.13\spring-jcl-6.1.13.jar com.ecm1.ECM1.Ecm1Application

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/

 :: Spring Boot ::                (v3.3.4)

2024-11-21T07:54:54.028-07:00  INFO 3204 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Starting Ecm1Application using Java 21.0.5 with PID 3204 (C:\ECM\ECM1\ECM1\target\classes started by service-ascscripting in C:\ECM\ECM1\ECM1)
2024-11-21T07:54:54.034-07:00  INFO 3204 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : No active profile set, falling back to 1 default profile: "default"
2024-11-21T07:54:56.218-07:00  INFO 3204 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 8080 (http)
2024-11-21T07:54:56.256-07:00  INFO 3204 --- [ECM1] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]
2024-11-21T07:54:56.257-07:00  INFO 3204 --- [ECM1] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.30]
2024-11-21T07:54:56.389-07:00  INFO 3204 --- [ECM1] [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext
2024-11-21T07:54:56.390-07:00  INFO 3204 --- [ECM1] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 2251 ms
eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJSUzUxMiJ9.eyJ1c2VyU2Vzc2lvbklkIjoiVEhFX1NFU1NJT05fSUQgQWVrd3BUZXFEQ2drakptc1FsR2V2N1ZkNnRwZWw4MzJYWl9lcTdxV1AtbUZSS0I3aFBKTWhhUmw5VUtxMDFCZFRIVTN4dDdwJTI1MEF5TXh1TjhVdkp1QXI1UTJ0XzA2T2dIbGpFVXJwaHpfUzA0c2ZhNkN5TXNzallmQmxLaGNyWFBJaGhMVXZjN0dPR2tkcTBVNDMlMjUwQTZ5ZTdMU2VnWFpJUXMzakFUb3haRDVmVlZydmJjOUtWYjdMWWVTNWJ0ZHRGeFRGRlU5WjlxV09YcHhHY18tMlhsN3oxcjlPVSUyNTBBbjhzZHRBUTNKNlBjcUVFd2FkUGJqMmdKSEEqKiIsDQogInZhbGlkVGltZSI6IjE3MzIyMDQ0OTg5MTUiLA0KICJleHBpcmVUaW1lIjoiMTczMjIwODA5ODkxNSJ9.o6bxSpVhp8NxpPEN-lCDq7mnWvx2GTsb1ZsQSMAx8HGpR_JIFR29ksABJiBArrjFJcoXL7DFoHg-0a163kK374DARZEyglzbF0ZptZBwGlAm2UtFLzE4CyMy4ijk8aZnnhzAzncatxf56Dj0hY0hkMVxSHzLP-J3YW8WYtvcTUgHsdGKod4-y-L81UrRF0YDivJw2-V33QXqnJ0CpyOuo9gmrSHkT2s0PTnQbJG4ApbrmjJjadxJej4K3FRTWYlyRtjwjVy6EAezD9XKYoiO4KESQ5GhHW2rP6PoC23-ly3hc_IF-y4jKGpRrvIwvpeSDaFF7sBwvfeIXDW6FJ1u5g
Regex: 591121-01_PRU_1_\d_\d{8}_\d{4}MST\.pdf
Found file name: 591121-01_PRU_1_6_20231218_1553MST.pdf
org.springframework.web.client.HttpServerErrorException$InternalServerError: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","location":null,"hint":null}],"link":null,"correlationId":"673f49c30ba0f3495c71683d46178afe"}}"
	at org.springframework.web.client.HttpServerErrorException.create(HttpServerErrorException.java:102)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:186)
	at org.springframework.web.client.DefaultResponseErrorHandler.handleError(DefaultResponseErrorHandler.java:137)
	at org.springframework.web.client.ResponseErrorHandler.handleError(ResponseErrorHandler.java:63)
	at org.springframework.web.client.RestTemplate.handleResponse(RestTemplate.java:942)
	at org.springframework.web.client.RestTemplate.doExecute(RestTemplate.java:891)
	at org.springframework.web.client.RestTemplate.execute(RestTemplate.java:790)
	at org.springframework.web.client.RestTemplate.exchange(RestTemplate.java:672)
	at com.ecm1.ECM1.ECMservice.sendPostScanSheets(ECMservice.java:160)
	at com.ecm1.ECM1.ECMservice.postApi(ECMservice.java:105)
	at com.ecm1.ECM1.ECMservice.processFile(ECMservice.java:32)
	at com.ecm1.ECM1.ECMcontroller.handleFileFromPath(ECMcontroller.java:19)
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:25)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:17)
java.lang.Exception: Error processing file: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","location":null,"hint":null}],"link":null,"correlationId":"673f49c30ba0f3495c71683d46178afe"}}"
	at com.ecm1.ECM1.ECMservice.processFile(ECMservice.java:38)
	at com.ecm1.ECM1.ECMcontroller.handleFileFromPath(ECMcontroller.java:19)
	at com.ecm1.ECM1.Ecm1Application.run(Ecm1Application.java:25)
	at java.base/jdk.internal.reflect.DirectMethodHandleAccessor.invoke(DirectMethodHandleAccessor.java:103)
	at java.base/java.lang.reflect.Method.invoke(Method.java:580)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMethod.invoke(InitDestroyAnnotationBeanPostProcessor.java:457)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor$LifecycleMetadata.invokeInitMethods(InitDestroyAnnotationBeanPostProcessor.java:401)
	at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:219)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization(AbstractAutowireCapableBeanFactory.java:422)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(AbstractAutowireCapableBeanFactory.java:1798)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:600)
	at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:522)
	at org.springframework.beans.factory.support.AbstractBeanFactory.lambda$doGetBean$0(AbstractBeanFactory.java:337)
	at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:234)
	at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:335)
	at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:200)
	at org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:975)
	at org.springframework.context.support.AbstractApplicationContext.finishBeanFactoryInitialization(AbstractApplicationContext.java:971)
	at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:625)
	at org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.refresh(ServletWebServerApplicationContext.java:146)
	at org.springframework.boot.SpringApplication.refresh(SpringApplication.java:754)
	at org.springframework.boot.SpringApplication.refreshContext(SpringApplication.java:456)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:335)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1363)
	at org.springframework.boot.SpringApplication.run(SpringApplication.java:1352)
	at com.ecm1.ECM1.Ecm1Application.main(Ecm1Application.java:17)
Failed to process file: Error processing file: 500 : "{"error":{"code":"E-000","message":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","details":[{"field":null,"issue":"INVALID_REQUEST:JsonProcessingException documentProperties likely a field is unknown:Unexpected character ('\"' (code 34)): was expecting comma to separate Object entries\n at [Source: (String)\"{\n    \"plan\": {\n        \"name\": \"Bob Johnson Group Retirement Savings Plan\",\n        \"number\": \"591121-01\"\n       \"category\": \"MassMutual\"\n    }\n}\"; line: 5, column: 9] (through reference chain: com.gwf.specprodecm.api.ecmdocumentsapi.model.DocumentProperties[\"plan\"])","location":null,"hint":null}],"link":null,"correlationId":"673f49c30ba0f3495c71683d46178afe"}}"
2024-11-21T07:54:59.979-07:00  INFO 3204 --- [ECM1] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 8080 (http) with context path '/'
2024-11-21T07:54:59.991-07:00  INFO 3204 --- [ECM1] [           main] com.ecm1.ECM1.Ecm1Application            : Started Ecm1Application in 6.684 seconds (process running for 8.862)
ECM Application is running!



public boolean sendPostScanSheets(ModelMain currCell) throws Exception {
    status = true;

    String authorizationID = getAuthorizationID();

    String url = "";
    if (runType.equals(("PROD"))) {
        url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
    } else if (runType.equals(("DEV"))) {
        url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
    }

    // Get the file associated with the plan number
    File file = getFile(currCell.getPlanNumber());
    if (file == null || !file.exists()) {
        throw new Exception("File not found for plan number: " + currCell.getPlanNumber());
    }

    // Read file content into a byte array
    byte[] fileContent = Files.readAllBytes(file.toPath());

    // Prepare document metadata
    String docuData = buildJsonFromModelMain(currCell);

    // Use ByteArrayResource for file content
    ByteArrayResource resource = new ByteArrayResource(fileContent) {
        @Override
        public String getFilename() {
            return file.getName(); // Set the file name
        }
    };

    // Set up the request body
    MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
    body.add("file", resource); // Add PDF file content
    body.add("typeOfDocument", "plan");
    body.add("mimeType", "application/pdf");
    body.add("documentProperties", docuData); // Add metadata as JSON

    // Set up headers
    HttpHeaders headers = new HttpHeaders();
    headers.setContentType(MediaType.MULTIPART_FORM_DATA);
    headers.add("Authorization", "JWT " + authorizationID);

    // Create the HTTP entity
    HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

    // Use RestTemplate to make the POST request
    RestTemplate restTemplate = new RestTemplate();
    ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

    // Print response details
    System.out.println("Response status: " + response.getStatusCode());
    System.out.println("Response body: " + response.getBody());

    return response.getStatusCode().is2xxSuccessful();
}





package com.ecm1.ECM1;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.util.*;
import java.util.regex.Pattern;

@Service
public class ECMservice {
    private final String runType = "PROD";
    HashMap<String, Integer> user = new HashMap<>();

    @Autowired
    private ECMRepo userRepository;


    public void processFile(String filePath) throws Exception {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            List<ModelMain> rows = parseExcelFile(inputStream);
//            postApi(rows);
            for (ModelMain cell : rows) {
                System.out.println(cell);
//            userRepository.saveAll(users)
            }
            ;
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Error processing file: " + e.getMessage());
        }
    }

    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> userList = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            // only parsing 4 rows in excel (testing)
            int i = 1;
            int maxRows = 4;
            while (i <= maxRows) {

                Row row = sheet.getRow(i);
                if (row == null) {  // Skip row if its empty
                    continue;
                }

                // Extract data from each cell
                String plan_name = row.getCell(5).getStringCellValue();
                String plan_number = row.getCell(4).getStringCellValue();


                // Get the associated file
                File file = getFile(plan_number);
//                System.out.println("file is "+file.getName());

                // Read file content as byte array (binary data)
//                byte[] fileContent = Files.readAllBytes(file.toPath());

                // Create an ECM object and add it to the list with file content
                ModelMain user = new ModelMain(plan_number, plan_name);
                userList.add(user);
                i++;
            }
            return userList;
        }

    }

    String fileName = "";
    public File getFile(String planNumber) throws Exception {
        // Retrieve the current count for the plan number
        int count = user.getOrDefault(planNumber, 1);

        // Construct the regex pattern dynamically
        String regex = String.format("%s_PRU_%d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber,count);

        // Print the regex for debugging
        System.out.println("Regex: " + regex);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // Define the directory path
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File directory = new File(directoryPath);

        // Check if the directory is valid
        if (!directory.exists() || !directory.isDirectory()) {
            System.out.println("Invalid directory path: " + directoryPath);
            return null;
        }

//        // List and print all files in the directory
//        File[] allFiles = directory.listFiles();
//        if (allFiles == null || allFiles.length == 0) {
//            System.out.println("The directory is empty.");
//            return null;
//        }

//        System.out.println("Files in the directory:");
//        for (File file : allFiles) {
//            if (file.isFile()) {
//                System.out.println(file.getName());
//            }
//        }

        // Filter files in the directory matching the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            System.out.println("Found file name: " + matchingFiles[0].getName());
//            return matchingFiles[0];
        }

        // If no file matches, increment the count for future calls
        user.put(planNumber, count + 1);
        System.out.println(user);

        // Print a message indicating no file was found
        System.out.println("No matching file found!");
        return null;
    }


    public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
        // Retrieve the file based on the provided filename
        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
        File file = new File(directoryPath, filename); // Assuming the filename is the full path or relative path to the file

        // Check if the file exists
        if (!file.exists()) {
//            System.out.println("name is "+filename);
            System.out.println(" found");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        try {
            // Read the file content into a byte array
            byte[] fileContent = Files.readAllBytes(file.toPath());

            // Check if the file content is empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // Set the dynamic filename for the response header
            String dynamicFilename = filename; // You can modify this to extract just the file name if needed
//            System.out.println("helo");
            // Return the file content as a response with the proper headers
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                    .body(fileContent);

        } catch (IOException e) {
            // Handle the exception and return an error response
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }

    public void postApi(List<ModelMain> rows) throws Exception {
        for (ModelMain cell : rows) {
            sendPostScanSheets(cell);
        }
    }

    boolean status;

    public boolean sendPostScanSheets(ModelMain currCell) throws Exception {

        status = true;

//        inputDocFileName = modelMain.getInputDocFileName();

        /*
         * Get authorization ID from Empower API
         */
        String authorizationID = getAuthorizationID();

        String url = "";
        if (runType.equals(("PROD"))) {
            url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
        } else if (runType.equals(("DEV"))) {
            url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
        }

        // get the file from plannumber
        File file = getFile(currCell.getPlanNumber());
        FileSystemResource resource = new FileSystemResource(file);

        // Types
        String typeOfDocument = "plan";
        String mimeType = "application/pdf";

        /*
            meta data of document in json
        */
        String docuData = "";
        docuData = buildJsonFromModelMain(currCell);

        // Set the request body
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", resource);
        body.add("typeOfDocument", typeOfDocument);
        body.add("mimeType", mimeType);
        body.add("documentProperties", docuData);

        // Set the headers
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        /*
         * Setup authorization ID in POST header for Empower DocuSign API
         */
        headers.add("Authorization", "JWT " + authorizationID);

        // Create the request entity
        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        // Create a RestTemplate
        RestTemplate restTemplate = new RestTemplate();

        // Make the HTTP POST request
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

        // Print the response
        System.out.println("Response status: " + response.getStatusCode());
        System.out.println("Response body: " + response.getBody());

        return status;
    }

    public String buildJsonFromModelMain(ModelMain modelMain) {
        String planName = modelMain.getPlanName();
        String planNumber = modelMain.getPlanNumber();

        // Build JSON as a String
        String json = "{\n" +
                "    \"plan\": {\n" +
                "        \"name\": \"" + planName + "\",\n" +
                "        \"number\": \"" + planNumber + "\"\n" +
                "    }\n" +
                "}";

        return json;
    }

    /*
     * Get authorization ID for DocuSign POST
     */
    private String getAuthorizationID() {

        String authorizationID = "";

        try {

            /*
             * Set up POST request for authorization key
             */
            URL authorizationUrl = null;
            if (runType.equals("PROD")) {
                authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
            } else if (runType.equals("DEV")) {
                authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
            }

            /*
             * Define JSON object
             */
            String authorizationJSON = "{\n";
            if (runType.equals("PROD")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
            } else if (runType.equals("DEV")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
            }
            authorizationJSON = authorizationJSON + "}\n";

            /*
             * Open connection
             */
            HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

            /*
             * Setup connection properties
             */
            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");

            /*
             * Write POST request
             */
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = authorizationJSON.getBytes("utf-8");
                os.write(input, 0, input.length);
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
             * Get response status
             */
            int status = connection.getResponseCode();

            /*
             * Should be 204, no content returned But we will get the authorization key
             * returned in a header record
             */
            if (status == HttpURLConnection.HTTP_NO_CONTENT) {
                authorizationID = connection.getHeaderField("Authorization");
                System.out.println(authorizationID);
            }
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return authorizationID;
    }

}



public File getFile(String planNumber) throws Exception {
    // Retrieve the current count for the plan number
    int count = user.getOrDefault(planNumber, 1);

    // Construct the regex pattern dynamically
    String regex = String.format("%s_PRU_\\d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber);

    // Print the regex for debugging
    System.out.println("Regex: " + regex);

    // Compile the pattern
    Pattern pattern = Pattern.compile(regex);

    // Define the directory path
    String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
    File directory = new File(directoryPath);

    // Check if the directory is valid
    if (!directory.exists() || !directory.isDirectory()) {
        System.out.println("Invalid directory path: " + directoryPath);
        return null;
    }

    // List and print all files in the directory
    File[] allFiles = directory.listFiles();
    if (allFiles == null || allFiles.length == 0) {
        System.out.println("The directory is empty.");
        return null;
    }

    System.out.println("Files in the directory:");
    for (File file : allFiles) {
        if (file.isFile()) {
            System.out.println(file.getName());
        }
    }

    // Filter files in the directory matching the regex pattern
    File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

    // Return the first matching file if found
    if (matchingFiles != null && matchingFiles.length > 0) {
        System.out.println("Found file name: " + matchingFiles[0].getName());
        return matchingFiles[0];
    }

    // If no file matches, increment the count for future calls
    user.put(planNumber, count + 1);

    // Print a message indicating no file was found
    System.out.println("No matching file found!");
    return null;
}



public File getFile(String planNumber) throws Exception {
    // Retrieve the current count for the plan number
    int count = user.getOrDefault(planNumber, 1);

    // Construct the regex pattern dynamically
    String regex = String.format("%s_PRU_\\d_\\d_\\d{8}_\\d{4}MST\\.pdf", planNumber);

    // Print the regex for debugging
    System.out.println("Regex: " + regex);

    // Compile the pattern
    Pattern pattern = Pattern.compile(regex);

    // Define the directory path
    String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
    File directory = new File(directoryPath);

    // Check if the directory is valid
    if (!directory.exists() || !directory.isDirectory()) {
        System.out.println("Invalid directory path!");
        return null;
    }

    // Filter files in the directory matching the regex pattern
    File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

    // Return the first matching file if found
    if (matchingFiles != null && matchingFiles.length > 0) {
        System.out.println("Found file name: " + matchingFiles[0].getName());
        return matchingFiles[0];
    }

    // If no file matches, increment the count for future calls
    user.put(planNumber, count + 1);

    // Print a message indicating no file was found
    System.out.println("No matching file found!");
    return null;
}





public File getFile(String planNumber) throws Exception {
        int count = user.getOrDefault(planNumber, 1);

        // Use zero-padded format if necessary; ensure to match your file naming
        fileName = String.format("%s_PRU_%02d_\\d_\\d{8}_\\d{4}MST.pdf", planNumber, count); // Adjusted to include ".pdf"

        String directoryPath = "C:\\ECM\\PVR\\All_20231218_1552MST\\";
//        File file = new File(directoryPath, fileName);

        // Compile the pattern
        Pattern pattern = Pattern.compile(fileName);

        // List all files in the directory
        File directory = new File(directoryPath);
        if (!directory.exists() || !directory.isDirectory()) {
            System.out.println("Invalid directory path!");
            return null;
        }

        // Filter files using the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            System.out.println("found file name is " + matchingFiles[0].getName());
            return matchingFiles[0]; // Assuming only one file matches
        }
        // Increment the count for next call
        user.put(planNumber, count + 1);
//        return file;
//        // If no file matches, return null
        System.out.println("No matching file found!");
        return null;

filename: 194715-01_PRU_1_6_20231218_1553MST


// Construct the regex pattern to match the file name
        String regex = String.format("%s_PRU_%02d_\\d_\\d{8}_\\d{4}[A-Z]{3}\\.pdf", planNumber, count);

        // Compile the pattern
        Pattern pattern = Pattern.compile(regex);

        // List all files in the directory
        File directory = new File(directoryPath);
        if (!directory.exists() || !directory.isDirectory()) {
            System.out.println("Invalid directory path!");
            return null;
        }

        // Filter files using the regex pattern
        File[] matchingFiles = directory.listFiles((dir, name) -> pattern.matcher(name).matches());

        // Return the first matching file if found
        if (matchingFiles != null && matchingFiles.length > 0) {
            return matchingFiles[0]; // Assuming only one file matches
        }

        // If no file matches, return null
        System.out.println("No matching file found!");
        return null;





public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
        // Retrieve the file based on the provided filename
        String directoryPath = "C:\\ECM\\docs\\";
        File file = new File(directoryPath, fileName); // Assuming the filename is the full path or relative path to the file
        System.out.println("not found" + file.getAbsolutePath());
        System.out.println("name is "+filename);
        // Check if the file exists
        if (!file.exists()) {
//            System.out.println("name is "+filename);
            System.out.println(" found");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        try {
            // Read the file content into a byte array
            byte[] fileContent = Files.readAllBytes(file.toPath());

            // Check if the file content is empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // Set the dynamic filename for the response header
            String dynamicFilename = filename; // You can modify this to extract just the file name if needed
            System.out.println("helo");
            // Return the file content as a response with the proper headers
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                    .body(fileContent);

        } catch (IOException e) {
            // Handle the exception and return an error response
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }
    }


public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
        // Retrieve the file based on the provided filename
        String directoryPath = "C:\\ECM\\PVR\\";
        File file = new File(directoryPath, fileName); // Assuming the filename is the full path or relative path to the file
        System.out.println("not found");
        System.out.println("name is "+filename);
        // Check if the file exists
        if (!file.exists()) {
//            System.out.println("name is "+filename);
            System.out.println(" found");
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        try {
            // Read the file content into a byte array
            byte[] fileContent = Files.readAllBytes(file.toPath());

            // Check if the file content is empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            // Set the dynamic filename for the response header
            String dynamicFilename = filename; // You can modify this to extract just the file name if needed
            System.out.println("helo");
            // Return the file content as a response with the proper headers
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                    .body(fileContent);

        } catch (IOException e) {
            // Handle the exception and return an error response
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
        }


public ResponseEntity<byte[]> getPDF(String filename) throws Exception {
    // Retrieve the file based on the provided filename
    File file = new File(filename); // Assuming the filename is the full path or relative path to the file
    
    // Check if the file exists
    if (!file.exists()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
    }

    try {
        // Read the file content into a byte array
        byte[] fileContent = Files.readAllBytes(file.toPath());

        // Check if the file content is empty
        if (fileContent == null || fileContent.length == 0) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

        // Set the dynamic filename for the response header
        String dynamicFilename = filename; // You can modify this to extract just the file name if needed

        // Return the file content as a response with the proper headers
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"")
                .header(HttpHeaders.CONTENT_TYPE, "application/pdf")
                .body(fileContent);

    } catch (IOException e) {
        // Handle the exception and return an error response
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);
    }


public ResponseEntity<byte[]> getPDF(Long id) throws Exception {
        File file = getFile(fileName);
        FileSystemResource resource = new FileSystemResource(file);
        
        byte[] fileContent;
        
        try {
            // Check if file content is null or empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            String dynamicFilename = fileName;
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"") // Set the desired filename
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf") // Set the content type for PDF
                    .body(fileContent);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

    }

package com.ecm1.ECM1;

import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;

import java.io.*;
import java.net.HttpURLConnection;
import java.net.URL;
import java.nio.file.Files;
import java.util.*;

@Service
public class ECMservice {
    private final String runType ="PROD";
    HashMap<String, Integer> user = new HashMap<>();

    @Autowired
    private ECMRepo userRepository;


    public void processFile(String filePath) throws Exception {
        try (InputStream inputStream = new FileInputStream(filePath)) {
            List<ModelMain> rows = parseExcelFile(inputStream);
            postApi(rows);
            for(ModelMain cell : rows){
                System.out.println(cell);
//            userRepository.saveAll(users)
            };
        } catch (Exception e) {
            e.printStackTrace();
            throw new Exception("Error processing file: " + e.getMessage());
        }
    }

    private List<ModelMain> parseExcelFile(InputStream inputStream) throws Exception {
        List<ModelMain> userList = new ArrayList<>();
        try (Workbook workbook = new XSSFWorkbook(inputStream)) {
            Sheet sheet = workbook.getSheetAt(0);  // Assume the first sheet contains data
            // only parsing 4 rows in excel (testing)
            int i = 1;
            int maxRows = 4;
             while(i <= maxRows){
                 Row row = sheet.getRow(i);
                if (row.getRowNum() == 0) {  // Skip the header row
                    continue;
                }

                // Extract data from each cell
                String plan_name =  row.getCell(5).getStringCellValue();
                String  plan_number = row.getCell(4).getStringCellValue();


                // Get the associated file
//                File file = getFile(plan_number);
//                System.out.println("file is "+file.getName());

                // Read file content as byte array (binary data)
//                byte[] fileContent = Files.readAllBytes(file.toPath());

                // Create an ECM object and add it to the list with file content
                 ModelMain user = new ModelMain(plan_number, plan_name);
                userList.add(user);
                i++;
            }
            return userList;
        }

    }

    String fileName = "";
    public File getFile(String planNumber) throws Exception {
        int count = user.getOrDefault(planNumber, 1);

        // Use zero-padded format if necessary; ensure to match your file naming
        fileName = String.format("%d_PRU_%02d_6_20231218_1553MST.pdf", planNumber, count); // Adjusted to include ".pdf"

        String directoryPath = "C:\\ECM\\PVR\\";
        File file = new File(directoryPath, fileName);

        // Check if the file exists
        if (!file.exists()) {
            throw new Exception("File not found: " + file.getAbsolutePath());
        }

        // Increment the count for next call
        user.put(planNumber, count + 1);
        return file;
    }

    public ResponseEntity<byte[]> getPDF(Long id) throws Exception {
        Optional<ECM> ecmOptional = userRepository.findById(id);
        byte[] fileContent;
        if (ecmOptional.isPresent()) {
            fileContent = ecmOptional.get().getFileContent();
        } else {
            throw new Exception("File not found for ID: " + id);
        }
        try {
            // Check if file content is null or empty
            if (fileContent == null || fileContent.length == 0) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
            }

            String dynamicFilename = fileName;
            return ResponseEntity.ok()
                    .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + dynamicFilename + "\"") // Set the desired filename
                    .header(HttpHeaders.CONTENT_TYPE, "application/pdf") // Set the content type for PDF
                    .body(fileContent);
        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
        }

    }
    public void postApi(List<ModelMain> rows ) throws Exception {
        for(ModelMain cell : rows){
            sendPostScanSheets(cell);
        }
    }
    boolean status ;
    public boolean sendPostScanSheets(ModelMain currCell) throws Exception {

        status = true;

//        inputDocFileName = modelMain.getInputDocFileName();

        /*
         * Get authorization ID from Empower API
         */
        String authorizationID = getAuthorizationID();

        // Replace with the actual API endpoint
        String url = "";
        if (runType.equals(("PROD"))) {
            url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
        }
        else if (runType.equals(("DEV"))) {
            url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
        }

        // get the file from plannumber
        File file = getFile(currCell.getPlanNumber());
        FileSystemResource resource = new FileSystemResource(file);

        // Types
        String typeOfDocument = "plan";
        String mimeType = "application/pdf";

        /*
            meta data of document in json
        */
        String docuData = "";
        docuData = buildJsonFromModelMain(currCell);

        // Set the request body
        MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();
        body.add("file", resource);
        body.add("typeOfDocument", typeOfDocument);
        body.add("mimeType", mimeType);
        body.add("documentProperties", docuData);

        // Set the headers
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.MULTIPART_FORM_DATA);

        /*
         * Setup authorization ID in POST header for Empower DocuSign API
         */
        headers.add("Authorization", "JWT " + authorizationID);

        // Create the request entity
        HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

        // Create a RestTemplate
        RestTemplate restTemplate = new RestTemplate();

        // Make the HTTP POST request
        ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

        // Print the response
        System.out.println("Response status: " + response.getStatusCode());
        System.out.println("Response body: " + response.getBody());

        return status;
    }
    public String buildJsonFromModelMain(ModelMain modelMain) {
        String planName = modelMain.getPlanName();
        String planNumber = modelMain.getPlanNumber();

        // Build JSON as a String
        String json = "{\n" +
                "    \"plan\": {\n" +
                "        \"name\": \"" + planName + "\",\n" +
                "        \"number\": \"" + planNumber + "\"\n" +
                "    }\n" +
                "}";

        return json;
    }
    /*
     * Get authorization ID for DocuSign POST
     */
    private String getAuthorizationID() {

        String authorizationID = "";

        try {

            /*
             * Set up POST request for authorization key
             */
            URL authorizationUrl = null;
            if (runType.equals("PROD")) {
                authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
            }
            else if (runType.equals("DEV")) {
                authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
            }

            /*
             * Define JSON object
             */
            String authorizationJSON = "{\n";
            if (runType.equals("PROD")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
            }
            else if (runType.equals("DEV")) {
                authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
                authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
            }
            authorizationJSON = authorizationJSON + "}\n";

            /*
             * Open connection
             */
            HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

            /*
             * Setup connection properties
             */
            connection.setDoInput(true);
            connection.setDoOutput(true);
            connection.setRequestMethod("POST");
            connection.setRequestProperty("Content-Type", "application/json");
            connection.setRequestProperty("Accept", "application/json");

            /*
             * Write POST request
             */
            try (OutputStream os = connection.getOutputStream()) {
                byte[] input = authorizationJSON.getBytes("utf-8");
                os.write(input, 0, input.length);
            } catch (IOException e) {
                e.printStackTrace();
            }

            /*
             * Get response status
             */
            int status = connection.getResponseCode();

            /*
             * Should be 204, no content returned But we will get the authorization key
             * returned in a header record
             */
            if (status == HttpURLConnection.HTTP_NO_CONTENT) {
                authorizationID = connection.getHeaderField("Authorization");
                System.out.println(authorizationID);
            }
            connection.disconnect();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return authorizationID;
    }

}



public String buildJsonFromModelMain(ModelMain modelMain) {
    String planName = modelMain.getPlanName();
    String groupID = modelMain.getGroupID();

    // Build JSON as a String
    String json = "{\n" +
            "    \"plan\": {\n" +
            "        \"name\": \"" + planName + "\",\n" +
            "        \"number\": \"" + groupID + "\"\n" +
            "    }\n" +
            "}";

    return json;
}


package com.hrlc.compliance.ecmstore;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;

import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.content.StringBody;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

public class PostAPINew {

	private ModelMain modelMain;
	private boolean status;
	private String inputDocFileName;

	/*
	 * Setup for DEV or PROD
	 */
	private final String runType ="PROD";
	//	private final String runType ="DEV";

	public PostAPINew() {
	}

	public PostAPINew(ModelMain modelMain) {
		this.modelMain = modelMain;
	}

	public boolean sendPostCompliance(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDate(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDate(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDate(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "SmartSubmission" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	/*
	 * Build JSON for document
	 */
	private String buildDocuData(FileSystemResource resource) {
		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Start of docuData
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n";
				
		if (dbinst == null || dbinst.equals("")) {
			docuData = docuData  
			+ "			\"name\": \"" + planName.trim() + "\"\n";
//			+ "			\"name\": \"" + planName.trim() + "\",\n";
//			+ "			\"source\": \"" + "" + "\"\n";
//			+ "			\"source\": \"" + "401k" + "\"\n";
		}
		else {
			docuData = docuData 
				+ "			\"name\": \"" + planName.trim() + "\",\n" 
				+ "			\"source\": \"" + dbinst.trim() + "\"\n";
		}
		docuData = docuData 
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "ScanSheets" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";
		return docuData;
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	public void postOne() {
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";

		// Create the request body as per the API's requirements
		String requestBody = "{\"key1\":\"value1\", \"key2\":\"value2\"}"; // Replace with your actual request body

		// Set the headers
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		// Create the request entity
		HttpEntity<String> requestEntity = new HttpEntity<>(requestBody, headers);

		// Create a RestTemplate
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response
		System.out.println("Response status: " + response.getStatusCode());
		System.out.println("Response body: " + response.getBody());
	}

	public void postJoel() {

		/*
		 * Write out the doc first
		 */
		File file = null;
		String fileName = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		file = new File(fileName);
		if (!file.exists()) {
			System.out.println("Error - Output file does not exist - " + fileName);
			return;
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}

		MultipartFile multipartFile = new MockMultipartFile(fileName, fileName, "application/pdf", image);

		/*
		 * Setup for multipart POST request
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";
		String docuBody = "ContentType.APPLICATION_JSON";
		String typeBody = "plan";
		String mimeBody = "application/pdf";

		/*
		 * Joel
		 */
		HttpHeaders httpHeaders = new HttpHeaders();
		MultiValueMap<String, Object> mvmBody = new LinkedMultiValueMap<>();

		HttpEntity requestEntity = null;
		Resource resource = null;

		httpHeaders.setContentType(org.springframework.http.MediaType.MULTIPART_FORM_DATA);

		resource = multipartFile.getResource();
		mvmBody.add("typeOfDocument", typeBody);
		mvmBody.add("mimeType", mimeBody);
		mvmBody.add("documentProperties", docuData);
		mvmBody.add("file", resource);

		requestEntity =  new HttpEntity<>(mvmBody, httpHeaders);

		RestTemplate restTemplate = new RestTemplate();

		URI location = null;
		try {
			location = new URI("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (URISyntaxException e) {
			e.printStackTrace();
		}
		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.setLocation(location);
		ResponseEntity responseAddDocumentResponseDTO = restTemplate.postForEntity(location, requestEntity, ResponseEntity.class);
		System.out.println(responseAddDocumentResponseDTO.getStatusCodeValue());

	}

	public String fixDate(String currDate) {
		if (currDate == null) {
			return "";
		}
		if (!currDate.equals(null) && !currDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("MM-dd-yyyy HH:mm:ss");

			//			String dateIn = currDate +" 00:00";
			String dateIn = currDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public String fixDateSS(String currDate) {
		if (currDate == null) {
			return "";
		}

		/*
		 * Convert to proper date
		 */
		if (!currDate.equals(null) && !currDate.equals("")) {
			/*
			 * Check month case
			 */
			StringBuffer newDate = new StringBuffer(currDate);
			int ln = newDate.length();

			// Conversion to proper month pascal case
			for (int i = 3; i<=3; i++) {
				newDate.setCharAt(i, Character.toUpperCase(currDate.charAt(i)));
			}
			for (int i = 4; i<=5; i++) {
				newDate.setCharAt(i, Character.toLowerCase(currDate.charAt(i)));
			}

			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

			String dateIn = newDate.toString().trim() +" 00:00:00";
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public static void main(String[] args) {

		PostAPINew testPostman = new PostAPINew();
		//		testPostman.postJoel();
		//		testPostman.doGet();
		//		testPostman.doPost();
		;
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

		MultiValueMap<String, String> map= new LinkedMultiValueMap<String, String>();
		map.add("email", "first.last@example.com");

		HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map, headers);

		try {
			URL url = new URL("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		RestTemplate restTemplate = new RestTemplate();
		System.out.println("Test");
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
	}

}


















public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}



/*
 * Class: ECMStore
 * Author: Paul Raab
 * Date: January 9, 2023
 * Group: HRLC
 * Main application for loading files into Empower ECM.
 * Replaces ContentCollector
 */
package com.hrlc.compliance.ecmstore;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;

import org.apache.commons.io.FilenameUtils;

public class ECMStore {

	private static Logger logger = null;

	/*
	 * Setup for DEV or PROD
	 */
	//	private static String runType = "PROD";
	//	private static String runType = "DEV";
	private static String runType = "UAT";

	public static void main(String[] args) {

		ModelMain modelMain = new ModelMain();
		ParseXML parseXML = new ParseXML(modelMain);
		//		PostAPI postAPI = new PostAPI(modelMain);
		PostAPINew postAPI = new PostAPINew(modelMain);
		Hashtable<String,String> xmlFileHash = new Hashtable<>();
		Hashtable<String,String> docFileHash = new Hashtable<>();

		/*
		 * Do Compliance job
		 */
		String imageDir = "";
		String imageDirCompleted = "";

		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Success\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging\\Test";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Test\\Success\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\Imaging\\Test";
			imageDirCompleted = "V:\\auto\\NewImaging\\Imaging\\Test\\Success\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);
		logger = modelMain.getLogger();
		
		/*
		 * Loop through all files
		 */
		Enumeration<String> e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("Compliance");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostCompliance(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				System.out.println("LocalDateTime : "
						+ todayDT);
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				/*
				 * If production, move files
				 */
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Success\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
			} catch (IOException e1) {
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Success\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}

		/*
		 * Do SmartSubmission job
		 */
		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Completed\\SmartSubmission\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Test\\Completed\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\PlanExpress\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\PlanExpress\\Test\\Completed\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);

		/*
		 * Loop through all files
		 */
		e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("SmartSubmission");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostSmartSubmission(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				System.out.println("LocalDateTime : "
						+ todayDT);
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\SmartSubmission\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf.processed"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}

		/*
		 * Do ScanSheets job
		 */
		if (runType.equals("PROD")) {
			imageDir = "V:\\auto\\NewImaging\\online\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Completed\\";
		}
		else if (runType.equals("DEV")) {
			imageDir = "V:\\auto\\NewImaging\\online\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Test\\Completed\\";
		}
		else if (runType.equals("UAT")) {
			imageDir = "V:\\auto\\NewImaging\\online\\Test\\";
			imageDirCompleted = "V:\\auto\\NewImaging\\online\\Test\\Completed\\";
		}
		xmlFileHash.clear();
		docFileHash.clear();
		modelMain.getFiles(imageDir, xmlFileHash, docFileHash);

		/*
		 * Loop through all files
		 */
		e = xmlFileHash.keys();
		while (e.hasMoreElements()) {
			String key = e.nextElement();
			String xmlFile = xmlFileHash.get(key);
			String pdfFile = docFileHash.get(key);
			parseXML.clearXML();
			parseXML.readXML(xmlFile);
			/*
			 * Check for null file in either PDF or XML
			 */
			if (pdfFile == null || xmlFile == null) {
				continue;
			}
			logger.info("ScanSheets");
			logger.info("Processing XML " + xmlFile + " - PDF " + pdfFile);

			boolean status = postAPI.sendPostScanSheets(pdfFile);
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File xmlFileMove = new File(xmlFile);
				String xmlPath = xmlFileMove.getParent();
				String xmlName = xmlFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp1 = Files.move
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp1 = Files.copy
							(Paths.get(xmlFile),
									Paths.get(xmlPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(xmlName) + "_" + dtstr + ".xml"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			try {
				LocalDateTime todayDT = LocalDateTime.now();
				DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
				String dtstr = todayDT.format(formatter);
				File pdfFileMove = new File(pdfFile);
				String pdfPath = pdfFileMove.getParent();
				String pdfName = pdfFileMove.getName();
				if (runType.equals(("PROD"))) {
					Path temp2 = Files.move
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
				else if (runType.equals(("DEV"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
				else if (runType.equals(("UAT"))) {
					Path temp2 = Files.copy
							(Paths.get(pdfFile),
									Paths.get(pdfPath + "\\Completed\\" + 
											FilenameUtils.removeExtension(pdfName) + "_" + dtstr + ".pdf"));
				}
			} catch (IOException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}

		}
		modelMain.closeLog();


	}

}




package com.hrlc.compliance.ecmstore;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.HashMap;

import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.content.StringBody;
import org.springframework.core.io.FileSystemResource;
import org.springframework.core.io.Resource;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.mock.web.MockMultipartFile;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;

import java.util.logging.Logger;

public class PostAPINew {

	private ModelMain modelMain;
	private boolean status;
	private String inputDocFileName;
	private static Logger logger = null;

	/*
	 * Setup for DEV or PROD
	 */
	//	private final String runType ="PROD";
	//	private final String runType ="DEV";
	private final String runType ="UAT";

	public PostAPINew() {
	}

	public PostAPINew(ModelMain modelMain) {
		super();
		this.modelMain = modelMain;
		logger = modelMain.getLogger();
	}

	public boolean sendPostCompliance(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDate(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDate(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDate(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
		if (!fileName.contains(groupID.trim())) {
			logger.info("Compliance");
			logger.info("Error - FileName - PlanNumber mismatch - skip");
			logger.info("FileName = " + fileName);
			logger.info("PlanNumber = " + groupID.trim());
			return false;
		}
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
//		if (!fileName.contains(groupID.trim())) {
//			logger.info("SmartSubmission");
//			logger.info("Error - FileName - PlanNumber mismatch - skip");
//			logger.info("FileName = " + fileName);
//			logger.info("PlanNumber = " + groupID.trim());
//			return false;
//		}
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n"
				+ "			\"name\": \"" + planName.trim() + "\",\n"
				+ "			\"source\": \"" + dbinst.trim() + "\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "SmartSubmission" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		String url = "";
		if (runType.equals(("PROD"))) {
			url = "https://api.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("DEV"))) {
			url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";
		}
		else if (runType.equals(("UAT"))) {
			url = "https://api-uat.gwl.com/content-management/ecm-documents-api/documents";
		}

		// Define the file         
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";

		/*
		 * Build docuData
		 */
		String docuData = "";
		docuData = buildDocuData(resource);
		if (docuData == null) {
			return false;
		}

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		HttpEntity<MultiValueMap<String, Object>> requestEntity = new HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;
	}

	/*
	 * Build JSON for document
	 */
	private String buildDocuData(FileSystemResource resource) {
		/*
		 * Add parameters to URL
		 */
		String accessCode = modelMain.getAccessCode();
		String actionRequired = modelMain.getActionRequired();
		String availableOnline = modelMain.getAvailableOnline();
		String externalView = "";
		if (availableOnline != null && availableOnline.equals("TRUE")) {
			externalView = "Y";
		}
		else {
			externalView = "";
		}
		String category = modelMain.getCategory();
		String dbinst = modelMain.getDbinst();
		if (dbinst == null || dbinst == "") {
			dbinst = "INST";
		}
		String documentGroup = modelMain.getDocumentGroup();
		String documentClass = modelMain.getDocumentClass();
		String DMTYCODE = modelMain.getDMTYCODE();
		String documentDescription = modelMain.getDocumentDescription();
		String effDate = modelMain.getEffectiveDate();
		effDate = fixDateSS(effDate);
		String friendlyName = modelMain.getFriendlyName();
		String groupID = modelMain.getGroupID();
		String planName = modelMain.getPlanName();
		String periodBegin = modelMain.getPeriodBegin();
		periodBegin = fixDateSS(periodBegin);
		String periodEnd = modelMain.getPeriodEnd();
		periodEnd = fixDateSS(periodEnd);
		String sortOrder = modelMain.getSortOrder();
		String fileName = resource.getFilename();

		/*
		 * Check for filename and plan number match
		 */
		if (!fileName.contains(groupID.trim())) {
			logger.info("ScanSheets");
			logger.info("Error - FileName - PlanNumber mismatch - skip");
			logger.info("FileName = " + fileName);
			logger.info("PlanNumber = " + groupID.trim());
			return null;
		}

		/*
		 * Start of docuData
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"" + groupID.trim() + "\",\n";
				
		if (dbinst == null || dbinst.equals("")) {
			docuData = docuData  
			+ "			\"name\": \"" + planName.trim() + "\"\n";
//			+ "			\"name\": \"" + planName.trim() + "\",\n";
//			+ "			\"source\": \"" + "" + "\"\n";
//			+ "			\"source\": \"" + "INST" + "\"\n";
		}
		else {
			docuData = docuData 
				+ "			\"name\": \"" + planName.trim() + "\",\n" 
				+ "			\"source\": \"" + dbinst.trim() + "\"\n";
		}
		docuData = docuData 
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"actionRequired\": \"" + actionRequired.trim() + "\",\n"
				+ "			\"externalView\": \"" + externalView.trim() + "\",\n"
				+ "			\"category\": \"" + category.trim() + "\",\n"
				+ "			\"documentClass\": \"" + documentClass.trim() + "\",\n"
				+ "			\"documentTypeCode\": \"" + DMTYCODE.trim() + "\",\n"
				+ "			\"eventType\": \"" + documentGroup.trim() + "\",\n"
				+ "			\"sourceSystem\": \"" + "ScanSheets" + "\",\n"
				+ "			\"documentDetails\": \"" + friendlyName.trim() + "\",\n"
				+ "			\"effectiveDateTime\": \"" + effDate.trim() + "\",\n"
				+ "			\"periodBeginDateTime\": \"" + periodBegin.trim() + "\",\n"
				+ "			\"periodEndDateTime\": \"" + periodEnd.trim() + "\",\n"
				+ "			\"sortOrder\": \"" + sortOrder.trim() + "\",\n"
				+ "			\"fileName\": \"" + fileName.trim() + "\"\n"
				+ "		}\n"
				+ "}";
		return docuData;
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}
			else if (runType.equals("UAT")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			else if (runType.equals("UAT")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	public void postOne() {
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents";

		// Create the request body as per the API's requirements
		String requestBody = "{\"key1\":\"value1\", \"key2\":\"value2\"}"; // Replace with your actual request body

		// Set the headers
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		// Create the request entity
		HttpEntity<String> requestEntity = new HttpEntity<>(requestBody, headers);

		// Create a RestTemplate
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response
		System.out.println("Response status: " + response.getStatusCode());
		System.out.println("Response body: " + response.getBody());
	}

	public void postJoel() {

		/*
		 * Write out the doc first
		 */
		File file = null;
		String fileName = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		file = new File(fileName);
		if (!file.exists()) {
			System.out.println("Error - Output file does not exist - " + fileName);
			return;
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}

		MultipartFile multipartFile = new MockMultipartFile(fileName, fileName, "application/pdf", image);

		/*
		 * Setup for multipart POST request
		 */
		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";
		String docuBody = "ContentType.APPLICATION_JSON";
		String typeBody = "plan";
		String mimeBody = "application/pdf";

		/*
		 * Joel
		 */
		HttpHeaders httpHeaders = new HttpHeaders();
		MultiValueMap<String, Object> mvmBody = new LinkedMultiValueMap<>();

		HttpEntity requestEntity = null;
		Resource resource = null;

		httpHeaders.setContentType(org.springframework.http.MediaType.MULTIPART_FORM_DATA);

		resource = multipartFile.getResource();
		mvmBody.add("typeOfDocument", typeBody);
		mvmBody.add("mimeType", mimeBody);
		mvmBody.add("documentProperties", docuData);
		mvmBody.add("file", resource);

		requestEntity =  new HttpEntity<>(mvmBody, httpHeaders);

		RestTemplate restTemplate = new RestTemplate();

		URI location = null;
		try {
			location = new URI("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (URISyntaxException e) {
			e.printStackTrace();
		}
		HttpHeaders responseHeaders = new HttpHeaders();
		responseHeaders.setLocation(location);
		ResponseEntity responseAddDocumentResponseDTO = restTemplate.postForEntity(location, requestEntity, ResponseEntity.class);
		System.out.println(responseAddDocumentResponseDTO.getStatusCodeValue());

	}

	public String fixDate(String currDate) {
		if (currDate == null) {
			return "";
		}
		if (!currDate.equals(null) && !currDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("MM-dd-yyyy HH:mm:ss");

			//			String dateIn = currDate +" 00:00";
			String dateIn = currDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public String fixDateSS(String currDate) {
		if (currDate == null) {
			return "";
		}

		/*
		 * Convert to proper date
		 */
		if (!currDate.equals(null) && !currDate.equals("")) {
			/*
			 * Check month case
			 */
			StringBuffer newDate = new StringBuffer(currDate);
			int ln = newDate.length();

			// Conversion to proper month pascal case
			for (int i = 3; i<=3; i++) {
				newDate.setCharAt(i, Character.toUpperCase(currDate.charAt(i)));
			}
			for (int i = 4; i<=5; i++) {
				newDate.setCharAt(i, Character.toLowerCase(currDate.charAt(i)));
			}

			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy HH:mm:ss");

			String dateIn = newDate.toString().trim() +" 00:00:00";
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			LocalDateTime dateTime = LocalDateTime.parse(dateIn, formatterIn);

			ZoneId zone = ZoneId.of("America/Denver");
			ZoneOffset zoneOffSet = zone.getRules().getOffset(dateTime);

			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ssz");
			DateTimeFormatter formatterOut = DateTimeFormatter.ISO_OFFSET_DATE_TIME;
			//			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss");
			String dtstr = dateTime.atOffset(zoneOffSet).format(formatterOut);

			/*
			 * Must have the time on this
			 */
			currDate = dtstr;
		}
		else {
			currDate = "";
		}
		return currDate;
		//		return 	"2023-02-15T13:35:48-07:00";
		//		return 	"2023-02-15 00:00:00 PM";

	}

	public static void main(String[] args) {

		PostAPINew testPostman = new PostAPINew();
		//		testPostman.postJoel();
		//		testPostman.doGet();
		//		testPostman.doPost();
		;
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);

		MultiValueMap<String, String> map= new LinkedMultiValueMap<String, String>();
		map.add("email", "first.last@example.com");

		HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<MultiValueMap<String, String>>(map, headers);

		try {
			URL url = new URL("https://api-dev.gwl.com/content-management/ecm-documents-api/documents");
		} catch (MalformedURLException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		RestTemplate restTemplate = new RestTemplate();
		System.out.println("Test");
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
		//		ResponseEntity<String> response = restTemplate.postForEntity(url, request , String.class );
	}

}





/**
 * Title: ModelTest
 * Description: Model for the Test application. Communicates with the View
 * and Control about state changes and settings. Stores information about
 * the parameter settings, the input and output files, and the view display.
 *
 * Interesting notes:
 * Notify() can be turned on or off. Typically, if you are loading a large
 * runstream, Notify() will be turned off until the entire file is loaded
 * and processed, and then a global notify is sent, and the auto Notify()
 * is turned back on.
 * @author Paul Raab
 * @version 1.0
 */

package com.hrlc.compliance.ecmstore;

import java.io.*;
import javax.swing.*;

import org.apache.commons.io.FilenameUtils;

import java.util.HashMap;
import java.util.Hashtable;
import java.util.logging.FileHandler;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.regex.Pattern;

public class ModelMain {

	private String inputDocFileName;
	private String inputXMLFileName;
	
	private String AccessCode;
	private String ActionRequired;
	private String AvailableOnline;
	private String Category;
	private String dbinst;
	private String DocumentGroup;
	private String DocumentClass;
	private String DMTYCODE;
	private String DocumentDescription;
	private String EffDate;
	private String FriendlyName;
	private String GroupID;
	private String PlanName;
	private String PeriodBegin;
	private String PeriodEnd;
	private String SortOrder;
	
	private String DocumentTitle; // FriendlyName from XML
	private String BatchName; // ICC Ingestion-<file name>
	private String CategorySubclass; // category from XML
	private String DatabaseInstance; // dbinst from XML
	private String EffectiveDate; // EffDate from XML
	private String ExternalView; // AvailableOnline from XML
	private String DocumentType; // friendlyname from XML
	private String PlanNumber; // GroupID from XML
	private String smart_submission_packages; // FriendlyName from XML
	
	private static Logger logger = null;
	private static FileHandler handler = null;

	public ModelMain() {
		
		handler = null;
		boolean append = true;
		try {
			handler = new FileHandler("C:\\ECMStoreLog\\default.log", append);
		} catch (SecurityException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		SimpleFormatter formatter = new SimpleFormatter();    
		handler.setFormatter(formatter);
		logger = Logger.getLogger("com.hrlc.compliance.ecmstore");
		logger.addHandler(handler);

		logger.info("ECMStore start");

	}

	public String getInputDocFileName() {
		return inputDocFileName;
	}

	public void setInputDocFileName(String inputDocFileName) {
		this.inputDocFileName = inputDocFileName;
	}

	public String getInputXMLFileName() {
		return inputXMLFileName;
	}

	public void setInputXMLFileName(String inputXMLFileName) {
		this.inputXMLFileName = inputXMLFileName;
	}
	
	public String getAccessCode() {
		return AccessCode;
	}

	public void setAccessCode(String accessCode) {
		AccessCode = accessCode;
	}

	public String getActionRequired() {
		return ActionRequired;
	}

	public void setActionRequired(String actionRequired) {
		ActionRequired = actionRequired;
	}

	public String getAvailableOnline() {
		return AvailableOnline;
	}

	public void setAvailableOnline(String availableOnline) {
		AvailableOnline = availableOnline;
	}

	public String getCategory() {
		return Category;
	}

	public void setCategory(String category) {
		Category = category;
	}

	public String getDbinst() {
		return dbinst;
	}

	public void setDbinst(String dbinst) {
		this.dbinst = dbinst;
	}

	public String getDocumentClass() {
		return DocumentClass;
	}

	public void setDocumentClass(String documentClass) {
		DocumentClass = documentClass;
	}

	public String getDMTYCODE() {
		return DMTYCODE;
	}

	public void setDMTYCODE(String dMTYCODE) {
		DMTYCODE = dMTYCODE;
	}

	public String getDocumentDescription() {
		return DocumentDescription;
	}

	public void setDocumentDescription(String documentDescription) {
		DocumentDescription = documentDescription;
	}

	public String getEffDate() {
		return EffDate;
	}

	public void setEffDate(String effDate) {
		EffDate = effDate;
	}

	public String getFriendlyName() {
		return FriendlyName;
	}

	public void setFriendlyName(String friendlyName) {
		FriendlyName = friendlyName;
	}

	public String getGroupID() {
		return GroupID;
	}

	public void setGroupID(String groupID) {
		GroupID = groupID;
	}

	public String getPeriodBegin() {
		return PeriodBegin;
	}

	public void setPeriodBegin(String periodBegin) {
		PeriodBegin = periodBegin;
	}

	public String getPeriodEnd() {
		return PeriodEnd;
	}

	public void setPeriodEnd(String periodEnd) {
		PeriodEnd = periodEnd;
	}

	public String getDocumentTitle() {
		return DocumentTitle;
	}

	public void setDocumentTitle(String documentTitle) {
		DocumentTitle = documentTitle;
	}

	public String getBatchName() {
		return BatchName;
	}

	public void setBatchName(String batchName) {
		BatchName = batchName;
	}

	public String getCategorySubclass() {
		return CategorySubclass;
	}

	public void setCategorySubclass(String categorySubclass) {
		CategorySubclass = categorySubclass;
	}

	public String getDatabaseInstance() {
		return DatabaseInstance;
	}

	public void setDatabaseInstance(String databaseInstance) {
		DatabaseInstance = databaseInstance;
	}

	public String getDocumentGroup() {
		return DocumentGroup;
	}

	public void setDocumentGroup(String documentGroup) {
		this.DocumentGroup = documentGroup;		
	}

	public String getEffectiveDate() {
		return EffectiveDate;
	}

	public void setEffectiveDate(String effectiveDate) {
		EffectiveDate = effectiveDate;
	}

	public String getExternalView() {
		return ExternalView;
	}

	public void setExternalView(String externalView) {
		ExternalView = externalView;
	}

	public String getDocumentType() {
		return DocumentType;
	}

	public void setDocumentType(String documentType) {
		DocumentType = documentType;
	}

	public String getPlanName() {
		return PlanName;
	}

	public void setPlanName(String planName) {
		PlanName = planName;
	}

	public String getPlanNumber() {
		return PlanNumber;
	}

	public void setPlanNumber(String planNumber) {
		PlanNumber = planNumber;
	}

	public String getSmart_submission_packages() {
		return smart_submission_packages;
	}

	public void setSmart_submission_packages(String smart_submission_packages) {
		this.smart_submission_packages = smart_submission_packages;
	}
	
	public String getSortOrder() {
		return SortOrder;
	}
	
	public void setSortOrder(String sortOrder) {
		this.SortOrder = sortOrder;
	}

	/*
	 * Get all the files in a template directory
	 * store in a fileHash Hashtable data structure
	 * Look for only *.docx files
	 */
	public void getFiles(String templateDir, Hashtable<String, String> xmlFileHash,
						 Hashtable<String, String> docFileHash) {

		/*
		 * Set directory name
		 */
		File fileTemplateDir = new File(templateDir);
		String delims  = ".";

		/*
		 * Process all files in directory
		 */
		if (fileTemplateDir.listFiles() == null) {
			return;
		}
		for (final File fileEntry : fileTemplateDir.listFiles()) {

			/*
			 * Debug output
			 */
			String fileName = fileEntry.getName();
			if (fileEntry.isDirectory()) {
				System.out.println("Directory: " + fileEntry.getName());
				continue;
			}
			else if (FilenameUtils.getExtension(fileName) != null &&
					FilenameUtils.getExtension(fileName).equals("xml")) {
				System.out.println("XML" + fileEntry.getName());
				String[] tokenString = fileEntry.getName().split(Pattern.quote("."));

				/*
				 * Get file path
				 */
				String filePath = fileEntry.getPath();

				/*
				 * Put filePath into fileHash using planNumber as key
				 */
				xmlFileHash.put(tokenString[0], filePath);

			}
			else if (FilenameUtils.getExtension(fileName) != null &&
					FilenameUtils.getExtension(fileName).equals("pdf")) {
				System.out.println("PDF " + fileEntry.getName());
				String testStr = fileEntry.getName();
				String[] tokenString = testStr.split(Pattern.quote("."));

				/*
				 * Get file path
				 */
				String filePath = fileEntry.getPath();

				/*
				 * Put filePath into fileHash using planNumber as key
				 */
				docFileHash.put(tokenString[0], filePath);
			}
			else {
				System.out.println(fileEntry.getName());
				continue;
			}

		}
	}
	
	/*
	 * Close log file
	 */
	public void closeLog() {
		handler.close();
	}

	public Logger getLogger() {
		return this.logger;
	}

}





/*
 * Class: DocuSignPostAPI
 * Author: Paul Raab
 * Date: November 11, 2020
 * Group: HRLC
 * Class to build and send POST request to DocuSign API.
 * 
 * Use:
 * https://hc.apache.org/httpcomponents-client-ga/httpmime/examples/org/apache/http/examples/entity/mime/ClientMultipartFormPost.java
 * For formatting response as JSON
 * https://stackoverflow.com/questions/20374156/sending-and-parsing-response-using-http-client-for-a-json-list
 * ====================================================================
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 * ====================================================================
 *
 * This software consists of voluntary contributions made by many
 * individuals on behalf of the Apache Software Foundation.  For more
 * information on the Apache Software Foundation, please see
 * <http://www.apache.org/>.
 * 
 * 06/01/2021
 * Add More detail on response header
 *
 */
package com.hrlc.compliance.ecmstore;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;

import org.apache.commons.codec.Charsets;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.ParseException;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.client.utils.URIBuilder;
import org.apache.http.entity.ContentType;
import org.apache.http.entity.mime.HttpMultipartMode;
import org.apache.http.entity.mime.MultipartEntityBuilder;
import org.apache.http.entity.mime.content.FileBody;
import org.apache.http.entity.mime.content.InputStreamBody;
import org.apache.http.entity.mime.content.StringBody;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;
import org.springframework.core.io.FileSystemResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
//import org.springframework.http.HttpEntity;

/**
 * Example how to use multipart/form encoded POST request.
 */
public class PostAPI {

	private String inputDocFileName;
	private String inputXMLFileName;

	private String DocumentTitle; // FriendlyName from XML
	private String BatchName; // ICC Ingestion-<file name>
	private String CategorySubclass; // category from XML
	private String DatabaseInstance; // dbinst from XML
	private String EffectiveDate; // EffDate from XML
	private String ExternalView; // AvailableOnline from XML
	private String DocumentType; // friendlyname from XML
	private String PlanName; // PlanName from XML
	private String PlanNumber; // GroupID from XML
	private String smart_submission_packages; // FriendlyName from XML

	private String httpStatus = null;
	private String envelopeId = null;
	private String errorDetails = null;
	private String statusStr = null;
	private String statusDateTime = null;
	private boolean status;
	private String error;
	private String message;

	private ArrayList<InputStreamBody> isb = null;

	private ModelMain modelMain;

	private final String runType ="PROD";
	//	private final String runType ="DEV";
	//	private final String runType ="DEVNOAPI";

	public PostAPI(ModelMain modelMain) {
		this.modelMain = modelMain;
	}

	public String getStatusStr() {
		return statusStr;
	}

	public void setStatusStr(String statusStr) {
		this.statusStr = statusStr;
	}

	public String getStatusDateTime() {
		return statusDateTime;
	}

	public void setStatusDateTime(String statusDateTime) {
		this.statusDateTime = statusDateTime;
	}

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}

	/*
	 * Send SmartSubmission POST request
	 */
	public boolean sendPostSmartSubmission(String pdfFile) {

		status = true;

		inputDocFileName = modelMain.getInputDocFileName();

		CloseableHttpClient httpClient = null;
		CloseableHttpResponse httpResponse = null;

		RequestConfig requestConfig = RequestConfig.custom()
				.setConnectionRequestTimeout(100000)
				.setConnectTimeout(100000)
				.setSocketTimeout(100000)
				.build();
		httpClient = HttpClients.custom()
				.setDefaultRequestConfig(requestConfig)
				.build();

		/*
		 * Build the POST request
		 */
		URI uri = null;
		URIBuilder uriBuilder = null;

		/*
		 * Add parameters to URL
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			
			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			String dtstr = date.format(formatterOut);
			/*
			 * Must have the time on this
			 */
			effDate = dtstr + " 00:00:00";
		}
		else {
			effDate = "";
		}
		File testFile = new File(pdfFile);
		String sFileName = testFile.getName();
		String batchName = "ICC Ingestion - " + FilenameUtils.removeExtension(sFileName);
		String sortOrder = modelMain.getSortOrder();

		try {
			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
			uriBuilder = new URIBuilder(uri);
			uriBuilder.addParameter("source", "FileNet");
			uriBuilder.addParameter("returnId", "true");
			uriBuilder.addParameter("contentType", "application/pdf");
//pvr Change SmartSubmissionPackage to ContractsAgreements for OnBase
//			uriBuilder.addParameter("documentType", "ContractsAgreements");
//			uriBuilder.addParameter("fileName", sdocType);
//			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"groupAccount\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"DocumentType\":\"Contracts/Agreements/Signature Page\",\"EffectiveDate\":\"" + effDate + "\"}");
//			uriBuilder.addParameter("subSource", "FASCORE_OS");
//			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

//pvr - original setup for PROD_BPI_OS			
			uriBuilder.addParameter("smart_submission_packages", sdocType);
			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"smart_submission_packages\":\"" + sdocType + "\"}");
			uriBuilder.addParameter("documentType", "SmartSubmissionPackage");
			uriBuilder.addParameter("documentType", "SmartSubmission");
			uriBuilder.addParameter("documentType", "Implementation");
			uriBuilder.addParameter("subSource", "PROD_BPI_OS");

		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}
		System.out.println(uriBuilder.getQueryParams());
		HttpPost post = null;
		try {
			post = new HttpPost(uriBuilder.build());
		} catch (URISyntaxException e2) {
			// TODO Auto-generated catch block
			e2.printStackTrace();
		}

		/*
		 * Write out the doc first
		 */
		File file = null;

		if (pdfFile != null) {
			file = new File(pdfFile);
			if (!file.exists()) {
				System.out.println("Error - Output file does not exist - " + pdfFile);
				status = false;
				setStatusStr("fail");
				setMessage("Error - Output file does not exist - " + pdfFile);
				return status;
			}
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}
		HttpEntity entity = MultipartEntityBuilder.create().addBinaryBody("file", image).build();
		post.setEntity(entity);

		/*
		 * Execute the post request
		 */
		try {
			System.out.println(post.getURI().toString());
			httpResponse = httpClient.execute(post);
		} catch (ClientProtocolException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		System.out.println(httpResponse);
		String httpStatus = null;
		httpStatus = Integer.toString(httpResponse.getStatusLine().getStatusCode());
		System.out.println("----------------------------------------");
		System.out.println(httpResponse.getStatusLine());
		Header[] hM = httpResponse.getAllHeaders();
		for (Header header : hM) {
			System.out.println(header.getName() + " " + header.getValue());
		}
		try {
			fis.close();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return status;

	}

	/*
	 * Test POST
	 */
	public void doPost() {

		/*
		 * Get authorization ID from Empower API
		 */
		System.out.println("Here");
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";

		// Define the file         
		String filePath = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		File file = new File(filePath);         
		FileSystemResource resource = new FileSystemResource(file);  

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";
		HashMap<String, Object> documentProperties = new HashMap<>();
		HashMap<String, String> documentMap = new HashMap<>();
		HashMap<String, String> planMap = new HashMap<>();

		planMap.put("number", "932777-01");
		planMap.put("name", "ecmdocumentsapi-name");
		planMap.put("source", "401K");
		documentProperties.put("plan", planMap);

		documentMap.put("batchName", "ecmdocumentapitest");
		documentMap.put("product", "ecmdocumentapitest");
		documentMap.put("title", "documentTitle");
		documentProperties.put("document", documentMap);

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		org.springframework.http.HttpEntity<MultiValueMap<String, Object>> requestEntity = new org.springframework.http.HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());
	}

	public void doGet() {

		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";
		// Replace with the actual API endpoint         

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();
		headers.setContentType(MediaType.APPLICATION_JSON);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create a HttpEntity         
		org.springframework.http.HttpEntity<String> entity = new org.springframework.http.HttpEntity<>(headers);         

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();         

		// Make the HTTP GET request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.GET, entity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody()); 
	}

	/*
	 * Send SmartSubmission POST request
	 * OnBase version
	 */
	public boolean sendPostSmartSubmissionOnBase(String pdfFile) {

		status = true;

		/*
		 * Get current doc
		 */
		inputDocFileName = modelMain.getInputDocFileName();

		/*
		 * Do OnBase
		 */
		/*
		 * Get authorization ID from Empower API
		 */
		String authorizationID = getAuthorizationID();

		// Replace with the actual API endpoint         
		final String url = "https://api-dev.gwl.com/content-management/ecm-documents-api/documents?id=76282262";

		// Define the file         
		String filePath = "H:/MassMutual/TestFiles/999999-01_2_25_20230715_1121MDT.pdf";
		File file = new File(pdfFile);         
		FileSystemResource resource = new FileSystemResource(file);  

		/*
		 * Set parameter values
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date = LocalDate.parse(dateIn, formatterIn);
			
			DateTimeFormatter formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
			String dtstr = date.format(formatterOut);
			/*
			 * Must have the time on this
			 */
			effDate = dtstr + " 00:00:00";
		}
		else {
			effDate = "";
		}

		// Types
		String typeOfDocument = "plan";
		String mimeType = "application/pdf";
		HashMap<String, Object> documentProperties = new HashMap<>();
		HashMap<String, String> documentMap = new HashMap<>();
		HashMap<String, String> planMap = new HashMap<>();

		planMap.put("number", "932777-01");
		planMap.put("name", "ecmdocumentsapi-name");
		planMap.put("source", "401K");
		documentProperties.put("plan", planMap);

		documentMap.put("batchName", "ecmdocumentapitest");
		documentMap.put("product", "ecmdocumentapitest");
		documentMap.put("title", "documentTitle");
		documentProperties.put("document", documentMap);

		String docuData = "{\n"
				+ "	\"plan\": \n"
				+ "		{\n"
				+ "			\"number\": \"999999-01\",\n"
				+ "			\"name\": \"Mass Mutual\",\n"
				+ "			\"source\": \"401K\"\n"
				+ "		},\n"
				+ "	\"document\": \n"
				+ "		{\n"
				+ "			\"documentTypeCode\": \"testmm\"\n"
				+ "		}\n"
				+ "}";

		// Set the request body         
		MultiValueMap<String, Object> body = new LinkedMultiValueMap<>();         
		body.add("file", resource);    
		body.add("typeOfDocument", typeOfDocument);
		body.add("mimeType", mimeType);
		body.add("documentProperties", docuData);

		// Set the headers         
		HttpHeaders headers = new HttpHeaders();         
		headers.setContentType(MediaType.MULTIPART_FORM_DATA);

		/*
		 * Setup authorization ID in POST header for Empower DocuSign API
		 */
		headers.add("Authorization", "JWT " + authorizationID);

		// Create the request entity         
		org.springframework.http.HttpEntity<MultiValueMap<String, Object>> requestEntity = new org.springframework.http.HttpEntity<>(body, headers);

		// Create a RestTemplate         
		RestTemplate restTemplate = new RestTemplate();

		// Make the HTTP POST request         
		ResponseEntity<String> response = restTemplate.exchange(url, HttpMethod.POST, requestEntity, String.class);

		// Print the response         
		System.out.println("Response status: " + response.getStatusCode());         
		System.out.println("Response body: " + response.getBody());

		return status;

	}

	/*
	 * Send ScanSheets POST request
	 */
	public boolean sendPostScanSheets(String pdfFile) {

		status = true;

		CloseableHttpClient httpClient = null;
		CloseableHttpResponse httpResponse = null;

		RequestConfig requestConfig = RequestConfig.custom()
				.setConnectionRequestTimeout(100000)
				.setConnectTimeout(100000)
				.setSocketTimeout(100000)
				.build();
		httpClient = HttpClients.custom()
				.setDefaultRequestConfig(requestConfig)
				.build();

		/*
		 * Build the POST request
		 */
		URI uri = null;
		URIBuilder uriBuilder = null;

		/*
		 * Add parameters to URL
		 */
		String sdocType = modelMain.getDocumentType();
		String docGroup = modelMain.getDocumentGroup();
		String dbinst = modelMain.getDatabaseInstance();
		String category = modelMain.getCategorySubclass();
		String planName = modelMain.getPlanName();
		String planNumber = modelMain.getPlanNumber();
		String effDate = modelMain.getEffectiveDate();
		if (!effDate.equals(null) && !effDate.equals("")) {
			DateTimeFormatter formatterIn = DateTimeFormatter.ofPattern("dd-MMM-yyyy");

			String dateIn = effDate;
			LocalDate date;
			DateTimeFormatter formatterOut;
			String dtstr;
			try {
				date = LocalDate.parse(dateIn, formatterIn);
				formatterOut = DateTimeFormatter.ofPattern("MM-dd-yyyy");
				dtstr = date.format(formatterOut);
				
				/*
				 * Must have the time on this
				 */
				effDate = dtstr + " 00:00:00";
			}
			catch (Exception e) {
				e.printStackTrace();
				effDate="";
			}
			
		}
		else {
			effDate = "";
		}
		File testFile = new File(pdfFile);
		String sFileName = testFile.getName();
//		String batchName = "ICCPPS" + sFileName;
		String batchName = "ICC Ingestion - " + FilenameUtils.removeExtension(sFileName);
		String sortOrder = modelMain.getSortOrder();
		
		try {
			
			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
			uriBuilder = new URIBuilder(uri);
			uriBuilder.addParameter("source", "FileNet");
			uriBuilder.addParameter("returnId", "true");
			uriBuilder.addParameter("contentType", "application/pdf");
//pvr Change SmartSubmissionPackage to Compliance for OnBase
//			uriBuilder.addParameter("documentType", "Plan");
			uriBuilder.addParameter("documentType", "Plan");
			uriBuilder.addParameter("fileName", sdocType);
//			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\"}");
			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\",\"groupAccount\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"" + sortOrder + "\",\"EffectiveDate\":\"" + effDate + "\"}");
			uriBuilder.addParameter("subSource", "PROD_BPI_OS");
//			uriBuilder.addParameter("subSource", "FASCORE_OS");
			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

//pvr			uri = new URI("http://esb.gwl.com:8080/bpi/service/ecm/document");
//			uriBuilder = new URIBuilder(uri);
//			uriBuilder.addParameter("source", "FileNet");
//			uriBuilder.addParameter("returnId", "true");
//			uriBuilder.addParameter("contentType", "application/pdf");
//			uriBuilder.addParameter("documentType", "SmartSubmissionPackage");
//			uriBuilder.addParameter("fileName", sdocType);
////			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\"}");
////			uriBuilder.addParameter("properties", "{\"BatchName\":\"" + batchName + "\"PlanNumber\":\"" + planNumber + "\",\"PlanName\":\"" + planName + "\",\"DatabaseInstance\":\"" + dbinst + "\",\"CategorySubclass\":\"" + category + "\",\"SortOrder\":\"\" + sortOrder + \"\"}");
//			uriBuilder.addParameter("subSource", "PROD_BPI_OS");
//			uriBuilder.addParameter("userPermissions", "[\"Create\",\"Update\",\"Delete\"]");

		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}
		System.out.println(uriBuilder.getQueryParams());
		HttpPost post = null;
		try {
			post = new HttpPost(uriBuilder.build());
		} catch (URISyntaxException e2) {
			e2.printStackTrace();
		}

		/*
		 * Write out the doc first
		 */
		File file = null;

		if (pdfFile != null) {
			file = new File(pdfFile);
			if (!file.exists()) {
				System.out.println("Error - Output file does not exist - " + pdfFile);
				status = false;
				setStatusStr("fail");
				setMessage("Error - Output file does not exist - " + pdfFile);
				return status;
			}
		}

		/*
		 * Build file part
		 */
		byte[] image = null;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(file);
			image = fis.readAllBytes();
		} 
		catch (Exception e) {
			e.printStackTrace();
		}
		HttpEntity entity = MultipartEntityBuilder.create().addBinaryBody("file", image).build();
		post.setEntity(entity);

		/*
		 * Execute the post request
		 */
		try {
			System.out.println(post.getURI().toString());
			httpResponse = httpClient.execute(post);
		} catch (ClientProtocolException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println(httpResponse);
		String httpStatus = null;
		httpStatus = Integer.toString(httpResponse.getStatusLine().getStatusCode());
		System.out.println("----------------------------------------");
		System.out.println(httpResponse.getStatusLine());
		Header[] hM = httpResponse.getAllHeaders();
		for (Header header : hM) {
			System.out.println(header.getName() + " " + header.getValue());
		}
		try {
			fis.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return status;

	}

	/*
	 * Initialize various status and message values
	 */
	public void clear() {
		setStatusDateTime(null);
		setStatusStr(null);
		setMessage(null);
	}

	/*
	 * Get authorization ID for DocuSign POST
	 */
	private String getAuthorizationID() {

		String authorizationID = "";

		try {

			/*
			 * Set up POST request for authorization key
			 */
			URL authorizationUrl = null;
			if (runType.equals("PROD")) {
				authorizationUrl = new URL("https://backend2-aws.retirementpartner.com:443/security/authenticate/agent");
			}
			else if (runType.equals("DEV")) {
				authorizationUrl = new URL("http://dapps4.gwl.com:8519/security/authenticate/agent");
			}

			/*
			 * Define JSON object
			 */
			String authorizationJSON = "{\n";
			if (runType.equals("PROD")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_4J0I5\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"Empower@2021\"\n";
			}
			else if (runType.equals("DEV")) {
				authorizationJSON = authorizationJSON + "\"username\":\"K_1IN02\",\n";
				authorizationJSON = authorizationJSON + "\"password\":\"testing1\"\n";
			}
			authorizationJSON = authorizationJSON + "}\n";

			/*
			 * Open connection
			 */
			HttpURLConnection connection = (HttpURLConnection) authorizationUrl.openConnection();

			/*
			 * Setup connection properties
			 */
			connection.setDoInput(true);
			connection.setDoOutput(true);
			connection.setRequestMethod("POST");
			connection.setRequestProperty("Content-Type", "application/json");
			connection.setRequestProperty("Accept", "application/json");

			/*
			 * Write POST request
			 */
			try (OutputStream os = connection.getOutputStream()) {
				byte[] input = authorizationJSON.getBytes("utf-8");
				os.write(input, 0, input.length);
			} catch (IOException e) {
				e.printStackTrace();
			}

			/*
			 * Get response status
			 */
			int status = connection.getResponseCode();

			/*
			 * Should be 204, no content returned But we will get the authorization key
			 * returned in a header record
			 */
			if (status == HttpURLConnection.HTTP_NO_CONTENT) {
				authorizationID = connection.getHeaderField("Authorization");
				System.out.println(authorizationID);
			}
			connection.disconnect();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return authorizationID;
	}

	/*
	 * Main for testing class
	 */
	public static void main(String[] args) throws Exception {
	}

}





{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Resource": "*",
			"Effect": "Allow",
			"NotAction": [
				"iam:*",
				"organizations:*",
				"account:*",
				"cloudhsm:*",
				"cognito-idp:*",
				"cognito-identity:*",
				"cognito-sync:*",
				"fms:*",
				"guardduty:*",
				"inspector:*",
				"inspector2:*",
				"macie2:*",
				"network-firewall:*",
				"shield:*"
			],
			"Sid": "AllowPowerUserAccess"
		},
		{
			"Action": [
				"ec2:GetPasswordData",
				"iam:CreateServiceLinkedRole",
				"iam:DeleteServiceLinkedRole",
				"iam:ListRoles",
				"organizations:DescribeOrganization",
				"account:ListRegions"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowPowerUserAccessIam"
		},
		{
			"Action": [
				"iam:List*",
				"iam:Generate*",
				"iam:Get*",
				"iam:Simulate*"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowReadIAMActions"
		},
		{
			"Action": [
				"iam:PassRole"
			],
			"Resource": [
				"arn:aws:iam::563003501456:role/gwf/service/*",
				"arn:aws:iam::563003501456:role/gwf/apps/*"
			],
			"Effect": "Allow",
			"Sid": "PassRole"
		},
		{
			"Action": [
				"ec2:AcceptVpcEndpointConnections",
				"ec2:AcceptVpcPeeringConnection",
				"ec2:AssociateRouteTable",
				"ec2:AssociateSubnetCidrBlock",
				"ec2:AssociateVpcCidrBlock",
				"ec2:AttachClassicLinkVpc",
				"ec2:AttachInternetGateway",
				"ec2:AttachVpnGateway",
				"ec2:CreateDefaultSubnet",
				"ec2:CreateDefaultVpc",
				"ec2:CreateDhcpOptions",
				"ec2:CreateEgressOnlyInternetGateway",
				"ec2:CreateInternetGateway",
				"ec2:CreateNatGateway",
				"ec2:CreateNetworkAcl",
				"ec2:CreateNetworkAclEntry",
				"ec2:CreateRoute",
				"ec2:CreateRouteTable",
				"ec2:CreateSubnet",
				"ec2:CreateVpc",
				"ec2:CreateVpcEndpoint",
				"ec2:CreateVpcEndpointConnectionNotification",
				"ec2:CreateVpcEndpointServiceConfiguration",
				"ec2:CreateVpcPeeringConnection",
				"ec2:CreateVpnConnection",
				"ec2:CreateVpnConnectionRoute",
				"ec2:CreateVpnGateway",
				"wafv2:Create*",
				"wafv2:Update*",
				"wafv2:Delete*",
				"waf:Create*",
				"waf:Update*",
				"waf:Delete*",
				"fms:*",
				"ec2:DeleteEgressOnlyInternetGateway",
				"ec2:DeleteInternetGateway",
				"ec2:DeleteNatGateway",
				"ec2:DeleteNetworkAcl",
				"ec2:DeleteNetworkAclEntry",
				"ec2:DeleteRoute",
				"ec2:DeleteRouteTable",
				"ec2:DeleteSubnet",
				"ec2:DeleteVpc",
				"ec2:DeleteVpcEndpointConnectionNotifications",
				"ec2:DeleteVpcEndpoints",
				"ec2:DeleteVpcEndpointServiceConfigurations",
				"ec2:DeleteVpcPeeringConnection",
				"ec2:DeleteVpnConnection",
				"ec2:DeleteVpnConnectionRoute",
				"ec2:DeleteVpnGateway",
				"ec2:DisableVgwRoutePropagation",
				"ec2:DisassociateRouteTable",
				"ec2:EnableVgwRoutePropagation",
				"ec2:EnableVpcClassicLink",
				"ec2:EnableVpcClassicLinkDnsSupport",
				"ec2:ModifySubnetAttribute",
				"ec2:ModifyVpcAttribute",
				"ec2:ModifyVpcEndpoint",
				"ec2:ModifyVpcEndpointConnectionNotification",
				"ec2:ModifyVpcEndpointServiceConfiguration",
				"ec2:ModifyVpcEndpointServicePermissions",
				"ec2:ModifyVpcPeeringConnectionOptions",
				"ec2:ModifyVpcTenancy",
				"ec2:RejectVpcEndpointConnections",
				"ec2:RejectVpcPeeringConnection",
				"ec2:ReplaceRoute",
				"ec2:ReplaceRouteTableAssociation",
				"s3:PutAccountPublicAccessBlock",
				"s3:PutBucketPublicAccessBlock",
				"s3:DeleteBucketEncryption"
			],
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedAction"
		},
		{
			"Condition": {
				"StringEquals": {
					"ec2:ResourceTag/department": "securityengineering"
				},
				"ForAllValues:StringEquals": {
					"aws:TagKeys": "department"
				}
			},
			"Action": [
				"ec2:AuthorizeSecurityGroupEgress",
				"ec2:AuthorizeSecurityGroupIngress",
				"ec2:CreateSecurityGroup",
				"ec2:DeleteSecurityGroup"
			],
			"Resource": "arn:aws:ec2:*:*:security-group/*",
			"Effect": "Deny",
			"Sid": "DenySecOpsOwnedSecuritygroups"
		},
		{
			"Condition": {
				"StringNotEquals": {
					"aws:RequestedRegion": [
						"us-west-2",
						"us-east-1"
					]
				}
			},
			"Action": "*",
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedRegions"
		}
	]
}




{
  "errorMessage": "An error occurred (UnauthorizedOperation) when calling the StartInstances operation: You are not authorized to perform this operation. User: arn:aws:sts::563003501456:assumed-role/LambdaEC2ManagementRole/test-chenna-last is not authorized to perform: ec2:StartInstances on resource: arn:aws:ec2:us-east-1:563003501456:instance/i-0488b8da2a2809c51 because no identity-based policy allows the ec2:StartInstances action. Encoded authorization failure message: zCAWRNCFjL8YiALExJZzPmdNdFWer4GA75KjX-oZsm1ZREL-N3s9ITmpLEgtBrDKOUGtushvpTeD3TlSA32XCDyYC0Ng7CvhAPkqBgvwj7uYUqwDN-Uumdk9n2jcV4NEyKvQbXKU5QGfAAuSNDU8NUHm_FEOuWTFVCOXrmjZsCu7UKVuXG9HYe4HH9TQjUReokDBdho8Kk-MtDTTssB9UzVm_98f0PM2GayJSnuasAtCRuFy_JnDRJlKy5EQ2AZ1hQSXiVkQRj3dH7VuGR-uYS4qXBV1jQkL8SJGUiXXygx2_GTJPY1P0MRQeA4oIRLs4aoahSAO2bPSYQhCzQtMAz7pCH6aK_QaR11OJbde-JFaDoc9e44Y0Dyvk8WdXpDeoLQHZoe18n-Osi-RsT8zAf3PzaxsCaDqRitcyGbdkCSjscuc9K9X9BFEALGV31Tn4A8At0Mgk1piXkZTreLzsZcbWlXyuibvN0Pu55HgJyU9kx4onMIou9CIK5pBKeAdtVW2u-n62ZQw-MCldOxkkq5HysQ-iFtkZxXd77ehSdIFnOmYpRRyFvtluwzEzjAJWyKhaLkPws1CfJ9aswY3zNgunlJDRAV8mgbZfrOnnOKQNOX4aVMozbg8W7e_J0r_HVcaXJQ_8Bd93ElqkDvVrAnXCq3ZawcGMLDcEAuI_ELcG2LUDyeqq7S7jQWyfQEylcaivOAxQ168Obew0Un8ksVGnW5cIvVE1zj7XQ3cJf-FOoX_rdtoN7-i4TauIeovMxEXzs0Tns46qaqRUGrVysyI0aPv4Zi60UgWtviDTl90P8sfZTqeDmfD71yj-oEP_kHc3LSXAbRdywhv8GorVhO9fcskvFbkep_WERvkuegFRUS1h4OtCzC4v_ff9zK2rrOmHQ4NQAa1aDe3Y0cpStwnT-psgpczhG3eFLglm0MRzODbPlbIulsEJzTlKnA1Dq1yabIPmT8UYWtOJYMk7mk86Vn_2v4eht1Tdya758Hw3PzLxq0",
  "errorType": "ClientError",
  "requestId": "83c9032b-28e2-4d2f-95e7-7c927ea231b3",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 12, in lambda_handler\n    ec2.start_instances(InstanceIds = instances)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 565, in _api_call\n    return self._make_api_call(operation_name, kwargs)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 1021, in _make_api_call\n    raise error_class(parsed_response, operation_name)\n"
  ]
}




AWSTemplateFormatVersion: '2010-09-09'
Description: IAM Role for Lambda to Start/Restart EC2 Instances with Logging Access and Existing Chenna1Policy

Resources:
  # Lambda IAM Role with EC2 management and logging access
  LambdaEC2ManagementRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: LambdaEC2ManagementRole
      Path: /gwf/apps/lambda/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument: 
        Version: '2012-10-17'
        Statement: 
          - Effect: Allow
            Principal: 
              Service: 
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      
      # Attach the required managed policies
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        
        # Attach the already created Chenna1Policy
        - arn:aws:iam::${AWS::AccountId}:policy/gwf/apps/chenna1policy








---
AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'

AWSTemplateFormatVersion: '2010-09-09'
Description: Compliance Lambda IAM Role with an Empower permissions boundary
Resources:
  ComplianceLambdaS3Read:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaS3Read
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
  ComplianceLambdaEC2Full:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaEC2Full
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole



AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role for Lambda with a permissions boundary
Resources:
  
  LambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: LambdaExecutionRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole


---
AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role with a permissions boundary
Resources:
  
  BackupRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: BackupRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - backup.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - >-
          arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup



AWSTemplateFormatVersion: 2010-09-09
Description: Role to allow starting an EC2 instance

Resources:
  EC2StartRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: chenna1role
      Path: /gwf/apps/
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 'ec2.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess



AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'



AWSTemplateFormatVersion: "2010-09-09"
Description: Lambda Role with EC2 and CloudWatch Logs Permissions

Resources:
  Chennatest1LambdaRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: "chennatest1"
      Path: "/gwf/apps/chennatest/"
      PermissionsBoundary: "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      # Attach policies for Lambda to perform basic tasks and the custom permissions
      ManagedPolicyArns: 
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: "CustomEC2AndCloudWatchPermissions"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Permissions for CloudWatch Logs
              - Effect: "Allow"
                Action: 
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              # Permissions to start and stop EC2 instances
              - Effect: "Allow"
                Action: 
                  - "ec2:Start*"
                  - "ec2:Stop*"
                Resource: "*"





AWSTemplateFormatVersion: "2010-09-09"Description: Compliance Lambda IAM Role with an Empower permissions boundaryResources:ComplianceLambdaS3Read:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaS3Read'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonS3FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole'ComplianceLambdaEC2Full:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaEC2Full'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonEC2FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole

{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "IAM Role with a permissions boundary for MyApp",
  "Resources": {
    "MyAppRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "MyAppRole-EC2Access",
        "Path": "/gwf/apps/MyApp/",
        "PermissionsBoundary": "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "ec2.amazonaws.com"
                ]
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
      }
    }
  }
}





Updates:

The /gwf/operations/CDTOperator role has been updated in each account to enable permissions boundary

Assumptions / Requirements:
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Least Preferred Method: Create a Role with Permissions Boundary using CLI
Notes from Matt / SS-Prod example as of 10/24/2018
This page contains the draft directions for how to create IAM roles within a permission boundary.

Assumptions / Requirements:
You must assume an AWS role with permissions to create roles.
Roles may be created with CLI or CloudFormation.  
Currently, roles cannot be created using the console because Path is unsupported in the IAM console.
Roles must be created within the /gwf/apps/app_name/ path.  
Attempts to create roles that are in this path will result in an Access Denied message.
Policies must be created within the /gwf/apps/app_name/ path.  
Attempts to create policies that are not in this path will result in an Access Denied message.
Attempts to create roles with attached policies that are not in this path will result in an Access Denied message.
Attempts to create roles with AWS Managed Policies attached will result in an Access Denied message.
Create a Customer Managed version of the AWS Managed Policy, but replace any reference to Resource: "*" with an IAM Best Practice.
A permissions boundary must be attached to the role at the time of role creation.  There are two policies to choose from:
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services and need to create other roles.
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services.
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
A CloudFormation template.
Instructions:

Create a CloudFormation role template that includes the following properties:
AssumeRolePolicyDocument
Also known as a "trust policy."  See IAM Best Practices: IAM for examples of common trust policy patterns and code snippets.
ManagedPolicyArns
Managed Policies can be created in the same CloudFormation template and passed by reference.
Path
See AWS IAM and Path for details.
RoleName
Roles should follow a descriptive naming standard of <App_Name>-Description.  For example, if my application is called underwaterbasketweaver, I might create a role called UnderwaterBasketWeaver-LambdaWriteToS3Role.
Launch the CloudFormation stack from the template.
An example CloudFormation template in YAML format might look something like:

SampleRole
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
---
AWSTemplateFormatVersion: "2010-09-09"
Description: IAM Role with a permissions boundary
Resources:
  TestRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: 'PermissionBoundaryTestRole'
      Path: /gwf/apps/
      PermissionsBoundary: !Sub "arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - 'ec2.amazonaws.com'
          Action: 'sts:AssumeRole'


Least Preferred Method: Create a Role with Permissions Boundary using CLI
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
Shell access on is-xcloud05nb to obtain federated CLI credentials.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
The trust document for the role in json format.


Instructions:

Login to is-xcloud05nb using LDAP/Active Directory credentials

directions to create SAML token

federate in as /gwf/operations/CDTOperator role for the account that needs the role.

When creating the role, you will need a json file containing a trust policy which defines what service will be using the role.  There are some examples of trust policies in the IAM Best Practices guide. Here is an example for an EC2 role:

ec2trust.json
1
2
3
4
5
6
7
8
9
10
11
12
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
Create a role with a particular boundary:  



[dfgkwg@is-xcloud05nb iamRoleTesting]$ aws iam create-role \
--permissions-boundary arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM \
--role-name testRole3 --assume-role-policy-document file://ec2trust.json \
--path /gwf/apps/<App_name> --profile iamtest

aws iam create-role --permissions-boundary <FULL PERMISSION BOUNDARY ARN> --role-name <ROLE NAME> --assume-role-policy-document file://<PATH TO TRUST DOCUMENT>.json --path /gwf/apps/<APP NAME>/ --profile saml

You should a response similar to the following:

create role output
1
{ "Role": { "PermissionsBoundary": { "PermissionsBoundaryType": "Policy", "PermissionsBoundaryArn": "arn:aws:iam::499776071476:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM" }, "AssumeRolePolicyDocument": { "Version": "2012-10-17", "Statement": [ { "Action": "sts:AssumeRole", "Effect": "Allow", "Principal": { "Service": "ec2.amazonaws.com" } } ] }, "RoleId": "AROAJRPI3P7H4TDI7EHCI", "CreateDate": "2018-10-05T17:13:27Z", "RoleName": "testRole3", "Path": "/gwf/apps/underwaterbasketweaver", "Arn": "arn:aws:iam::499776071476:role/gwf/apps/underwaterbasketweaver/testRole3" }
Create a permissions policy with a path of /gwf/apps/<App_Name>/.

CLI to create IAM policy
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
[user@is-xcloud05nb iamRoleTesting]$ aws iam create-policy --policy-name testPolicyName2 --policy-document file://testPolicy.json --profile iamtest --path /gwf/apps/underwaterbasketweaver/
 {     "Policy":
      {
         "PolicyName": "testPolicyName2",
         "PermissionsBoundaryUsageCount": 0,
         "CreateDate": "2018-10-05T17:20:04Z",
         "AttachmentCount": 0,
         "IsAttachable": true,
         "PolicyId": "ANPAITVBCUQSQA3BHFDJM",
         "DefaultVersionId": "v1",
         "Path": "/gwf/service/",
         "Arn": "arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2",
         "UpdateDate": "2018-10-05T17:20:04Z"
     }
}
Attach the permissions policy to the role.  This step may be performed using the Console once the role and permissions policy in the app-specific path have been created.

CLI to attach IAM policy
1
2
aws iam attach-role-policy --role-name testRole3 --policy-arn arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2 \
--profile iamtest
Diagram


Boundary      
Delegated IAM Administrator
EC2 Instance Boundary
Lambda Boundary
Other Boundaries
Newly Created Roles
arn:aws:iam::role/gwf/service/<ROLE>
CreateBoundedIamPolicy
Required
Boundary
Policies
IAM Administrator
Role managed by Security
Policy managed by Security
Role managed by CDT
Policy managed by CDT
arn:aws:iam::policy/gwf/boundary/*
arn:aws:iam::policy/gwf/service/<POLICY>
Security creates boundaries
based on reasonable and frequent
access requirements in partnership with
the CDT / Application teams
CDT IAM Admins are able to
create new roles and policies,
if and only if they attach an
existing boundary to the role
         Policy
Boundary      
Effective
Permissions
         Policy





Boundary      
Effective
Permissions
Effective
Permissions


arn:aws:iam::role/gwf/operations/<ROLE>
arn:aws:iam::role/gwf/security/<ROLE>
Legend
Effective Permissions using Permissions Boundary
Delegating IAM Administration using Permissions Boundary
Logical Design
- Sid: AllowAttachPermBoundary
  Effect: Allow
  Action:
  - iam:DetachRolePolicy
  - iam:AttachRolePolicy
  - iam:DeleteRolePolicy
  - iam:PutRolePermissionsBoundary
  - iam:CreateRole
  - iam:PutRolePolicy
  Resource: arn:aws:iam:::role/gwf/service/*
  Condition:
    StringLike:
      iam:PermissionsBoundary: arn:aws:iam::*:policy/gwf/boundaries/*

- Sid: AllowOtherIAMActions
  Effect: Allow
  Action:
  - iam:AddRoleToInstanceProfile
  - iam:CreateInstanceProfile
  - iam:CreatePolicy
  - iam:CreatePolicyVersion
  - iam:DeleteInstanceProfile
  - iam:DeletePolicy
  - iam:DeleteRole
  - iam:UpdateRole
  - iam:UpdateRoleDescription
  - iam:RemoveRoleFromInstanceProfile
  Resource:
  - arn:aws:iam:::role/gwf/service/*
  - arn:aws:iam:::policy/gwf/service/*
  - arn:aws:iam:::instance-profile/gwf/service/*

Delegating IAM Administration using Permissions Boundary
Physical Design
arn:aws:iam::role/gwf/operations/DelegatedIAMAdmin
ExampleBlacklistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: blacklist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: BoundaryAllowance
        Effect: Allow
        Action: '*'
        Resource: '*'
      - Sid:DenyNotApprovedAction
        Effect:Deny
        Action:
        - iam:*
        - organizations:*
        Resource:'*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
      
ExampleWhitelistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: whitelist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: AllowActions
        Effect: Allow
        Action: 
        - 's3:GetObject'
        - 'ssm:*'
        - 'logs:*'
        Resource: '*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
        Resource: '*'
Matt Helgen
10/5/2018
Policy
Error Messages
message 1


message 2


message 3


(---------- if you need this -----------------)






Notes from Matt / SS-Prod example as of 10/24/2018
here’s the commands I ran in the sharedservices prod account to create the role, after federating into the CDTOperator role on is-xcloud05nb
 
aws iam create-role \
--permissions-boundary arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary \
--role-name mtthlg-test \
--assume-role-policy-document file://ec2trust.json \
--path /gwf/operations/services/ \
--profile saml

Returns:
{
    "Role": {
        "PermissionsBoundary": {
            "PermissionsBoundaryType": "Policy",
            "PermissionsBoundaryArn": "arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary"
        },
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "ec2.amazonaws.com"
                    }
                }
            ]
        },
        "RoleId": "AROAJSWTGLMITKAYZG35K",
        "CreateDate": "2018-10-24T16:49:37Z",
        "RoleName": "mtthlg-test",
        "Path": "/gwf/operations/services/",
        "Arn": "arn:aws:iam::676428981261:role/gwf/operations/services/mtthlg-test"
    }
}
 
For the boundaries, we’ve created 2 empty boundaries which can be used for testing in every account (the account number will differ by account)
 
arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary  
arn:aws:iam::676428981261:policy/gwf/boundaries/apps/AppsTestBoundary
 
For the ec2trust.json file, this depends on what the role will be used for, here is the example file content for if we are creating an ec2 role, the trust policy will depend on what service needs to use the role:
 
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
After this role is created, you should be able to manage it via the console, or create new policies in cloudformation and attach them to this role. Only the initial creation of the role itself needs to be done via CLI, until the “PermissionsBoundary” option is available as part of the AWS::IAM::Role cloudformation resource properties.







Resources:



Permission Boundary links recommended by Unknown User (rjskkn) on 4 February 2019:

https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html
https://aws.amazon.com/blogs/security/delegate-permission-management-to-developers-using-iam-permissions-boundaries/
https://www.youtube.com/watch?v=YQsK4MtsELU


https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actions-resources-contextkeys.html was a recommended reference to understand adding AWS services to IAM policies from Matt Helgen in October 2018






LikeBe the first to like this
No labelsEdit Labels
User icon: Add a picture of yourself




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaEC2LogsPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:us-east-1:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:Start*'
                  - 'ec2:Stop*'
                Resource: 'arn:aws:ec2:us-east-1:*:instance/*'

Outputs:
  LambdaRole:
    Value: !Ref LambdaExecutionRole
    Description: The IAM role ARN for Lambda execution




AWSTemplateFormatVersion: '2010-09-09'
Resources:

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaExecutionPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128





AWSTemplateFormatVersion: '2010-09-09'
Resources:
  
  # Create the IAM Policy
  LambdaExecutionPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: 'LambdaExecutionPolicy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: 'arn:aws:logs:*:*:*'
          - Effect: Allow
            Action:
              - 'ec2:StartInstances'
              - 'ec2:StopInstances'
            Resource: '*'
      Roles:
        - !Ref LambdaExecutionRole

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: LambdaExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Lambda Function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code: 
        S3Bucket: 'your-lambda-code-bucket'
        S3Key: 'your-lambda-code.zip'
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128

  # CloudWatch log group for Lambda
  LambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub '/aws/lambda/${MyLambdaFunction}'
      RetentionInDays: 14




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ec2:Start*",
        "ec2:Stop*"
      ],
      "Resource": "*"
    }
  ]
}




{'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': '45922bac-072d-484d-83ba-50770d2da1ee', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': '45922bac-072d-484d-83ba-50770d2da1ee', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Mon, 23 Sep 2024 13:54:50 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}
END RequestId: 82f2b6c6-2835-4335-b43b-33c52667dd08

INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e
REPORT RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e	Duration: 1256.09 ms	Billed Duration: 1257 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 570.13 ms	
START RequestId: 70e884fd-d13b-425f-8832-a35244b00733 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 70e884fd-d13b-425f-8832-a35244b00733
REPORT RequestId: 70e884fd-d13b-425f-8832-a35244b00733	Duration: 1117.61 ms	Billed Duration: 1118 ms	Memory Size: 128 MB	Max Memory Used: 87 MB

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            try:
                ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
                print(f"Starting instance {INSTANCE_ID}")
            except Exception as e:
                print(f"exception is {e}");
            
           
            
            # # Wait for the instance to be in running state
            # retry_count = 0
            # max_retries = 4
            # while retry_count < max_retries:
            #     response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
            #     current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
            #     print(f"Current state after start attempt: {current_state}")
                
            #     if current_state == 'running':
            #         print(f"Instance {INSTANCE_ID} is now running.")
            #         break
            #     elif current_state == 'stopped':
            #         print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
            #         retry_count += 1;
            #         time.sleep(4)  # Wait before checking again
            #     else:
            #         print("instance is in unexpected state")
            #         break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # # Send error message via SNS
        # sns_client.publish(
        #     TopicArn=SNS_TOPIC_ARN,
        #     Subject='Error starting EC2 instance',
        #     Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        # )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send escalation email via SNS
def send_escalation_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Escalation Alert: Instance {instance_name} ({instance_id})"
    body = f"Instance {instance_name} ({instance_id}) is still in a stopped state after 1 hour."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to check if the instance is still stopped
def is_instance_stopped(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_state = instance['State']['Name']
        return instance_state == 'stopped'
    return False

def lambda_handler(event, context):
    # Extract instance ID and name from the event
    instance_id = event['instance-id']
    instance_name = event['instance-name']

    # Check if the instance is still stopped
    if is_instance_stopped(instance_id):
        # Send escalation email
        send_escalation_email(instance_id, instance_name)

    return {
        "message": f"Escalation email sent for instance {instance_id}."
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send an initial email via SNS
def send_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) Alert"
    body = f"Instance {instance_name} ({instance_id}) is in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get instance name
def get_instance_name(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        return instance_name
    return None

def lambda_handler(event, context):
    # Extract instance ID from the event
    instance_id = event['detail']['instance-id']

    # Get instance name
    instance_name = get_instance_name(instance_id) or "Unnamed Instance"

    # Send the email
    send_email(instance_id, instance_name)

    return {
        "message": f"Initial email sent for instance {instance_id}.",
        "instance-id": instance_id,
        "instance-name": instance_name
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




https://app.diagrams.net/?src=about
INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: ccf2649f-086a-441a-8309-9960e57577f2 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: ccf2649f-086a-441a-8309-9960e57577f2
REPORT RequestId: ccf2649f-086a-441a-8309-9960e57577f2	Duration: 41737.89 ms	Billed Duration: 41738 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 567.85 ms	


import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            retry_count = 0
            max_retries = 4
            while retry_count < max_retries:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                    retry_count += 1;
                    time.sleep(10)  # Wait before checking again
                else:
                    print("instance is in unexpected state")
                    break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Test Event Name
inputdata

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86
REPORT RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 534.24 ms	Status: timeout

Request ID
7c5fad82-989a-42db-ac8a-96df2d23ff86

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            while True:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                time.sleep(10)  # Wait before checking again

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Starting instance i-0488b8da2a2809c51 {'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Sat, 21 Sep 2024 10:50:18 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}

import boto3
import os

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "states:StartExecution",
      "Resource": "arn:aws:states:REGION:ACCOUNT_ID:stateMachine:STATE_MACHINE_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "sns:Publish",
      "Resource": "arn:aws:sns:REGION:ACCOUNT_ID:TOPIC_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "ec2:DescribeInstances",
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:REGION:ACCOUNT_ID:*"
    }
  ]
}



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Send the initial email when the instance is first stopped
    send_email(instance_id, instance_name)

    # If the instance is still in a stopped state, send the escalation email after some time
    if instance_state == 'stopped':
        send_email(instance_id, instance_name, escalation=True)

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output


-----
{
  "statusCode": 200,
  "body": "{\"detail\": {\"instance-id\": \"i-0488b8da2a2809c51\"}}"
}
output:
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "bba3f772-b551-4e65-a291-ec06a01b78bc",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 37, in lambda_handler\n    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda\n"
  ]
}
code:

import boto3
import time
import os
import json

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available


def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }






-------
import json

def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }



{
  "errorMessage": "'NoneType' object is not subscriptable",
  "errorType": "TypeError",
  "requestId": "bd316927-5a89-481c-89e9-f940a8a129ef",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}



The principal states.amazonaws.com is not authorized to assume the provided role. (role: arn:aws:iam::563003501456:role/gwf/apps/compliance/ComplianceLambdaEC2Chenna1)

{
  "Comment": "State machine to handle EC2 instance stop alerts and escalation",
  "StartAt": "InitialCheck",
  "States": {
    "InitialCheck": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<InitialEmailFunction>",
      "Next": "Wait1Hour"
    },
    "Wait1Hour": {
      "Type": "Wait",
      "Seconds": 3600,
      "Next": "CheckInstanceState"
    },
    "CheckInstanceState": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<RecheckEmailFunction>",
      "End": true
    }
  }
}


Test Event Name
event1

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Version: $LATEST
END RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f
REPORT RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 455.70 ms	Status: timeout

Request ID
ec3fd342-3d6f-480f-963f-42bf39870b2f

{
  "version": "0",
  "id": "c8c7bf83-0ce5-4b94-953e-0d332c7611b5",
  "detail-type": "EC2 Instance State-change Notification",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2023-09-20T18:40:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0abcd1234efgh5678"
  ],
  "detail": {
    "instance-id": "i-0abcd1234efgh5678",
    "state": "stopped"
  }
}



hello i am chenna 
{
  "version": "0",
  "id": "12345678-1234-1234-1234-1234567890ab",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2024-09-18T10:00:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0488b8da2a2809c51"
  ],
  "detail-type": "EC2 Instance State-change Notification",
  "detail": {
    "instance-id": "i-0488b8da2a2809c51",
    "state": "stopped"
  }
}

{
  "instanceId": "$.detail.instance-id",
  "state": "$.detail.state",

  "time": "$.time"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}
{
  "source": ["aws.ec2"],
  "detail-type": ["EC2 Instance State-change Notification"],
  "detail": {
    "state": ["stopped"],
    "instance-id": ["i-0488b8da2a2809c51"]
  }
}
Test Event Name
chennaStopInstance

Response
{
  "errorMessage": "Handler 'Hello::handleRequest' missing on module 'example'",
  "errorType": "Runtime.HandlerNotFound",
  "requestId": "",
  "stackTrace": []
}

Function Logs
[ERROR] Runtime.HandlerNotFound: Handler 'Hello::handleRequest' missing on module 'example'
Traceback (most recent call last):INIT_REPORT Init Duration: 310.36 ms	Phase: invoke	Status: error	Error Type: Runtime.Unknown
START RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32 Version: $LATEST
END RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32
REPORT RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32	Duration: 341.22 ms	Billed Duration: 342 ms	Memory Size: 512 MB	Max Memory Used: 42 MB	Status: error	Error Type: Runtime.Unknown

Request ID
84cb5abc-c4c1-4409-b195-b34f955f5c32



import boto3
import time
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available

# Lambda handler function
def lambda_handler(event, context):
    # Get instance ID from event (triggered by EventBridge)
    instance_id = event['detail']['instance-id']
    
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    # Wait for 1 hour
    time.sleep(3600)  # 3600 seconds = 1 hour
    
    # Check the instance state again after 1 hour
    instance_state = check_instance_state(instance_id)
    
    # If the instance is still in 'stopped' state, send the escalation email
    if instance_state == 'stopped':
        send_email(instance_id, escalation=True)
    
    return {
        'statusCode': 200,
        'body': f'Email sent successfully for instance {instance_id}.'
    }

Test Event Name
event1

Response
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "943b4064-98ae-40b4-bb88-d5bf8b59bfba",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}

Function Logs
START RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba Version: $LATEST
LAMBDA_WARNING: Unhandled exception. The most likely cause is an issue in the function code. However, in rare cases, a Lambda runtime update can cause unexpected function behavior. For functions using managed runtimes, runtime updates can be triggered by a function change, or can be applied automatically. To determine if the runtime has been updated, check the runtime version in the INIT_START log entry. If this error correlates with a change in the runtime version, you may be able to mitigate this error by temporarily rolling back to the previous runtime version. For more information, see https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html
[ERROR] KeyError: 'detail'
Traceback (most recent call last):
  File "/var/task/lambda_function.py", line 36, in lambda_handler
    instance_id = event['detail']['instance-id']END RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba
REPORT RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba	Duration: 6.27 ms	Billed Duration: 7 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 432.06 ms

Request ID
943b4064-98ae-40b4-bb88-d5bf8b59bfba

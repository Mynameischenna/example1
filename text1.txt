{
	"Version": "2012-10-17",
	"Statement": [
		{
			"Resource": "*",
			"Effect": "Allow",
			"NotAction": [
				"iam:*",
				"organizations:*",
				"account:*",
				"cloudhsm:*",
				"cognito-idp:*",
				"cognito-identity:*",
				"cognito-sync:*",
				"fms:*",
				"guardduty:*",
				"inspector:*",
				"inspector2:*",
				"macie2:*",
				"network-firewall:*",
				"shield:*"
			],
			"Sid": "AllowPowerUserAccess"
		},
		{
			"Action": [
				"ec2:GetPasswordData",
				"iam:CreateServiceLinkedRole",
				"iam:DeleteServiceLinkedRole",
				"iam:ListRoles",
				"organizations:DescribeOrganization",
				"account:ListRegions"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowPowerUserAccessIam"
		},
		{
			"Action": [
				"iam:List*",
				"iam:Generate*",
				"iam:Get*",
				"iam:Simulate*"
			],
			"Resource": "*",
			"Effect": "Allow",
			"Sid": "AllowReadIAMActions"
		},
		{
			"Action": [
				"iam:PassRole"
			],
			"Resource": [
				"arn:aws:iam::563003501456:role/gwf/service/*",
				"arn:aws:iam::563003501456:role/gwf/apps/*"
			],
			"Effect": "Allow",
			"Sid": "PassRole"
		},
		{
			"Action": [
				"ec2:AcceptVpcEndpointConnections",
				"ec2:AcceptVpcPeeringConnection",
				"ec2:AssociateRouteTable",
				"ec2:AssociateSubnetCidrBlock",
				"ec2:AssociateVpcCidrBlock",
				"ec2:AttachClassicLinkVpc",
				"ec2:AttachInternetGateway",
				"ec2:AttachVpnGateway",
				"ec2:CreateDefaultSubnet",
				"ec2:CreateDefaultVpc",
				"ec2:CreateDhcpOptions",
				"ec2:CreateEgressOnlyInternetGateway",
				"ec2:CreateInternetGateway",
				"ec2:CreateNatGateway",
				"ec2:CreateNetworkAcl",
				"ec2:CreateNetworkAclEntry",
				"ec2:CreateRoute",
				"ec2:CreateRouteTable",
				"ec2:CreateSubnet",
				"ec2:CreateVpc",
				"ec2:CreateVpcEndpoint",
				"ec2:CreateVpcEndpointConnectionNotification",
				"ec2:CreateVpcEndpointServiceConfiguration",
				"ec2:CreateVpcPeeringConnection",
				"ec2:CreateVpnConnection",
				"ec2:CreateVpnConnectionRoute",
				"ec2:CreateVpnGateway",
				"wafv2:Create*",
				"wafv2:Update*",
				"wafv2:Delete*",
				"waf:Create*",
				"waf:Update*",
				"waf:Delete*",
				"fms:*",
				"ec2:DeleteEgressOnlyInternetGateway",
				"ec2:DeleteInternetGateway",
				"ec2:DeleteNatGateway",
				"ec2:DeleteNetworkAcl",
				"ec2:DeleteNetworkAclEntry",
				"ec2:DeleteRoute",
				"ec2:DeleteRouteTable",
				"ec2:DeleteSubnet",
				"ec2:DeleteVpc",
				"ec2:DeleteVpcEndpointConnectionNotifications",
				"ec2:DeleteVpcEndpoints",
				"ec2:DeleteVpcEndpointServiceConfigurations",
				"ec2:DeleteVpcPeeringConnection",
				"ec2:DeleteVpnConnection",
				"ec2:DeleteVpnConnectionRoute",
				"ec2:DeleteVpnGateway",
				"ec2:DisableVgwRoutePropagation",
				"ec2:DisassociateRouteTable",
				"ec2:EnableVgwRoutePropagation",
				"ec2:EnableVpcClassicLink",
				"ec2:EnableVpcClassicLinkDnsSupport",
				"ec2:ModifySubnetAttribute",
				"ec2:ModifyVpcAttribute",
				"ec2:ModifyVpcEndpoint",
				"ec2:ModifyVpcEndpointConnectionNotification",
				"ec2:ModifyVpcEndpointServiceConfiguration",
				"ec2:ModifyVpcEndpointServicePermissions",
				"ec2:ModifyVpcPeeringConnectionOptions",
				"ec2:ModifyVpcTenancy",
				"ec2:RejectVpcEndpointConnections",
				"ec2:RejectVpcPeeringConnection",
				"ec2:ReplaceRoute",
				"ec2:ReplaceRouteTableAssociation",
				"s3:PutAccountPublicAccessBlock",
				"s3:PutBucketPublicAccessBlock",
				"s3:DeleteBucketEncryption"
			],
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedAction"
		},
		{
			"Condition": {
				"StringEquals": {
					"ec2:ResourceTag/department": "securityengineering"
				},
				"ForAllValues:StringEquals": {
					"aws:TagKeys": "department"
				}
			},
			"Action": [
				"ec2:AuthorizeSecurityGroupEgress",
				"ec2:AuthorizeSecurityGroupIngress",
				"ec2:CreateSecurityGroup",
				"ec2:DeleteSecurityGroup"
			],
			"Resource": "arn:aws:ec2:*:*:security-group/*",
			"Effect": "Deny",
			"Sid": "DenySecOpsOwnedSecuritygroups"
		},
		{
			"Condition": {
				"StringNotEquals": {
					"aws:RequestedRegion": [
						"us-west-2",
						"us-east-1"
					]
				}
			},
			"Action": "*",
			"Resource": "*",
			"Effect": "Deny",
			"Sid": "DenyNotApprovedRegions"
		}
	]
}




{
  "errorMessage": "An error occurred (UnauthorizedOperation) when calling the StartInstances operation: You are not authorized to perform this operation. User: arn:aws:sts::563003501456:assumed-role/LambdaEC2ManagementRole/test-chenna-last is not authorized to perform: ec2:StartInstances on resource: arn:aws:ec2:us-east-1:563003501456:instance/i-0488b8da2a2809c51 because no identity-based policy allows the ec2:StartInstances action. Encoded authorization failure message: zCAWRNCFjL8YiALExJZzPmdNdFWer4GA75KjX-oZsm1ZREL-N3s9ITmpLEgtBrDKOUGtushvpTeD3TlSA32XCDyYC0Ng7CvhAPkqBgvwj7uYUqwDN-Uumdk9n2jcV4NEyKvQbXKU5QGfAAuSNDU8NUHm_FEOuWTFVCOXrmjZsCu7UKVuXG9HYe4HH9TQjUReokDBdho8Kk-MtDTTssB9UzVm_98f0PM2GayJSnuasAtCRuFy_JnDRJlKy5EQ2AZ1hQSXiVkQRj3dH7VuGR-uYS4qXBV1jQkL8SJGUiXXygx2_GTJPY1P0MRQeA4oIRLs4aoahSAO2bPSYQhCzQtMAz7pCH6aK_QaR11OJbde-JFaDoc9e44Y0Dyvk8WdXpDeoLQHZoe18n-Osi-RsT8zAf3PzaxsCaDqRitcyGbdkCSjscuc9K9X9BFEALGV31Tn4A8At0Mgk1piXkZTreLzsZcbWlXyuibvN0Pu55HgJyU9kx4onMIou9CIK5pBKeAdtVW2u-n62ZQw-MCldOxkkq5HysQ-iFtkZxXd77ehSdIFnOmYpRRyFvtluwzEzjAJWyKhaLkPws1CfJ9aswY3zNgunlJDRAV8mgbZfrOnnOKQNOX4aVMozbg8W7e_J0r_HVcaXJQ_8Bd93ElqkDvVrAnXCq3ZawcGMLDcEAuI_ELcG2LUDyeqq7S7jQWyfQEylcaivOAxQ168Obew0Un8ksVGnW5cIvVE1zj7XQ3cJf-FOoX_rdtoN7-i4TauIeovMxEXzs0Tns46qaqRUGrVysyI0aPv4Zi60UgWtviDTl90P8sfZTqeDmfD71yj-oEP_kHc3LSXAbRdywhv8GorVhO9fcskvFbkep_WERvkuegFRUS1h4OtCzC4v_ff9zK2rrOmHQ4NQAa1aDe3Y0cpStwnT-psgpczhG3eFLglm0MRzODbPlbIulsEJzTlKnA1Dq1yabIPmT8UYWtOJYMk7mk86Vn_2v4eht1Tdya758Hw3PzLxq0",
  "errorType": "ClientError",
  "requestId": "83c9032b-28e2-4d2f-95e7-7c927ea231b3",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 12, in lambda_handler\n    ec2.start_instances(InstanceIds = instances)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 565, in _api_call\n    return self._make_api_call(operation_name, kwargs)\n",
    "  File \"/var/lang/lib/python3.12/site-packages/botocore/client.py\", line 1021, in _make_api_call\n    raise error_class(parsed_response, operation_name)\n"
  ]
}




AWSTemplateFormatVersion: '2010-09-09'
Description: IAM Role for Lambda to Start/Restart EC2 Instances with Logging Access and Existing Chenna1Policy

Resources:
  # Lambda IAM Role with EC2 management and logging access
  LambdaEC2ManagementRole:
    Type: AWS::IAM::Role
    Properties: 
      RoleName: LambdaEC2ManagementRole
      Path: /gwf/apps/lambda/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument: 
        Version: '2012-10-17'
        Statement: 
          - Effect: Allow
            Principal: 
              Service: 
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      
      # Attach the required managed policies
      ManagedPolicyArns: 
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        
        # Attach the already created Chenna1Policy
        - arn:aws:iam::${AWS::AccountId}:policy/gwf/apps/chenna1policy








---
AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'

AWSTemplateFormatVersion: '2010-09-09'
Description: Compliance Lambda IAM Role with an Empower permissions boundary
Resources:
  ComplianceLambdaS3Read:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaS3Read
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonS3FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole
  ComplianceLambdaEC2Full:
    Type: AWS::IAM::Role
    Properties:
      RoleName: ComplianceLambdaEC2Full
      Path: /gwf/apps/compliance/
      PermissionsBoundary: !Sub arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AWSLambda_FullAccess
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action: sts:AssumeRole



AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role for Lambda with a permissions boundary
Resources:
  
  LambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: LambdaExecutionRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
        - arn:aws:iam::aws:policy/service-role/AWSLambdaVPCAccessExecutionRole


---
AWSTemplateFormatVersion: 2010-09-09
Description: IAM Role with a permissions boundary
Resources:
  
  BackupRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: BackupRole
      Path: /gwf/apps/
      PermissionsBoundary: !Sub >-
        arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - backup.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      ManagedPolicyArns:
        - >-
          arn:aws:iam::aws:policy/service-role/AWSBackupServiceRolePolicyForBackup



AWSTemplateFormatVersion: 2010-09-09
Description: Role to allow starting an EC2 instance

Resources:
  EC2StartRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: chenna1role
      Path: /gwf/apps/
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service: 'ec2.amazonaws.com'
            Action: 'sts:AssumeRole'
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonEC2FullAccess



AWSTemplateFormatVersion: 2010-09-09
Description: Policy to allow the starting of an EC2
Resources:
  EC2StartPolicy:
    Type: 'AWS::IAM::ManagedPolicy'
    Properties:
      ManagedPolicyName: chenna1policy
      Path: /gwf/apps/
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: 'logs:*'
            Resource: 'arn:aws:logs:::*'
          - Effect: Allow
            Action: 'ec2:*'
            Resource: 'arn:aws:ec2:::*'



AWSTemplateFormatVersion: "2010-09-09"
Description: Lambda Role with EC2 and CloudWatch Logs Permissions

Resources:
  Chennatest1LambdaRole:
    Type: "AWS::IAM::Role"
    Properties:
      RoleName: "chennatest1"
      Path: "/gwf/apps/chennatest/"
      PermissionsBoundary: "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service:
                - "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      # Attach policies for Lambda to perform basic tasks and the custom permissions
      ManagedPolicyArns: 
        - "arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole"
      Policies:
        - PolicyName: "CustomEC2AndCloudWatchPermissions"
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              # Permissions for CloudWatch Logs
              - Effect: "Allow"
                Action: 
                  - "logs:CreateLogGroup"
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "arn:aws:logs:*:*:*"
              # Permissions to start and stop EC2 instances
              - Effect: "Allow"
                Action: 
                  - "ec2:Start*"
                  - "ec2:Stop*"
                Resource: "*"





AWSTemplateFormatVersion: "2010-09-09"Description: Compliance Lambda IAM Role with an Empower permissions boundaryResources:ComplianceLambdaS3Read:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaS3Read'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonS3FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole'ComplianceLambdaEC2Full:Type: 'AWS::IAM::Role'Properties:RoleName: 'ComplianceLambdaEC2Full'Path: /gwf/apps/compliance/PermissionsBoundary: !Sub"arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"ManagedPolicyArns:["arn:aws:iam::aws:policy/AWSLambda_FullAccess","arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole","arn:aws:iam::aws:policy/AmazonEC2FullAccess"]AssumeRolePolicyDocument:Version: '2012-10-17'Statement:-Effect: AllowPrincipal:Service:-'lambda.amazonaws.com'Action: 'sts:AssumeRole

{
  "AWSTemplateFormatVersion": "2010-09-09",
  "Description": "IAM Role with a permissions boundary for MyApp",
  "Resources": {
    "MyAppRole": {
      "Type": "AWS::IAM::Role",
      "Properties": {
        "RoleName": "MyAppRole-EC2Access",
        "Path": "/gwf/apps/MyApp/",
        "PermissionsBoundary": "arn:aws:iam::123456789012:policy/gwf/boundaries/apps/MyAppPermissionsBoundary",
        "AssumeRolePolicyDocument": {
          "Version": "2012-10-17",
          "Statement": [
            {
              "Effect": "Allow",
              "Principal": {
                "Service": [
                  "ec2.amazonaws.com"
                ]
              },
              "Action": "sts:AssumeRole"
            }
          ]
        }
      }
    }
  }
}





Updates:

The /gwf/operations/CDTOperator role has been updated in each account to enable permissions boundary

Assumptions / Requirements:
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Least Preferred Method: Create a Role with Permissions Boundary using CLI
Notes from Matt / SS-Prod example as of 10/24/2018
This page contains the draft directions for how to create IAM roles within a permission boundary.

Assumptions / Requirements:
You must assume an AWS role with permissions to create roles.
Roles may be created with CLI or CloudFormation.  
Currently, roles cannot be created using the console because Path is unsupported in the IAM console.
Roles must be created within the /gwf/apps/app_name/ path.  
Attempts to create roles that are in this path will result in an Access Denied message.
Policies must be created within the /gwf/apps/app_name/ path.  
Attempts to create policies that are not in this path will result in an Access Denied message.
Attempts to create roles with attached policies that are not in this path will result in an Access Denied message.
Attempts to create roles with AWS Managed Policies attached will result in an Access Denied message.
Create a Customer Managed version of the AWS Managed Policy, but replace any reference to Resource: "*" with an IAM Best Practice.
A permissions boundary must be attached to the role at the time of role creation.  There are two policies to choose from:
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services and need to create other roles.
arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM
This policy is intended to be used by roles that need to interact with Great-West Approved AWS Services.
Preferred Method: Create a Role with Permissions Boundary using CloudFormation
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
A CloudFormation template.
Instructions:

Create a CloudFormation role template that includes the following properties:
AssumeRolePolicyDocument
Also known as a "trust policy."  See IAM Best Practices: IAM for examples of common trust policy patterns and code snippets.
ManagedPolicyArns
Managed Policies can be created in the same CloudFormation template and passed by reference.
Path
See AWS IAM and Path for details.
RoleName
Roles should follow a descriptive naming standard of <App_Name>-Description.  For example, if my application is called underwaterbasketweaver, I might create a role called UnderwaterBasketWeaver-LambdaWriteToS3Role.
Launch the CloudFormation stack from the template.
An example CloudFormation template in YAML format might look something like:

SampleRole
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
---
AWSTemplateFormatVersion: "2010-09-09"
Description: IAM Role with a permissions boundary
Resources:
  TestRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: 'PermissionBoundaryTestRole'
      Path: /gwf/apps/
      PermissionsBoundary: !Sub "arn:aws:iam::${AWS::AccountId}:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM"
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
        - Effect: Allow
          Principal:
            Service:
            - 'ec2.amazonaws.com'
          Action: 'sts:AssumeRole'


Least Preferred Method: Create a Role with Permissions Boundary using CLI
Requirements:

Access to AssumeRole to the /gwf/operations/CDTOperator or <Account_Name>-FullStackTeam role.
Shell access on is-xcloud05nb to obtain federated CLI credentials.
The ARN of an existing permissions boundary to attach to the Role (arn:aws:iam::<accountnumber>:policy/gwf/boundaries/apps/<boundaryname>).
The trust document for the role in json format.


Instructions:

Login to is-xcloud05nb using LDAP/Active Directory credentials

directions to create SAML token

federate in as /gwf/operations/CDTOperator role for the account that needs the role.

When creating the role, you will need a json file containing a trust policy which defines what service will be using the role.  There are some examples of trust policies in the IAM Best Practices guide. Here is an example for an EC2 role:

ec2trust.json
1
2
3
4
5
6
7
8
9
10
11
12
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
Create a role with a particular boundary:  



[dfgkwg@is-xcloud05nb iamRoleTesting]$ aws iam create-role \
--permissions-boundary arn:aws:iam::<Account_Number>:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM \
--role-name testRole3 --assume-role-policy-document file://ec2trust.json \
--path /gwf/apps/<App_name> --profile iamtest

aws iam create-role --permissions-boundary <FULL PERMISSION BOUNDARY ARN> --role-name <ROLE NAME> --assume-role-policy-document file://<PATH TO TRUST DOCUMENT>.json --path /gwf/apps/<APP NAME>/ --profile saml

You should a response similar to the following:

create role output
1
{ "Role": { "PermissionsBoundary": { "PermissionsBoundaryType": "Policy", "PermissionsBoundaryArn": "arn:aws:iam::499776071476:policy/gwf/boundaries/apps/GwfAppPermissionsBoundaryWithoutIAM" }, "AssumeRolePolicyDocument": { "Version": "2012-10-17", "Statement": [ { "Action": "sts:AssumeRole", "Effect": "Allow", "Principal": { "Service": "ec2.amazonaws.com" } } ] }, "RoleId": "AROAJRPI3P7H4TDI7EHCI", "CreateDate": "2018-10-05T17:13:27Z", "RoleName": "testRole3", "Path": "/gwf/apps/underwaterbasketweaver", "Arn": "arn:aws:iam::499776071476:role/gwf/apps/underwaterbasketweaver/testRole3" }
Create a permissions policy with a path of /gwf/apps/<App_Name>/.

CLI to create IAM policy
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
[user@is-xcloud05nb iamRoleTesting]$ aws iam create-policy --policy-name testPolicyName2 --policy-document file://testPolicy.json --profile iamtest --path /gwf/apps/underwaterbasketweaver/
 {     "Policy":
      {
         "PolicyName": "testPolicyName2",
         "PermissionsBoundaryUsageCount": 0,
         "CreateDate": "2018-10-05T17:20:04Z",
         "AttachmentCount": 0,
         "IsAttachable": true,
         "PolicyId": "ANPAITVBCUQSQA3BHFDJM",
         "DefaultVersionId": "v1",
         "Path": "/gwf/service/",
         "Arn": "arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2",
         "UpdateDate": "2018-10-05T17:20:04Z"
     }
}
Attach the permissions policy to the role.  This step may be performed using the Console once the role and permissions policy in the app-specific path have been created.

CLI to attach IAM policy
1
2
aws iam attach-role-policy --role-name testRole3 --policy-arn arn:aws:iam::499776071476:policy/gwf/apps/underwaterbasketweaver/testPolicyName2 \
--profile iamtest
Diagram


Boundary      
Delegated IAM Administrator
EC2 Instance Boundary
Lambda Boundary
Other Boundaries
Newly Created Roles
arn:aws:iam::role/gwf/service/<ROLE>
CreateBoundedIamPolicy
Required
Boundary
Policies
IAM Administrator
Role managed by Security
Policy managed by Security
Role managed by CDT
Policy managed by CDT
arn:aws:iam::policy/gwf/boundary/*
arn:aws:iam::policy/gwf/service/<POLICY>
Security creates boundaries
based on reasonable and frequent
access requirements in partnership with
the CDT / Application teams
CDT IAM Admins are able to
create new roles and policies,
if and only if they attach an
existing boundary to the role
         Policy
Boundary      
Effective
Permissions
         Policy





Boundary      
Effective
Permissions
Effective
Permissions


arn:aws:iam::role/gwf/operations/<ROLE>
arn:aws:iam::role/gwf/security/<ROLE>
Legend
Effective Permissions using Permissions Boundary
Delegating IAM Administration using Permissions Boundary
Logical Design
- Sid: AllowAttachPermBoundary
  Effect: Allow
  Action:
  - iam:DetachRolePolicy
  - iam:AttachRolePolicy
  - iam:DeleteRolePolicy
  - iam:PutRolePermissionsBoundary
  - iam:CreateRole
  - iam:PutRolePolicy
  Resource: arn:aws:iam:::role/gwf/service/*
  Condition:
    StringLike:
      iam:PermissionsBoundary: arn:aws:iam::*:policy/gwf/boundaries/*

- Sid: AllowOtherIAMActions
  Effect: Allow
  Action:
  - iam:AddRoleToInstanceProfile
  - iam:CreateInstanceProfile
  - iam:CreatePolicy
  - iam:CreatePolicyVersion
  - iam:DeleteInstanceProfile
  - iam:DeletePolicy
  - iam:DeleteRole
  - iam:UpdateRole
  - iam:UpdateRoleDescription
  - iam:RemoveRoleFromInstanceProfile
  Resource:
  - arn:aws:iam:::role/gwf/service/*
  - arn:aws:iam:::policy/gwf/service/*
  - arn:aws:iam:::instance-profile/gwf/service/*

Delegating IAM Administration using Permissions Boundary
Physical Design
arn:aws:iam::role/gwf/operations/DelegatedIAMAdmin
ExampleBlacklistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: blacklist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: BoundaryAllowance
        Effect: Allow
        Action: '*'
        Resource: '*'
      - Sid:DenyNotApprovedAction
        Effect:Deny
        Action:
        - iam:*
        - organizations:*
        Resource:'*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
      
ExampleWhitelistBoundary:
  Type: 'AWS::IAM::ManagedPolicy'
  Properties:
    ManagedPolicyName: whitelist-specific-actions-boundary
    Path: /gwf/boundaries/
    PolicyDocument:
      Version: 2012-10-17
      Statement:
      - Sid: AllowActions
        Effect: Allow
        Action: 
        - 's3:GetObject'
        - 'ssm:*'
        - 'logs:*'
        Resource: '*'
      - Sid: DenyNotApprovedRegions
        Action: '*'
        Resource: '*'
        Effect: Deny
        Condition:
          StringNotEquals:
            'aws:RequestedRegion':
            - us-west-2
            - us-east-1
        Resource: '*'
Matt Helgen
10/5/2018
Policy
Error Messages
message 1


message 2


message 3


(---------- if you need this -----------------)






Notes from Matt / SS-Prod example as of 10/24/2018
here’s the commands I ran in the sharedservices prod account to create the role, after federating into the CDTOperator role on is-xcloud05nb
 
aws iam create-role \
--permissions-boundary arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary \
--role-name mtthlg-test \
--assume-role-policy-document file://ec2trust.json \
--path /gwf/operations/services/ \
--profile saml

Returns:
{
    "Role": {
        "PermissionsBoundary": {
            "PermissionsBoundaryType": "Policy",
            "PermissionsBoundaryArn": "arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary"
        },
        "AssumeRolePolicyDocument": {
            "Version": "2012-10-17",
            "Statement": [
                {
                    "Action": "sts:AssumeRole",
                    "Effect": "Allow",
                    "Principal": {
                        "Service": "ec2.amazonaws.com"
                    }
                }
            ]
        },
        "RoleId": "AROAJSWTGLMITKAYZG35K",
        "CreateDate": "2018-10-24T16:49:37Z",
        "RoleName": "mtthlg-test",
        "Path": "/gwf/operations/services/",
        "Arn": "arn:aws:iam::676428981261:role/gwf/operations/services/mtthlg-test"
    }
}
 
For the boundaries, we’ve created 2 empty boundaries which can be used for testing in every account (the account number will differ by account)
 
arn:aws:iam::676428981261:policy/gwf/boundaries/operations/OperationsTestBoundary  
arn:aws:iam::676428981261:policy/gwf/boundaries/apps/AppsTestBoundary
 
For the ec2trust.json file, this depends on what the role will be used for, here is the example file content for if we are creating an ec2 role, the trust policy will depend on what service needs to use the role:
 
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Principal": {
        "Service": "ec2.amazonaws.com"
      },
      "Action": "sts:AssumeRole"
    }
  ]
}
After this role is created, you should be able to manage it via the console, or create new policies in cloudformation and attach them to this role. Only the initial creation of the role itself needs to be done via CLI, until the “PermissionsBoundary” option is available as part of the AWS::IAM::Role cloudformation resource properties.







Resources:



Permission Boundary links recommended by Unknown User (rjskkn) on 4 February 2019:

https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html
https://aws.amazon.com/blogs/security/delegate-permission-management-to-developers-using-iam-permissions-boundaries/
https://www.youtube.com/watch?v=YQsK4MtsELU


https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_actions-resources-contextkeys.html was a recommended reference to understand adding AWS services to IAM policies from Matt Helgen in October 2018






LikeBe the first to like this
No labelsEdit Labels
User icon: Add a picture of yourself




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaEC2LogsPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:us-east-1:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:Start*'
                  - 'ec2:Stop*'
                Resource: 'arn:aws:ec2:us-east-1:*:instance/*'

Outputs:
  LambdaRole:
    Value: !Ref LambdaExecutionRole
    Description: The IAM role ARN for Lambda execution




AWSTemplateFormatVersion: '2010-09-09'
Resources:

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: 'LambdaExecutionPolicy'
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128





AWSTemplateFormatVersion: '2010-09-09'
Resources:
  
  # Create the IAM Policy
  LambdaExecutionPolicy:
    Type: 'AWS::IAM::Policy'
    Properties:
      PolicyName: 'LambdaExecutionPolicy'
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Action:
              - 'logs:CreateLogGroup'
              - 'logs:CreateLogStream'
              - 'logs:PutLogEvents'
            Resource: 'arn:aws:logs:*:*:*'
          - Effect: Allow
            Action:
              - 'ec2:StartInstances'
              - 'ec2:StopInstances'
            Resource: '*'
      Roles:
        - !Ref LambdaExecutionRole

  # Create the IAM Role for Lambda function
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'

  # Create the Lambda function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          ec2 = boto3.client('ec2')
          
          def lambda_handler(event, context):
              instance_id = 'i-0488b8da2a2809c51'  # Replace with your EC2 instance ID
              
              # Check instance state
              response = ec2.describe_instances(InstanceIds=[instance_id])
              state = response['Reservations'][0]['Instances'][0]['State']['Name']
              print(f"Current state of instance {instance_id}: {state}")
              
              # Start the instance if it is stopped
              if state == 'stopped':
                  ec2.start_instances(InstanceIds=[instance_id])
                  print(f"Starting instance {instance_id}")
              else:
                  print(f"Instance {instance_id} is already running")
                  
              return {
                  'statusCode': 200,
                  'body': json.dumps('EC2 Instance Managed')
              }
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128




AWSTemplateFormatVersion: '2010-09-09'
Resources:
  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: 'AWS::IAM::Role'
    Properties: 
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: 'sts:AssumeRole'
      Policies:
        - PolicyName: LambdaExecutionPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: 'arn:aws:logs:*:*:*'
              - Effect: Allow
                Action:
                  - 'ec2:StartInstances'
                  - 'ec2:StopInstances'
                Resource: '*'

  # Lambda Function
  MyLambdaFunction:
    Type: 'AWS::Lambda::Function'
    Properties: 
      Handler: 'index.lambda_handler'
      Role: !GetAtt LambdaExecutionRole.Arn
      Code: 
        S3Bucket: 'your-lambda-code-bucket'
        S3Key: 'your-lambda-code.zip'
      Runtime: 'python3.9'
      Timeout: 120
      MemorySize: 128

  # CloudWatch log group for Lambda
  LambdaLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Properties:
      LogGroupName: !Sub '/aws/lambda/${MyLambdaFunction}'
      RetentionInDays: 14




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "ec2:Start*",
        "ec2:Stop*"
      ],
      "Resource": "*"
    }
  ]
}




{'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': '45922bac-072d-484d-83ba-50770d2da1ee', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': '45922bac-072d-484d-83ba-50770d2da1ee', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Mon, 23 Sep 2024 13:54:50 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}
END RequestId: 82f2b6c6-2835-4335-b43b-33c52667dd08

INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e
REPORT RequestId: 8bcf2d0d-8e8b-4216-a981-a62271d8c22e	Duration: 1256.09 ms	Billed Duration: 1257 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 570.13 ms	
START RequestId: 70e884fd-d13b-425f-8832-a35244b00733 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
END RequestId: 70e884fd-d13b-425f-8832-a35244b00733
REPORT RequestId: 70e884fd-d13b-425f-8832-a35244b00733	Duration: 1117.61 ms	Billed Duration: 1118 ms	Memory Size: 128 MB	Max Memory Used: 87 MB

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            try:
                ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
                print(f"Starting instance {INSTANCE_ID}")
            except Exception as e:
                print(f"exception is {e}");
            
           
            
            # # Wait for the instance to be in running state
            # retry_count = 0
            # max_retries = 4
            # while retry_count < max_retries:
            #     response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
            #     current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
            #     print(f"Current state after start attempt: {current_state}")
                
            #     if current_state == 'running':
            #         print(f"Instance {INSTANCE_ID} is now running.")
            #         break
            #     elif current_state == 'stopped':
            #         print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
            #         retry_count += 1;
            #         time.sleep(4)  # Wait before checking again
            #     else:
            #         print("instance is in unexpected state")
            #         break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # # Send error message via SNS
        # sns_client.publish(
        #     TopicArn=SNS_TOPIC_ARN,
        #     Subject='Error starting EC2 instance',
        #     Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        # )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send escalation email via SNS
def send_escalation_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Escalation Alert: Instance {instance_name} ({instance_id})"
    body = f"Instance {instance_name} ({instance_id}) is still in a stopped state after 1 hour."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to check if the instance is still stopped
def is_instance_stopped(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_state = instance['State']['Name']
        return instance_state == 'stopped'
    return False

def lambda_handler(event, context):
    # Extract instance ID and name from the event
    instance_id = event['instance-id']
    instance_name = event['instance-name']

    # Check if the instance is still stopped
    if is_instance_stopped(instance_id):
        # Send escalation email
        send_escalation_email(instance_id, instance_name)

    return {
        "message": f"Escalation email sent for instance {instance_id}."
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send an initial email via SNS
def send_email(instance_id, instance_name):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) Alert"
    body = f"Instance {instance_name} ({instance_id}) is in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get instance name
def get_instance_name(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        return instance_name
    return None

def lambda_handler(event, context):
    # Extract instance ID from the event
    instance_id = event['detail']['instance-id']

    # Get instance name
    instance_name = get_instance_name(instance_id) or "Unnamed Instance"

    # Send the email
    send_email(instance_id, instance_name)

    return {
        "message": f"Initial email sent for instance {instance_id}.",
        "instance-id": instance_id,
        "instance-name": instance_name
    }



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




https://app.diagrams.net/?src=about
INIT_START Runtime Version: python:3.12.v30	Runtime Version ARN: arn:aws:lambda:us-east-1::runtime:acd6500d0e3f6a085fb07933e3472ed6e58360d19ec5dd91bc7c7e8ad119de42
START RequestId: ccf2649f-086a-441a-8309-9960e57577f2 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: ccf2649f-086a-441a-8309-9960e57577f2
REPORT RequestId: ccf2649f-086a-441a-8309-9960e57577f2	Duration: 41737.89 ms	Billed Duration: 41738 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 567.85 ms	


import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            retry_count = 0
            max_retries = 4
            while retry_count < max_retries:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                    retry_count += 1;
                    time.sleep(10)  # Wait before checking again
                else:
                    print("instance is in unexpected state")
                    break

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Test Event Name
inputdata

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86 Version: $LATEST
Current state of instance i-0488b8da2a2809c51: stopped
Starting instance i-0488b8da2a2809c51
Current state after start attempt: stopped
Instance i-0488b8da2a2809c51 is still stopped, retrying...
END RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86
REPORT RequestId: 7c5fad82-989a-42db-ac8a-96df2d23ff86	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 87 MB	Init Duration: 534.24 ms	Status: timeout

Request ID
7c5fad82-989a-42db-ac8a-96df2d23ff86

import boto3
import os
import time

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        print(f"Current state of instance {INSTANCE_ID}: {state}")
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
            
            # Wait for the instance to be in running state
            while True:
                response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
                current_state = response['Reservations'][0]['Instances'][0]['State']['Name']
                print(f"Current state after start attempt: {current_state}")
                
                if current_state == 'running':
                    print(f"Instance {INSTANCE_ID} is now running.")
                    break
                elif current_state == 'stopped':
                    print(f"Instance {INSTANCE_ID} is still stopped, retrying...")
                time.sleep(10)  # Wait before checking again

        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e


Starting instance i-0488b8da2a2809c51 {'StartingInstances': [{'CurrentState': {'Code': 0, 'Name': 'pending'}, 'InstanceId': 'i-0488b8da2a2809c51', 'PreviousState': {'Code': 80, 'Name': 'stopped'}}], 'ResponseMetadata': {'RequestId': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'HTTPStatusCode': 200, 'HTTPHeaders': {'x-amzn-requestid': 'a87a4724-fa0c-4e00-8938-ff9c681ad703', 'cache-control': 'no-cache, no-store', 'strict-transport-security': 'max-age=31536000; includeSubDomains', 'content-type': 'text/xml;charset=UTF-8', 'content-length': '411', 'date': 'Sat, 21 Sep 2024 10:50:18 GMT', 'server': 'AmazonEC2'}, 'RetryAttempts': 0}}

import boto3
import os

# Initialize clients
ec2_client = boto3.client('ec2')
sns_client = boto3.client('sns')

# Get SNS topic ARN and instance ID from environment variables
SNS_TOPIC_ARN = os.environ['SNS_TOPIC_ARN']
INSTANCE_ID = os.environ['INSTANCE_ID']

def lambda_handler(event, context):
    try:
        # Describe instance to check status
        response = ec2_client.describe_instances(InstanceIds=[INSTANCE_ID])
        
        # Get instance state
        state = response['Reservations'][0]['Instances'][0]['State']['Name']
        
        if state == 'stopped':
            # If instance is stopped, start it
            ec2_client.start_instances(InstanceIds=[INSTANCE_ID])
            print(f"Starting instance {INSTANCE_ID}")
        else:
            print(f"Instance {INSTANCE_ID} is already in '{state}' state")
    
    except Exception as e:
        print(f"Error occurred: {str(e)}")
        
        # Send error message via SNS
        sns_client.publish(
            TopicArn=SNS_TOPIC_ARN,
            Subject='Error starting EC2 instance',
            Message=f"Failed to start instance {INSTANCE_ID}. Error: {str(e)}"
        )
        
        # Optionally re-raise the error if you want Lambda to retry or fail
        raise e



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Global dictionary to track sent emails
sent_emails = {}

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Check if this instance ID has already had emails sent
    if instance_id not in sent_emails:
        sent_emails[instance_id] = {'initial_sent': False, 'escalation_sent': False}

    # Send the initial email when the instance is first stopped
    if instance_state == 'stopped' and not sent_emails[instance_id]['initial_sent']:
        send_email(instance_id, instance_name)
        sent_emails[instance_id]['initial_sent'] = True

    # If the instance is still in a stopped state, send the escalation email
    if instance_state == 'stopped' and not sent_emails[instance_id]['escalation_sent']:
        send_email(instance_id, instance_name, escalation=True)
        sent_emails[instance_id]['escalation_sent'] = True

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output




{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": "states:StartExecution",
      "Resource": "arn:aws:states:REGION:ACCOUNT_ID:stateMachine:STATE_MACHINE_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "sns:Publish",
      "Resource": "arn:aws:sns:REGION:ACCOUNT_ID:TOPIC_NAME"
    },
    {
      "Effect": "Allow",
      "Action": "ec2:DescribeInstances",
      "Resource": "*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:REGION:ACCOUNT_ID:*"
    }
  ]
}



import boto3
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, instance_name, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_name} ({instance_id}) {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_name} ({instance_id}) is {'still' if escalation else ''} in a stopped state."

    sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

# Function to get the instance name and state
def get_instance_name_and_state(instance_id):
    response = ec2_client.describe_instances(InstanceIds=[instance_id])
    if response['Reservations']:
        instance = response['Reservations'][0]['Instances'][0]
        
        # Get instance state
        instance_state = instance['State']['Name']
        
        # Retrieve the instance name from tags
        instance_name = None
        for tag in instance.get('Tags', []):
            if tag['Key'] == 'Name':
                instance_name = tag['Value']
                break
        
        return instance_name, instance_state
    return None, None  # Instance not found or no tags available

def lambda_handler(event, context):
    # Extract instance ID directly from the event
    instance_id = event['detail']['instance-id']

    # Get instance name and state
    instance_name, instance_state = get_instance_name_and_state(instance_id)
    
    if not instance_name:
        instance_name = "Unnamed Instance"

    # Send the initial email when the instance is first stopped
    send_email(instance_id, instance_name)

    # If the instance is still in a stopped state, send the escalation email after some time
    if instance_state == 'stopped':
        send_email(instance_id, instance_name, escalation=True)

    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id,
            "instance-name": instance_name
        }
    }

    # Return the output with instance name and ID
    return output


-----
{
  "statusCode": 200,
  "body": "{\"detail\": {\"instance-id\": \"i-0488b8da2a2809c51\"}}"
}
output:
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "bba3f772-b551-4e65-a291-ec06a01b78bc",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 37, in lambda_handler\n    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda\n"
  ]
}
code:

import boto3
import time
import os
import json

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available


def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }






-------
import json

def lambda_handler(event, context):
    # Simulate getting the instance ID (you would retrieve this from the event in practice)
    instance_id = event['detail']['instance-id']  # Extracted from the event that triggered this Lambda
    
    # Prepare the output structure
    output = {
        "detail": {
            "instance-id": instance_id
        }
    }

    # Return the output
    return {
        'statusCode': 200,
        'body': json.dumps(output)
    }



{
  "errorMessage": "'NoneType' object is not subscriptable",
  "errorType": "TypeError",
  "requestId": "bd316927-5a89-481c-89e9-f940a8a129ef",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}



The principal states.amazonaws.com is not authorized to assume the provided role. (role: arn:aws:iam::563003501456:role/gwf/apps/compliance/ComplianceLambdaEC2Chenna1)

{
  "Comment": "State machine to handle EC2 instance stop alerts and escalation",
  "StartAt": "InitialCheck",
  "States": {
    "InitialCheck": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<InitialEmailFunction>",
      "Next": "Wait1Hour"
    },
    "Wait1Hour": {
      "Type": "Wait",
      "Seconds": 3600,
      "Next": "CheckInstanceState"
    },
    "CheckInstanceState": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:<region>:<account-id>:function:<RecheckEmailFunction>",
      "End": true
    }
  }
}


Test Event Name
event1

Response
{
  "errorType": "Sandbox.Timedout",
  "errorMessage": "RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Error: Task timed out after 3.00 seconds"
}

Function Logs
START RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f Version: $LATEST
END RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f
REPORT RequestId: ec3fd342-3d6f-480f-963f-42bf39870b2f	Duration: 3000.00 ms	Billed Duration: 3000 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 455.70 ms	Status: timeout

Request ID
ec3fd342-3d6f-480f-963f-42bf39870b2f

{
  "version": "0",
  "id": "c8c7bf83-0ce5-4b94-953e-0d332c7611b5",
  "detail-type": "EC2 Instance State-change Notification",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2023-09-20T18:40:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0abcd1234efgh5678"
  ],
  "detail": {
    "instance-id": "i-0abcd1234efgh5678",
    "state": "stopped"
  }
}



hello i am chenna 
{
  "version": "0",
  "id": "12345678-1234-1234-1234-1234567890ab",
  "source": "aws.ec2",
  "account": "123456789012",
  "time": "2024-09-18T10:00:00Z",
  "region": "us-west-2",
  "resources": [
    "arn:aws:ec2:us-west-2:123456789012:instance/i-0488b8da2a2809c51"
  ],
  "detail-type": "EC2 Instance State-change Notification",
  "detail": {
    "instance-id": "i-0488b8da2a2809c51",
    "state": "stopped"
  }
}

{
  "instanceId": "$.detail.instance-id",
  "state": "$.detail.state",

  "time": "$.time"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}

{
  "default": "Instance {{instanceId}} has entered the state: {{state}} at {{time}}.",
  "email": "ALERT: EC2 instance {{instanceId}} has been stopped at {{time}}. Please check the instance status immediately!"
}
{
  "source": ["aws.ec2"],
  "detail-type": ["EC2 Instance State-change Notification"],
  "detail": {
    "state": ["stopped"],
    "instance-id": ["i-0488b8da2a2809c51"]
  }
}
Test Event Name
chennaStopInstance

Response
{
  "errorMessage": "Handler 'Hello::handleRequest' missing on module 'example'",
  "errorType": "Runtime.HandlerNotFound",
  "requestId": "",
  "stackTrace": []
}

Function Logs
[ERROR] Runtime.HandlerNotFound: Handler 'Hello::handleRequest' missing on module 'example'
Traceback (most recent call last):INIT_REPORT Init Duration: 310.36 ms	Phase: invoke	Status: error	Error Type: Runtime.Unknown
START RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32 Version: $LATEST
END RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32
REPORT RequestId: 84cb5abc-c4c1-4409-b195-b34f955f5c32	Duration: 341.22 ms	Billed Duration: 342 ms	Memory Size: 512 MB	Max Memory Used: 42 MB	Status: error	Error Type: Runtime.Unknown

Request ID
84cb5abc-c4c1-4409-b195-b34f955f5c32



import boto3
import time
import os

# Clients for SNS and EC2
sns_client = boto3.client('sns')
ec2_client = boto3.client('ec2')

# Function to send email via SNS
def send_email(instance_id, escalation=False):
    topic_arn = os.environ['SNS_TOPIC_ARN']  # SNS Topic ARN from environment variable
    subject = f"Instance {instance_id} {'Escalation' if escalation else ''} Alert"
    body = f"Instance {instance_id} is {'still' if escalation else ''} in a stopped state."

    response = sns_client.publish(
        TopicArn=topic_arn,
        Message=body,
        Subject=subject
    )

    return response

# Function to check the instance state
def check_instance_state(instance_id):
    response = ec2_client.describe_instance_status(InstanceIds=[instance_id])
    if response['InstanceStatuses']:
        instance_state = response['InstanceStatuses'][0]['InstanceState']['Name']
        return instance_state
    else:
        return None  # Instance not found or no state available

# Lambda handler function
def lambda_handler(event, context):
    # Get instance ID from event (triggered by EventBridge)
    instance_id = event['detail']['instance-id']
    
    # Send the initial email when the instance is first stopped
    send_email(instance_id)
    
    # Wait for 1 hour
    time.sleep(3600)  # 3600 seconds = 1 hour
    
    # Check the instance state again after 1 hour
    instance_state = check_instance_state(instance_id)
    
    # If the instance is still in 'stopped' state, send the escalation email
    if instance_state == 'stopped':
        send_email(instance_id, escalation=True)
    
    return {
        'statusCode': 200,
        'body': f'Email sent successfully for instance {instance_id}.'
    }

Test Event Name
event1

Response
{
  "errorMessage": "'detail'",
  "errorType": "KeyError",
  "requestId": "943b4064-98ae-40b4-bb88-d5bf8b59bfba",
  "stackTrace": [
    "  File \"/var/task/lambda_function.py\", line 36, in lambda_handler\n    instance_id = event['detail']['instance-id']\n"
  ]
}

Function Logs
START RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba Version: $LATEST
LAMBDA_WARNING: Unhandled exception. The most likely cause is an issue in the function code. However, in rare cases, a Lambda runtime update can cause unexpected function behavior. For functions using managed runtimes, runtime updates can be triggered by a function change, or can be applied automatically. To determine if the runtime has been updated, check the runtime version in the INIT_START log entry. If this error correlates with a change in the runtime version, you may be able to mitigate this error by temporarily rolling back to the previous runtime version. For more information, see https://docs.aws.amazon.com/lambda/latest/dg/runtimes-update.html
[ERROR] KeyError: 'detail'
Traceback (most recent call last):
  File "/var/task/lambda_function.py", line 36, in lambda_handler
    instance_id = event['detail']['instance-id']END RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba
REPORT RequestId: 943b4064-98ae-40b4-bb88-d5bf8b59bfba	Duration: 6.27 ms	Billed Duration: 7 ms	Memory Size: 128 MB	Max Memory Used: 89 MB	Init Duration: 432.06 ms

Request ID
943b4064-98ae-40b4-bb88-d5bf8b59bfba
